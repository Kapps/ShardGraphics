/++
	Provides a wrapper for OpenGL functions, and easy loading of the functions.
	In order to load functions, LoadGLExtensions() must be called.
	By default, functions are loaded with glfw. This may be swapped by changing the function getExtensionAddress(string).
	This file is generated by parsing the OpenGL man pages, and as such may be subject to the license used by them.
	Otherwise, the license is Boost.
	OpenGL Man Page License: This material may be distributed subject to the terms and conditions set forth in the $(WEB http://opencontent.org/openpub/, Open Publication License, v 1.0, 8 June 1999).
+/
module glfuncs;

// TODO: Make the function pointers originally a function pointer that validates if the extension is set (aka, getExtensionAddress does not return null),
// and if it is set, replace the function pointer with the actual gl function pointer, otherwise throw an exception.

private import glfw;
private import std.string;
public import gltypes;

/// Returns the address of the given extension (such as glActiveTexture) or null if the extension was either not found or not supported.
private void* getExtensionAddress(string name) {
	return glfwGetProcAddress(toStringz(name));
}

extern(System) {
	/// Set the active program object for a program pipeline object.
	/// 
	/// glActiveShaderProgram sets the linked program named by program
	/// to be the active program for the program pipeline object pipeline. The active
	/// program in the active program pipeline object is the target of calls to glUniform
	/// when no program has been made current through a call to glUseProgram.
	__gshared void function(GLuint pipeline, GLuint program) glActiveShaderProgram;
	/// Select active texture unit.
	/// 
	/// glActiveTexture selects which texture unit subsequent texture state calls will
	/// affect. The number of texture units an implementation supports is
	/// implementation dependent, but must be at least 80.
	__gshared void function(GLenum texture) glActiveTexture;
	/// Attaches a shader object to a program object.
	/// 
	/// In order to create a complete shader program, there must be a way to
	/// specify the list of things that will be linked together. Program
	/// objects provide this mechanism. Shaders that are to be linked
	/// together in a program object must first be attached to that
	/// program object. glAttachShader attaches the
	/// shader object specified by shader to the
	/// program object specified by program. This
	/// indicates that shader will be included in
	/// link operations that will be performed on
	/// program.
	/// 
	/// All operations that can be performed on a shader object
	/// are valid whether or not the shader object is attached to a
	/// program object. It is permissible to attach a shader object to a
	/// program object before source code has been loaded into the
	/// shader object or before the shader object has been compiled. It
	/// is permissible to attach multiple shader objects of the same
	/// type because each may contain a portion of the complete shader.
	/// It is also permissible to attach a shader object to more than
	/// one program object. If a shader object is deleted while it is
	/// attached to a program object, it will be flagged for deletion,
	/// and deletion will not occur until
	/// glDetachShader
	/// is called to detach it from all program objects to which it is
	/// attached.
	__gshared void function(GLuint program, GLuint shader) glAttachShader;
	/// Start conditional rendering.
	/// 
	/// Conditional rendering is started using glBeginConditionalRender and ended using glEndConditionalRender.
	/// During conditional rendering, all vertex array commands, as well as glClear and
	/// glClearBuffer have no effect if the (GL_SAMPLES_PASSED) result
	/// of the query object id is zero, or if the (GL_ANY_SAMPLES_PASSED) result is GL_FALSE.
	/// The results of commands setting the current vertex state, such as glVertexAttrib are
	/// undefined. If the (GL_SAMPLES_PASSED) result is non-zero or if the (GL_ANY_SAMPLES_PASSED) result is
	/// GL_TRUE, such commands are not discarded. The id parameter to glBeginConditionalRender
	/// must be the name of a query object previously returned from a call to glGenQueries.
	/// mode specifies how the results of the query object are to be interpreted. If mode is
	/// GL_QUERY_WAIT, the GL waits for the results of the query to be available and then uses the results to determine if subsequent
	/// rendering commands are discarded. If mode is GL_QUERY_NO_WAIT, the GL may choose to unconditionally
	/// execute the subsequent rendering commands without waiting for the query to complete.
	/// 
	/// 
	/// 
	/// If mode is GL_QUERY_BY_REGION_WAIT, the GL will also wait for occlusion query results and discard
	/// rendering commands if the result of the occlusion query is zero. If the query result is non-zero, subsequent rendering commands are executed,
	/// but the GL may discard the results of the commands for any region of the framebuffer that did not contribute to the sample count in the specified
	/// occlusion query. Any such discarding is done in an implementation-dependent manner, but the rendering command results may not be discarded for
	/// any samples that contributed to the occlusion query sample count. If mode is GL_QUERY_BY_REGION_NO_WAIT,
	/// the GL operates as in GL_QUERY_BY_REGION_WAIT, but may choose to unconditionally execute the subsequent rendering commands
	/// without waiting for the query to complete.
	__gshared void function(GLuint id, GLenum mode) glBeginConditionalRender;
	/// Ditto
	__gshared void function() glEndConditionalRender;
	/// Delimit the boundaries of a query object.
	/// 
	/// glBeginQuery and glEndQuery delimit the
	/// boundaries of a query object. query must be a name previously returned from a call to
	/// glGenQueries. If a query object with name id
	/// does not yet exist it is created with the type determined by target. target must
	/// be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED,
	/// GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. The behavior of the query
	/// object depends on its type and is as follows.
	/// 
	/// 
	/// 
	/// If target is GL_SAMPLES_PASSED, id must be an unused name,
	/// or the name of an existing occlusion query object.
	/// When glBeginQuery is executed, the query object's samples-passed counter is reset to 0. Subsequent
	/// rendering will increment the counter for every sample that passes the depth test. If the value of GL_SAMPLE_BUFFERS
	/// is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of GL_SAMPLE_BUFFERS
	/// is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their
	/// discression may instead increase the samples-passed count by the value of GL_SAMPLES if any sample in the fragment
	/// is covered. When glEndQuery
	/// is executed, the samples-passed counter is assigned to the query object's result value. This value can be queried by
	/// calling glGetQueryObject with pnameGL_QUERY_RESULT.
	/// 
	/// 
	/// 
	/// If target is GL_ANY_SAMPLES_PASSED, id must be an unused name,
	/// or the name of an existing boolean occlusion query object.
	/// When glBeginQuery is executed, the query object's samples-passed flag is reset to GL_FALSE.
	/// Subsequent rendering causes the flag to be set to GL_TRUE if any sample passes the depth test. When
	/// glEndQuery is executed, the samples-passed flag is assigned to the query object's result value. This value can
	/// be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
	/// 
	/// 
	/// 
	/// If target is GL_PRIMITIVES_GENERATED, id must be an unused
	/// name, or the name of an existing primitive query object previously bound to the GL_PRIMITIVES_GENERATED query binding.
	/// When glBeginQuery is executed, the query object's primitives-generated counter is reset to 0. Subsequent
	/// rendering will increment the counter once for every vertex that is emitted from the geometry shader, or from the vertex shader if
	/// no geometry shader is present. When glEndQuery is executed, the primitives-generated counter is assigned to
	/// the query object's result value. This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
	/// 
	/// 
	/// 
	/// If target is GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, id must be
	/// an unused name, or the name of an existing primitive query object previously bound to the GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
	/// query binding. When glBeginQuery is executed, the query object's primitives-written counter is reset to 0. Subsequent
	/// rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s). If transform feedback
	/// mode is not activated between the call to glBeginQuery and glEndQuery, the counter will not be
	/// incremented. When glEndQuery is executed, the primitives-written counter is assigned to
	/// the query object's result value. This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
	/// 
	/// 
	/// 
	/// If target is GL_TIME_ELAPSED, id must be
	/// an unused name, or the name of an existing timer query object previously bound to the GL_TIME_ELAPSED
	/// query binding. When glBeginQuery is executed, the query object's time counter is reset to 0. When glEndQuery
	/// is executed, the elapsed server time that has passed since the call to glBeginQuery is written into the query object's
	/// time counter. This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
	/// 
	/// 
	/// 
	/// Querying the GL_QUERY_RESULT implicitly flushes the GL pipeline until the rendering delimited by the
	/// query object has completed and the result is available. GL_QUERY_RESULT_AVAILABLE can be queried to
	/// determine if the result is immediately available or if the rendering is not yet complete.
	__gshared void function(GLenum target, GLuint id) glBeginQuery;
	/// Ditto
	__gshared void function(GLenum target) glEndQuery;
	/// Delimit the boundaries of a query object on an indexed target.
	/// 
	/// glBeginQueryIndexed and glEndQueryIndexed delimit the
	/// boundaries of a query object. query must be a name previously returned from a call to
	/// glGenQueries. If a query object with name id
	/// does not yet exist it is created with the type determined by target. target must
	/// be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED,
	/// GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. The behavior of the query
	/// object depends on its type and is as follows.
	/// 
	/// 
	/// index specifies the index of the query target and must be between a target-specific
	/// maximum.
	/// 
	/// 
	/// 
	/// If target is GL_SAMPLES_PASSED, id must be an unused name,
	/// or the name of an existing occlusion query object.
	/// When glBeginQueryIndexed is executed, the query object's samples-passed counter is reset to 0. Subsequent
	/// rendering will increment the counter for every sample that passes the depth test. If the value of GL_SAMPLE_BUFFERS
	/// is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of GL_SAMPLE_BUFFERS
	/// is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their
	/// discression may instead increase the samples-passed count by the value of GL_SAMPLES if any sample in the fragment
	/// is covered. When glEndQueryIndexed
	/// is executed, the samples-passed counter is assigned to the query object's result value. This value can be queried by
	/// calling glGetQueryObject with pnameGL_QUERY_RESULT.
	/// When target is GL_SAMPLES_PASSED, index must be zero.
	/// 
	/// 
	/// 
	/// If target is GL_ANY_SAMPLES_PASSED, id must be an unused name,
	/// or the name of an existing boolean occlusion query object.
	/// When glBeginQueryIndexed is executed, the query object's samples-passed flag is reset to GL_FALSE.
	/// Subsequent rendering causes the flag to be set to GL_TRUE if any sample passes the depth test. When
	/// glEndQueryIndexed is executed, the samples-passed flag is assigned to the query object's result value. This value can
	/// be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
	/// When target is GL_ANY_SAMPLES_PASSED, index must be zero.
	/// 
	/// 
	/// 
	/// If target is GL_PRIMITIVES_GENERATED, id must be an unused
	/// name, or the name of an existing primitive query object previously bound to the GL_PRIMITIVES_GENERATED query binding.
	/// When glBeginQueryIndexed is executed, the query object's primitives-generated counter is reset to 0. Subsequent
	/// rendering will increment the counter once for every vertex that is emitted from the geometry shader to the stream given by index,
	/// or from the vertex shader if index is zero and no geometry shader is present.
	/// When glEndQueryIndexed is executed, the primitives-generated counter for stream index is assigned to
	/// the query object's result value. This value can be queried by calling glGetQueryObject
	/// with pnameGL_QUERY_RESULT.
	/// When target is GL_PRIMITIVES_GENERATED, index must be
	/// less than the value of GL_MAX_VERTEX_STREAMS.
	/// 
	/// 
	/// 
	/// If target is GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, id must be
	/// an unused name, or the name of an existing primitive query object previously bound to the GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
	/// query binding. When glBeginQueryIndexed is executed, the query object's primitives-written counter for the stream specified by
	/// index is reset to 0. Subsequent rendering will increment the counter once for every vertex that is written into the bound
	/// transform feedback buffer(s) for stream index. If transform feedback
	/// mode is not activated between the call to glBeginQueryIndexed and glEndQueryIndexed, the counter will not be
	/// incremented. When glEndQueryIndexed is executed, the primitives-written counter for stream index is assigned to
	/// the query object's result value. This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
	/// When target is GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, index must be
	/// less than the value of GL_MAX_VERTEX_STREAMS.
	/// 
	/// 
	/// 
	/// If target is GL_TIME_ELAPSED, id must be
	/// an unused name, or the name of an existing timer query object previously bound to the GL_TIME_ELAPSED
	/// query binding. When glBeginQueryIndexed is executed, the query object's time counter is reset to 0. When glEndQueryIndexed
	/// is executed, the elapsed server time that has passed since the call to glBeginQueryIndexed is written into the query object's
	/// time counter. This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
	/// When target is GL_TIME_ELAPSED, index must be zero.
	/// 
	/// 
	/// 
	/// Querying the GL_QUERY_RESULT implicitly flushes the GL pipeline until the rendering delimited by the
	/// query object has completed and the result is available. GL_QUERY_RESULT_AVAILABLE can be queried to
	/// determine if the result is immediately available or if the rendering is not yet complete.
	__gshared void function(GLenum target, GLuint index, GLuint id) glBeginQueryIndexed;
	/// Ditto
	__gshared void function(GLenum target, GLuint index) glEndQueryIndexed;
	/// Start transform feedback operation.
	/// 
	/// Transform feedback mode captures the values of varying variables written by the vertex shader (or, if active, the geometry shader).
	/// Transform feedback is said to be active after a call to glBeginTransformFeedback
	/// until a subsequent call to glEndTransformFeedback.
	/// Transform feedback commands must be paired.
	/// 
	/// 
	/// 
	/// If no geometry shader is present, while transform feedback is active the mode parameter to
	/// glDrawArrays must match those specified
	/// in the following table:
	/// 
	/// 
	/// 
	/// If a geometry shader is present, the output primitive type from the geometry shader must match those
	/// provided in the following table:
	/// 
	/// Transform Feedback primitiveMode
	/// Allowed Geometry Shader Output Primitive Type
	/// GL_POINTSpointsGL_LINESline_stripGL_TRIANGLEStriangle_strip
	__gshared void function(GLenum primitiveMode) glBeginTransformFeedback;
	/// Ditto
	__gshared void function() glEndTransformFeedback;
	/// Associates a generic vertex attribute index with a named attribute variable.
	/// 
	/// glBindAttribLocation is used to
	/// associate a user-defined attribute variable in the program
	/// object specified by program with a
	/// generic vertex attribute index. The name of the user-defined
	/// attribute variable is passed as a null terminated string in
	/// name. The generic vertex attribute index
	/// to be bound to this variable is specified by
	/// index. When
	/// program is made part of current state,
	/// values provided via the generic vertex attribute
	/// index will modify the value of the
	/// user-defined attribute variable specified by
	/// name.
	/// 
	/// If name refers to a matrix
	/// attribute variable, index refers to the
	/// first column of the matrix. Other matrix columns are then
	/// automatically bound to locations index+1
	/// for a matrix of type mat2; index+1 and
	/// index+2 for a matrix of type mat3; and
	/// index+1, index+2,
	/// and index+3 for a matrix of type
	/// mat4.
	/// 
	/// This command makes it possible for vertex shaders to use
	/// descriptive names for attribute variables rather than generic
	/// variables that are numbered from 0 to
	/// GL_MAX_VERTEX_ATTRIBS -1. The values sent
	/// to each generic attribute index are part of current state.
	/// If a different program object is made current by calling
	/// glUseProgram,
	/// the generic vertex attributes are tracked in such a way that the
	/// same values will be observed by attributes in the new program
	/// object that are also bound to
	/// index.
	/// 
	/// Attribute variable
	/// name-to-generic attribute index bindings for a program object
	/// can be explicitly assigned at any time by calling
	/// glBindAttribLocation. Attribute bindings do
	/// not go into effect until
	/// glLinkProgram
	/// is called. After a program object has been linked successfully,
	/// the index values for generic attributes remain fixed (and their
	/// values can be queried) until the next link command
	/// occurs.
	/// 
	/// Any attribute binding that occurs after the program object has been linked will not take effect
	/// until the next time the program object is linked.
	__gshared void function(GLuint program, GLuint index, const GLchar* name) glBindAttribLocation;
	/// Bind a named buffer object.
	/// 
	/// glBindBuffer binds a buffer object to the specified buffer binding point. Calling glBindBuffer with
	/// target set to one of the accepted symbolic constants and buffer set to the name
	/// of a buffer object binds that buffer object name to the target. If no buffer object with name buffer
	/// exists, one is created with that name. When a buffer object is bound to a target, the previous binding for that
	/// target is automatically broken.
	/// 
	/// 
	/// 
	/// Buffer object names are unsigned integers. The value zero is reserved, but
	/// there is no default buffer object for each buffer object target. Instead, buffer set to zero
	/// effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target (if supported for that target).
	/// Buffer object names and the corresponding buffer object contents are local to
	/// the shared object space of the current
	/// GL rendering context;
	/// two rendering contexts share buffer object names only if they
	/// explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.
	/// 
	/// 
	/// glGenBuffers must be used to generate a set of unused buffer object names.
	/// 
	/// 
	/// 
	/// The state of a buffer object immediately after it is first bound is an unmapped zero-sized memory buffer with
	/// GL_READ_WRITE access and GL_STATIC_DRAW usage.
	/// 
	/// 
	/// 
	/// While a non-zero buffer object name is bound, GL operations on the target to which it is
	/// bound affect the bound buffer object, and queries of the target to which it is bound return state 
	/// from the bound buffer object. While buffer object name zero is bound, as in the initial state,
	/// attempts to modify or query state on the target to which it is bound generates an 
	/// GL_INVALID_OPERATION error.
	/// 
	/// 
	/// 
	/// When a non-zero buffer object is bound to the GL_ARRAY_BUFFER target, 
	/// the vertex array pointer parameter is interpreted as an offset within the
	/// buffer object measured in basic machine units.
	/// 
	/// 
	/// 
	/// When a non-zero buffer object is bound to the GL_DRAW_INDIRECT_BUFFER target,
	/// parameters for draws issued through glDrawArraysIndirect
	/// and glDrawElementsIndirect are sourced
	/// from that buffer object.
	/// 
	/// 
	/// 
	/// While a non-zero buffer object is bound to the GL_ELEMENT_ARRAY_BUFFER target, 
	/// the indices parameter of glDrawElements, 
	/// glDrawElementsInstanced,
	/// glDrawElementsBaseVertex, 
	/// glDrawRangeElements, 
	/// glDrawRangeElementsBaseVertex,
	/// glMultiDrawElements, or 
	/// glMultiDrawElementsBaseVertex is interpreted as an 
	/// offset within the buffer object measured in basic machine units.
	/// 
	/// 
	/// 
	/// While a non-zero buffer object is bound to the GL_PIXEL_PACK_BUFFER target, 
	/// the following commands are affected: glGetCompressedTexImage, 
	/// glGetTexImage, and 
	/// glReadPixels. The pointer parameter is
	/// interpreted as an offset within the buffer object measured in basic machine units.
	/// 
	/// 
	/// 
	/// While a non-zero buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target, 
	/// the following commands are affected: 
	/// glCompressedTexImage1D,
	/// glCompressedTexImage2D,
	/// glCompressedTexImage3D,
	/// glCompressedTexSubImage1D,
	/// glCompressedTexSubImage2D,
	/// glCompressedTexSubImage3D,
	/// glTexImage1D,
	/// glTexImage2D,
	/// glTexImage3D,
	/// glTexSubImage1D,
	/// glTexSubImage2D, and 
	/// glTexSubImage3D. The pointer parameter is 
	/// interpreted as an offset within the buffer object measured in basic machine units.
	/// 
	/// 
	/// 
	/// The buffer targets GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER
	/// are provided to allow glCopyBufferSubData
	/// to be used without disturbing the state of other bindings. However, glCopyBufferSubData
	/// may be used with any pair of buffer binding points.
	/// 
	/// 
	/// 
	/// The GL_TRANSFORM_FEEDBACK_BUFFER buffer binding point may be passed to glBindBuffer,
	/// but will not directly affect transform feedback state. Instead, the indexed GL_TRANSFORM_FEEDBACK_BUFFER
	/// bindings must be used through a call to glBindBufferBase
	/// or glBindBufferRange. This will affect the generic
	/// GL_TRANSFORM_FEEDABCK_BUFFER binding.
	/// 
	/// 
	/// 
	/// Likewise, the GL_UNIFORM_BUFFER and GL_ATOMIC_COUNTER_BUFFER buffer binding points may
	/// be used, but do not directly affect uniform buffer or atomic counter buffer state, respectively.
	/// glBindBufferBase
	/// or glBindBufferRange must be used to bind a buffer to
	/// an indexed uniform buffer or atomic counter buffer binding point.
	/// 
	/// 
	/// 
	/// A buffer object binding created with glBindBuffer remains active until a different
	/// buffer object name is bound to the same target, or until the bound buffer object is
	/// deleted with glDeleteBuffers.
	/// 
	/// 
	/// 
	/// Once created, a named buffer object may be re-bound to any target as often as needed. However,
	/// the GL implementation may make choices about how to optimize the storage of a buffer object based
	/// on its initial binding target.
	__gshared void function(GLenum target, GLuint buffer) glBindBuffer;
	/// Bind a buffer object to an indexed buffer target.
	/// 
	/// glBindBufferBase binds the buffer object buffer
	/// to the binding point at index index of the array of targets specified
	/// by target. Each target represents an indexed
	/// array of buffer binding points, as well as a single general binding point that can be used by
	/// other buffer manipulation functions such as glBindBuffer
	/// or glMapBuffer. In addition to binding
	/// buffer to the indexed buffer binding target, glBindBufferBase
	/// also binds buffer to the generic buffer binding point specified by target.
	__gshared void function(GLenum target, GLuint index, GLuint buffer) glBindBufferBase;
	/// Bind a range within a buffer object to an indexed buffer target.
	/// 
	/// glBindBufferRange binds a range the buffer object buffer
	/// represented by offset and size to the
	/// binding point at index index of the array of targets specified by target.
	/// Each target represents an indexed array of buffer binding points, as well
	/// as a single general binding point that can be used by other buffer manipulation functions such as
	/// glBindBuffer or
	/// glMapBuffer. In addition to binding
	/// a range of buffer to the indexed buffer binding target, glBindBufferBase
	/// also binds the range to the generic buffer binding point specified by target.
	/// 
	/// 
	/// offset specifies the offset in basic machine units into the buffer object
	/// buffer and size specifies the amount of data that
	/// can be read from the buffer object while used as an indexed target.
	__gshared void function(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) glBindBufferRange;
	/// Bind a user-defined varying out variable to a fragment shader color number.
	/// 
	/// glBindFragDataLocation explicitly specifies the binding of the user-defined varying out variable
	/// name to fragment shader color number colorNumber for program
	/// program. If name was bound previously, its assigned binding is replaced
	/// with colorNumber. name must be a null-terminated string. colorNumber
	/// must be less than GL_MAX_DRAW_BUFFERS.
	/// 
	/// 
	/// 
	/// The bindings specified by glBindFragDataLocation have no effect until program
	/// is next linked. Bindings may be specified at any time after program has been created. Specifically,
	/// they may be specified before shader objects are attached to the program. Therefore, any name may be specified in name,
	/// including a name that is never used as a varying out variable in any fragment shader object. Names beginning with gl_ are
	/// reserved by the GL.
	/// 
	/// 
	/// 
	/// In addition to the errors generated by glBindFragDataLocation, the
	/// program program will fail to link if:
	/// 
	/// The number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS.
	/// 
	/// More than one varying out variable is bound to the same color number.
	/// 
	/// 
	/// 
	/// The number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS.
	/// 
	/// 
	/// 
	/// More than one varying out variable is bound to the same color number.
	__gshared void function(GLuint program, GLuint colorNumber, const char * name) glBindFragDataLocation;
	/// Bind a user-defined varying out variable to a fragment shader color number and index.
	/// 
	/// glBindFragDataLocationIndexed specifies that the varying out variable name in
	/// program should be bound to fragment color colorNumber when the program is next
	/// linked. index may be zero or one to specify that the color be used as either the first or second color
	/// input to the blend equation, respectively.
	/// 
	/// 
	/// 
	/// The bindings specified by glBindFragDataLocationIndexed have no effect until program
	/// is next linked. Bindings may be specified at any time after program has been created. Specifically,
	/// they may be specified before shader objects are attached to the program. Therefore, any name may be specified in name,
	/// including a name that is never used as a varying out variable in any fragment shader object. Names beginning with gl_ are
	/// reserved by the GL.
	/// 
	/// 
	/// 
	/// If name was bound previously, its assigned binding is replaced with colorNumber and
	/// index. name must be a null-terminated string. index must be less than or equal to one,
	/// and colorNumber must be less than the value of GL_MAX_DRAW_BUFFERS if index
	/// is zero, and less than the value of GL_MAX_DUAL_SOURCE_DRAW_BUFFERS if index is greater than or equal to one.
	/// 
	/// 
	/// 
	/// In addition to the errors generated by glBindFragDataLocationIndexed, the
	/// program program will fail to link if:
	/// 
	/// The number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS.
	/// 
	/// More than one varying out variable is bound to the same color number.
	/// 
	/// 
	/// 
	/// The number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS.
	/// 
	/// 
	/// 
	/// More than one varying out variable is bound to the same color number.
	__gshared void function(GLuint program, GLuint colorNumber, GLuint index, const char* name) glBindFragDataLocationIndexed;
	/// Bind a framebuffer to a framebuffer target.
	/// 
	/// glBindFramebuffer binds the framebuffer object with name framebuffer to the framebuffer target specified
	/// by target. target must be either GL_DRAW_FRAMEBUFFER,
	/// GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER. If a framebuffer object is bound to
	/// GL_DRAW_FRAMEBUFFER or GL_READ_FRAMEBUFFER, it becomes the target for
	/// rendering or readback operations, respectively, until it is deleted or another framebuffer is bound to the corresponding bind point.
	/// Calling glBindFramebuffer with target set to GL_FRAMEBUFFER binds
	/// framebuffer to both the read and draw framebuffer targets. framebuffer is the name of a framebuffer
	/// object previously returned from a call to glGenFramebuffers, or zero to break the existing
	/// binding of a framebuffer object to target.
	__gshared void function(GLenum target, GLuint framebuffer) glBindFramebuffer;
	/// Bind a level of a texture to an image unit.
	/// 
	/// glBindImageTexture binds a single level of a texture to an image unit for the purpose of
	/// reading and writing it from shaders. unit specifies the zero-based index of the image
	/// unit to which to bind the texture level. texture specifies the name of an existing texture
	/// object to bind to the image unit. If texture is zero, then any existing binding to
	/// the image unit is broken. level specifies the level of the texture to bind to the image
	/// unit.
	/// 
	/// 
	/// 
	/// If texture is the name of a one-, two-, or three-dimensional array texture, a cube map
	/// or cube map array texture, or a two-dimensional multisample array texture, then it is possible to bind either
	/// the entire array, or only a single layer of the array to the image unit. In such cases, if layered
	/// is GL_TRUE, the entire array is attached to the image unit and layer
	/// is ignored. However, if layered is GL_FALSE then layer
	/// specifies the layer of the array to attach to the image unit.
	/// 
	/// 
	/// access specifies the access types to be performed by shaders and may be set to
	/// GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE
	/// to indicate read-only, write-only or read-write access, respectively. Violation of the access type specified in access
	/// (for example, if a shader writes to an image bound with access set to GL_READ_ONLY)
	/// will lead to undefined results, possibly including program termination.
	/// 
	/// 
	/// format specifies the format that is to be used when performing formatted stores into the
	/// image from shaders. format must be compatible with the texture's internal format and must
	/// be one of the formats listed in the following table.
	/// 
	/// 
	/// Internal Image Formats
	/// Image Unit Format
	/// 
	/// Format Qualifier
	/// GL_RGBA32Frgba32fGL_RGBA16Frgba16fGL_RG32Frg32fGL_RG16Frg16fGL_R11F_G11F_B10Fr11f_g11f_b10fGL_R32Fr32fGL_R16Fr16fGL_RGBA32UIrgba32uiGL_RGBA16UIrgba16uiGL_RGB10_A2UIrgb10_a2uiGL_RGBA8UIrgba8uiGL_RG32UIrg32uiGL_RG16UIrg16uiGL_RG8UIrg8uiGL_R32UIr32uiGL_R16UIr16uiGL_R8UIr8uiGL_RGBA32Irgba32iGL_RGBA16Irgba16iGL_RGBA8Irgba8iGL_RG32Irg32iGL_RG16Irg16iGL_RG8Irg8iGL_R32Ir32iGL_R16Ir16iGL_R8Ir8iGL_RGBA16rgba16GL_RGB10_A2rgb10_a2GL_RGBA8rgba8GL_RG16rg16GL_RG8rg8GL_R16r16GL_R8r8GL_RGBA16_SNORMrgba16_snormGL_RGBA8_SNORMrgba8_snormGL_RG16_SNORMrg16_snormGL_RG8_SNORMrg8_snormGL_R16_SNORMr16_snormGL_R8_SNORMr8_snorm
	/// 
	/// 
	/// When a texture is bound to an image unit, the format parameter for the image
	/// unit need not exactly match the texture internal format as long as the formats are
	/// considered compatible as defined in the OpenGL Specification. The matching criterion used
	/// for a given texture may be determined by calling glGetTexParameter
	/// with value
	/// set to GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, with return values of GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE
	/// and GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS, specifying matches by size and class, respectively.
	__gshared void function(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) glBindImageTexture;
	/// Bind a program pipeline to the current context.
	/// 
	/// glBindProgramPipeline binds a program pipeline object to the current
	/// context. pipeline must be a name previously returned from a call
	/// to glGenProgramPipelines. If
	/// no program pipeline exists with name pipeline then a new pipeline object
	/// is created with that name and initialized to the default state vector.
	/// 
	/// 
	/// 
	/// When a program pipeline object is bound using glBindProgramPipeline, any previous
	/// binding is broken and is replaced with a binding to the specified pipeline object. If pipeline
	/// is zero, the previous binding is broken and is not replaced, leaving no pipeline object bound.
	/// If no current program object has been established by glUseProgram,
	/// the program objects used for each stage and for uniform updates are taken from the bound program
	/// pipeline object, if any. If there is a current program object established by glUseProgram,
	/// the bound program pipeline object has no effect on rendering or uniform updates. When a bound program
	/// pipeline object is used for rendering, individual shader executables are taken from its program objects.
	__gshared void function(GLuint pipeline) glBindProgramPipeline;
	/// Bind a renderbuffer to a renderbuffer target.
	/// 
	/// glBindRenderbuffer binds the renderbuffer object with name renderbuffer to the renderbuffer target specified
	/// by target. target must be GL_RENDERBUFFER. renderbuffer
	/// is the name of a renderbuffer object previously returned from a call to glGenRenderbuffers,
	/// or zero to break the existing binding of a renderbuffer object to target.
	__gshared void function(GLenum target, GLuint renderbuffer) glBindRenderbuffer;
	/// Bind a named sampler to a texturing target.
	/// 
	/// glBindSampler binds sampler to the texture unit at index unit.
	/// sampler must be zero or the name of a sampler object previously returned from a call to
	/// glGenSamplers. unit must be less than the value
	/// of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS.
	/// 
	/// 
	/// 
	/// When a sampler object is bound to a texture unit, its state supersedes that of
	/// the texture object bound to that texture unit. If the sampler name zero is bound to
	/// a texture unit, the currently bound texture's sampler state becomes active. A single
	/// sampler object may be bound to multiple texture units simultaneously.
	__gshared void function(GLuint unit, GLuint sampler) glBindSampler;
	/// Bind a named texture to a texturing target.
	/// 
	/// glBindTexture lets you create or use a named texture. Calling glBindTexture with
	/// target set to
	/// GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or
	/// GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE,
	/// GL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY
	/// and texture set to the name of the new texture binds the texture name to the target.
	/// When a texture is bound to a target, the previous binding for that target is automatically broken.
	/// 
	/// 
	/// 
	/// Texture names are unsigned integers. The value zero is reserved to
	/// represent the default texture for each texture target.
	/// Texture names and the corresponding texture contents are local to
	/// the shared object space of the current GL rendering context;
	/// two rendering contexts share texture names only if they
	/// explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.
	/// 
	/// 
	/// 
	/// You must use glGenTextures to generate a set of new texture names.
	/// 
	/// 
	/// 
	/// When a texture is first bound, it assumes the specified target:
	/// A texture first bound to GL_TEXTURE_1D becomes one-dimensional texture, a
	/// texture first bound to GL_TEXTURE_2D becomes two-dimensional texture, a
	/// texture first bound to GL_TEXTURE_3D becomes three-dimensional texture, a
	/// texture first bound to GL_TEXTURE_1D_ARRAY becomes one-dimensional array texture, a
	/// texture first bound to GL_TEXTURE_2D_ARRAY becomes two-dimensional arary texture, a
	/// texture first bound to GL_TEXTURE_RECTANGLE becomes rectangle texture, a,
	/// texture first bound to GL_TEXTURE_CUBE_MAP becomes a cube-mapped texture, a
	/// texture first bound to GL_TEXTURE_2D_MULTISAMPLE becomes a two-dimensional multisampled texture, and a
	/// texture first bound to GL_TEXTURE_2D_MULTISAMPLE_ARRAY becomes a two-dimensional multisampled array texture.
	/// The state of a one-dimensional texture immediately after it is first bound is equivalent to the state of the
	/// default GL_TEXTURE_1D at GL initialization, and similarly for the other texture types.
	/// 
	/// 
	/// 
	/// While a texture is bound, GL operations on the target to which it is
	/// bound affect the bound texture, and queries of the target to which it
	/// is bound return state from the bound texture. 
	/// In effect, the texture targets become aliases for the textures currently
	/// bound to them, and the texture name zero refers to the default textures
	/// that were bound to them at initialization.
	/// 
	/// 
	/// 
	/// A texture binding created with glBindTexture remains active until a different
	/// texture is bound to the same target, or until the bound texture is
	/// deleted with glDeleteTextures.
	/// 
	/// 
	/// 
	/// Once created, a named texture may be re-bound to its same original target as often as needed.
	/// It is usually much faster to use glBindTexture to bind an existing named
	/// texture to one of the texture targets than it is to reload the texture image
	/// using glTexImage1D, glTexImage2D,
	/// glTexImage3D or another similar function.
	void glBindTexture(GLenum target, GLuint texture);
	/// Bind a transform feedback object.
	/// 
	/// glBindTransformFeedback binds the transform feedback object with name id to the current
	/// GL state. id must be a name previously returned from a call to
	/// glGenTransformFeedbacks. If id has not
	/// previously been bound, a new transform feedback object with name id and initialized with with the
	/// default transform state vector is created.
	/// 
	/// 
	/// 
	/// In the initial state, a default transform feedback object is bound and treated as
	/// a transform feedback object with a name of zero. If the name zero is subsequently bound, the default
	/// transform feedback object is again bound to the GL state.
	/// 
	/// 
	/// 
	/// While a transform feedback buffer object is bound, GL operations on the target
	/// to which it is bound affect the bound transform feedback object, and queries of the
	/// target to which a transform feedback object is bound return state from the bound
	/// object. When buffer objects are bound for transform feedback, they are attached to
	/// the currently bound transform feedback object. Buffer objects are used for trans-
	/// form feedback only if they are attached to the currently bound transform feedback
	/// object.
	__gshared void function(GLenum target, GLuint id) glBindTransformFeedback;
	/// Bind a vertex array object.
	/// 
	/// glBindVertexArray binds the vertex array object with name array. array
	/// is the name of a vertex array object previously returned from a call to glGenVertexArrays,
	/// or zero to break the existing vertex array object binding.
	/// 
	/// 
	/// 
	/// If no vertex array object with name array exists, one is created when array is first bound. If the bind
	/// is successful no change is made to the state of the vertex array object, and any previous vertex array object binding is broken.
	__gshared void function(GLuint array) glBindVertexArray;
	/// Set the blend color.
	/// 
	/// The GL_BLEND_COLOR may be used to calculate the source and destination
	/// blending factors. The color components are clamped to the range 
	/// 01
	/// before being stored. See glBlendFunc for a complete description of the
	/// blending operations.
	/// Initially the GL_BLEND_COLOR is set to (0, 0, 0, 0).
	__gshared void function(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) glBlendColor;
	/// Specify the equation used for both the RGB blend equation and the Alpha blend equation.
	/// 
	/// The blend equations determine how a new pixel (the ''source'' color)
	/// is combined with a pixel already in the framebuffer (the ''destination''
	/// color). This function sets both the RGB blend equation and the alpha 
	/// blend equation to a single equation. glBlendEquationi
	/// specifies the blend equation for a single draw buffer whereas glBlendEquation
	/// sets the blend equation for all draw buffers.
	/// 
	/// 
	/// 
	/// These equations use the source and destination blend factors
	/// specified by either glBlendFunc or
	/// glBlendFuncSeparate.
	/// See glBlendFunc or glBlendFuncSeparate
	/// for a description of the various blend factors.
	/// 
	/// 
	/// 
	/// In the equations that follow, source and destination
	/// color components are referred to as
	/// RsGsBsAs
	/// and
	/// RdGdBdAd,
	/// respectively.
	/// The result color is referred to as
	/// RrGrBrAr.
	/// The source and destination blend factors are denoted
	/// sRsGsBsA
	/// and
	/// dRdGdBdA,
	/// respectively.
	/// For these equations all color components are understood to have values
	/// in the range 
	/// 01.
	/// 
	/// 
	/// Mode
	/// 
	/// RGB Components
	/// 
	/// Alpha Component
	/// GL_FUNC_ADDRr=RssR+RddRGr=GssG+GddGBr=BssB+BddBAr=AssA+AddAGL_FUNC_SUBTRACTRr=RssR-RddRGr=GssG-GddGBr=BssB-BddBAr=AssA-AddAGL_FUNC_REVERSE_SUBTRACTRr=RddR-RssRGr=GddG-GssGBr=BddB-BssBAr=AddA-AssAGL_MINRr=minRsRdGr=minGsGdBr=minBsBdAr=minAsAdGL_MAXRr=maxRsRdGr=maxGsGdBr=maxBsBdAr=maxAsAd
	/// 
	/// 
	/// The results of these equations are clamped to the range 
	/// 01.
	/// 
	/// 
	/// 
	/// The GL_MIN and GL_MAX equations are useful for applications
	/// that analyze image data (image thresholding against a constant color,
	/// for example).
	/// The GL_FUNC_ADD equation is useful
	/// for antialiasing and transparency, among other things.
	/// 
	/// 
	/// 
	/// Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.
	__gshared void function(GLenum mode) glBlendEquation;
	/// Ditto
	__gshared void function(GLuint buf, GLenum mode) glBlendEquationi;
	/// Set the RGB blend equation and the alpha blend equation separately.
	/// 
	/// The blend equations determines how a new pixel (the ''source'' color)
	/// is combined with a pixel already in the framebuffer (the ''destination''
	/// color). These functions specifie one blend equation for the RGB-color 
	/// components and one blend equation for the alpha component. glBlendEquationSeparatei
	/// specifies the blend equations for a single draw buffer whereas glBlendEquationSeparate
	/// sets the blend equations for all draw buffers.
	/// 
	/// 
	/// 
	/// The blend equations use the source and destination blend factors
	/// specified by either glBlendFunc or
	/// glBlendFuncSeparate.
	/// See glBlendFunc or glBlendFuncSeparate
	/// for a description of the various blend factors.
	/// 
	/// 
	/// 
	/// In the equations that follow, source and destination
	/// color components are referred to as
	/// RsGsBsAs
	/// and
	/// RdGdBdAd,
	/// respectively.
	/// The result color is referred to as
	/// RrGrBrAr.
	/// The source and destination blend factors are denoted
	/// sRsGsBsA
	/// and
	/// dRdGdBdA,
	/// respectively.
	/// For these equations all color components are understood to have values
	/// in the range 
	/// 01.
	/// 
	/// 
	/// Mode
	/// 
	/// RGB Components
	/// 
	/// Alpha Component
	/// GL_FUNC_ADDRr=RssR+RddRGr=GssG+GddGBr=BssB+BddBAr=AssA+AddAGL_FUNC_SUBTRACTRr=RssR-RddRGr=GssG-GddGBr=BssB-BddBAr=AssA-AddAGL_FUNC_REVERSE_SUBTRACTRr=RddR-RssRGr=GddG-GssGBr=BddB-BssBAr=AddA-AssAGL_MINRr=minRsRdGr=minGsGdBr=minBsBdAr=minAsAdGL_MAXRr=maxRsRdGr=maxGsGdBr=maxBsBdAr=maxAsAd
	/// 
	/// 
	/// The results of these equations are clamped to the range 
	/// 01.
	/// 
	/// 
	/// 
	/// The GL_MIN and GL_MAX equations are useful for applications
	/// that analyze image data (image thresholding against a constant color,
	/// for example).
	/// The GL_FUNC_ADD equation is useful
	/// for antialiasing and transparency, among other things.
	/// 
	/// 
	/// 
	/// Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.
	__gshared void function(GLenum modeRGB, GLenum modeAlpha) glBlendEquationSeparate;
	/// Ditto
	__gshared void function(GLuint buf, GLenum modeRGB, GLenum modeAlpha) glBlendEquationSeparatei;
	/// Specify pixel arithmetic.
	/// 
	/// Pixels can be drawn using a function that blends
	/// the incoming (source) RGBA values with the RGBA values
	/// that are already in the frame buffer (the destination values).
	/// Blending is initially disabled.
	/// Use glEnable and glDisable with argument GL_BLEND
	/// to enable and disable blending.
	/// 
	/// 
	/// glBlendFunc defines the operation of blending for all draw buffers when it is enabled.
	/// glBlendFunci defines the operation of blending for a single draw buffer
	/// specified by buf when enabled for that draw buffer.
	/// sfactor specifies which method is used to scale the
	/// source color components.
	/// dfactor specifies which method is used to scale the
	/// destination color components.
	/// Both parameters must be one of the following symbolic constants:
	/// GL_ZERO,
	/// GL_ONE,
	/// GL_SRC_COLOR,
	/// GL_ONE_MINUS_SRC_COLOR,
	/// GL_DST_COLOR,
	/// GL_ONE_MINUS_DST_COLOR,
	/// GL_SRC_ALPHA,
	/// GL_ONE_MINUS_SRC_ALPHA,
	/// GL_DST_ALPHA,
	/// GL_ONE_MINUS_DST_ALPHA,
	/// GL_CONSTANT_COLOR,
	/// GL_ONE_MINUS_CONSTANT_COLOR,
	/// GL_CONSTANT_ALPHA,
	/// GL_ONE_MINUS_CONSTANT_ALPHA,
	/// GL_SRC_ALPHA_SATURATE,
	/// GL_SRC1_COLOR,
	/// GL_ONE_MINUS_SRC1_COLOR,
	/// GL_SRC1_ALPHA, and
	/// GL_ONE_MINUS_SRC1_ALPHA.
	/// The possible methods are described in the following table.
	/// Each method defines four scale factors,
	/// one each for red, green, blue, and alpha.
	/// In the table and in subsequent equations, first source, second source
	/// and destination color components are referred to as
	/// Rs0Gs0Bs0As0,
	/// Rs1Gs1Bs1As1
	/// and
	/// RdGdBdAd, respectively.
	/// The color specified by glBlendColor is referred to as
	/// RcGcBcAc.
	/// They are understood to have integer values between 0 and
	/// kRkGkBkA,
	/// where
	/// 
	/// 
	/// kc=2mc-1
	/// 
	/// kc=2mc-1
	/// 
	/// 
	/// and
	/// mRmGmBmA
	/// is the number of red,
	/// green,
	/// blue,
	/// and alpha bitplanes.
	/// 
	/// 
	/// 
	/// Source and destination scale factors are referred to as
	/// sRsGsBsA
	/// and
	/// dRdGdBdA.
	/// The scale factors described in the table,
	/// denoted 
	/// fRfGfBfA,
	/// represent either source or destination factors.
	/// All scale factors have range 
	/// 01.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// In the table,
	/// 
	/// 
	/// i=minAskA-AdkA
	/// 
	/// i=minAskA-AdkA
	/// 
	/// 
	/// To determine the blended RGBA values of a pixel,
	/// the system uses the following equations:
	/// 
	/// 
	/// Rd=minkRRssR+RddRGd=minkGGssG+GddGBd=minkBBssB+BddBAd=minkAAssA+AddA
	/// 
	/// Rd=minkRRssR+RddRGd=minkGGssG+GddGBd=minkBBssB+BddBAd=minkAAssA+AddA
	/// 
	/// 
	/// Despite the apparent precision of the above equations,
	/// blending arithmetic is not exactly specified,
	/// because blending operates with imprecise integer color values.
	/// However,
	/// a blend factor that should be equal to 1
	/// is guaranteed not to modify its multiplicand,
	/// and a blend factor equal to 0 reduces its multiplicand to 0.
	/// For example,
	/// when sfactor is GL_SRC_ALPHA,
	/// dfactor is GL_ONE_MINUS_SRC_ALPHA,
	/// and 
	/// As
	/// is equal to 
	/// kA,
	/// the equations reduce to simple replacement:
	/// 
	/// 
	/// Rd=RsGd=GsBd=BsAd=As
	/// 
	/// Rd=RsGd=GsBd=BsAd=As
	void glBlendFunc(GLenum sfactor, GLenum dfactor);
	/// Ditto
	void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor);
	/// Specify pixel arithmetic for RGB and alpha components separately.
	/// 
	/// Pixels can be drawn using a function that blends
	/// the incoming (source) RGBA values with the RGBA values
	/// that are already in the frame buffer (the destination values).
	/// Blending is initially disabled.
	/// Use glEnable and glDisable with argument GL_BLEND
	/// to enable and disable blending.
	/// 
	/// 
	/// glBlendFuncSeparate defines the operation of blending for all draw buffers when it is enabled.
	/// glBlendFuncSeparatei defines the operation of blending for a single draw buffer
	/// specified by buf when enabled for that draw buffer.
	/// srcRGB specifies which method is used to scale the
	/// source RGB-color components.
	/// dstRGB specifies which method is used to scale the
	/// destination RGB-color components.
	/// Likewise, srcAlpha specifies which method is used to scale the source alpha
	/// color component, and dstAlpha specifies which method is used to scale the
	/// destination alpha component.
	/// The possible methods are described in the following table.
	/// Each method defines four scale factors,
	/// one each for red, green, blue, and alpha.
	/// 
	/// 
	/// 
	/// In the table and in subsequent equations, first source, second source and destination
	/// color components are referred to as
	/// Rs0Gs0Bs0As0,
	/// Rs1Gs1Bs1As1,
	/// and
	/// RdGdBdAd, respectively.
	/// The color specified by glBlendColor is referred to as
	/// RcGcBcAc.
	/// They are understood to have integer values between 0 and
	/// kRkGkBkA,
	/// where
	/// 
	/// 
	/// kc=2mc-1
	/// 
	/// kc=2mc-1
	/// 
	/// 
	/// and
	/// mRmGmBmA
	/// is the number of red,
	/// green,
	/// blue,
	/// and alpha bitplanes.
	/// 
	/// 
	/// 
	/// Source and destination scale factors are referred to as
	/// sRsGsBsA
	/// and
	/// dRdGdBdA.
	/// All scale factors have range 
	/// 01.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// In the table,
	/// 
	/// 
	/// i=minAs1-Ad
	/// 
	/// i=minAs1-Ad
	/// 
	/// 
	/// To determine the blended RGBA values of a pixel,
	/// the system uses the following equations:
	/// 
	/// 
	/// Rd=minkRRssR+RddRGd=minkGGssG+GddGBd=minkBBssB+BddBAd=minkAAssA+AddA
	/// 
	/// Rd=minkRRssR+RddRGd=minkGGssG+GddGBd=minkBBssB+BddBAd=minkAAssA+AddA
	/// 
	/// 
	/// Despite the apparent precision of the above equations, blending arithmetic
	/// is not exactly specified, because blending operates with imprecise integer
	/// color values. However, a blend factor that should be equal to 1 is
	/// guaranteed not to modify its multiplicand, and a blend factor equal to 0
	/// reduces its multiplicand to 0. For example, when srcRGB is
	/// GL_SRC_ALPHA, dstRGB is GL_ONE_MINUS_SRC_ALPHA, and 
	/// As
	/// is
	/// equal to 
	/// kA,
	/// the equations reduce to simple replacement:
	/// 
	/// 
	/// Rd=RsGd=GsBd=BsAd=As
	/// 
	/// Rd=RsGd=GsBd=BsAd=As
	__gshared void function(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) glBlendFuncSeparate;
	/// Ditto
	__gshared void function(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) glBlendFuncSeparatei;
	/// Copy a block of pixels from the read framebuffer to the draw framebuffer.
	/// 
	/// glBlitFramebuffer transfers a rectangle of pixel values from one region of the read framebuffer to another region in
	/// the draw framebuffer. mask is the bitwise OR of a number of values indicating which buffers are
	/// to be copied. The values are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and
	/// GL_STENCIL_BUFFER_BIT. The pixels corresponding to these buffers are copied from the source rectangle bounded by the
	/// locations (srcX0; srcY0) and (srcX1; srcY1)
	/// to the destination rectangle bounded by the locations (dstX0; dstY0) and
	/// (dstX1; dstY1). The lower bounds of the rectangle are inclusive, while the upper
	/// bounds are exclusive.
	/// 
	/// 
	/// 
	/// The actual region taken from the read framebuffer is limited to the intersection of the source buffers being transferred, which may
	/// include the color buffer selected by the read buffer, the depth buffer, and/or the stencil buffer depending on mask. The actual region
	/// written to the draw framebuffer is limited to the intersection of the destination buffers being written, which may include multiple draw
	/// buffers, the depth buffer, and/or the stencil buffer depending on mask. Whether or not the source or destination regions are altered due
	/// to these limits, the scaling and offset applied to pixels being transferred is performed as though no such limits were present.
	/// 
	/// 
	/// 
	/// If the sizes of the source and destination rectangles are not equal, filter specifies the interpolation method that
	/// will be applied to resize the source image , and must be GL_NEAREST or GL_LINEAR.
	/// GL_LINEAR is only a valid interpolation method for the color buffer. If filter is not
	/// GL_NEAREST and mask includes GL_DEPTH_BUFFER_BIT or
	/// GL_STENCIL_BUFFER_BIT, no data is transferred and a GL_INVALID_OPERATION error is generated.
	/// 
	/// 
	/// 
	/// If filter is GL_LINEAR and the source rectangle would require sampling outside the bounds of
	/// the source framebuffer, values are read as if the GL_CLAMP_TO_EDGE texture wrapping mode were applied.
	/// 
	/// 
	/// 
	/// When the color buffer is transferred, values are taken from the read buffer of the read framebuffer and written to each of the draw
	/// buffers of the draw framebuffer.
	/// 
	/// 
	/// 
	/// If the source and destination rectangles overlap or are the same, and the read and draw buffers are the same, the result of the operation
	/// is undefined.
	__gshared void function(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) glBlitFramebuffer;
	/// Creates and initializes a buffer object's data store.
	/// 
	/// glBufferData creates a new data store for the buffer object currently bound to
	/// target. Any pre-existing data store is deleted. The new data store is created with the
	/// specified size in bytes and usage. If data
	/// is not NULL, the data store is initialized with data from this pointer. In its initial 
	/// state, the new data store is not mapped, it has a NULL mapped pointer, and its mapped access 
	/// is GL_READ_WRITE.
	/// 
	/// 
	/// usage is a hint to the GL implementation as to how a buffer object's data store will be 
	/// accessed. This enables the GL implementation to make more intelligent decisions that may significantly 
	/// impact buffer object performance. It does not, however, constrain the actual usage of the data store.
	/// usage can be broken down into two parts: first, the frequency of access (modification 
	/// and usage), and second, the nature of that access. The frequency of access may be one of these:
	/// 
	/// 
	/// 
	/// The data store contents will be modified once and used at most a few times.
	/// 
	/// 
	/// 
	/// The data store contents will be modified once and used many times.
	/// 
	/// 
	/// 
	/// The data store contents will be modified repeatedly and used many times.
	/// 
	/// 
	/// 
	/// The nature of access may be one of these:
	/// 
	/// 
	/// 
	/// The data store contents are modified by the application, and used as the source for GL drawing and
	/// image specification commands.
	/// 
	/// 
	/// 
	/// The data store contents are modified by reading data from the GL, and used to return that data 
	/// when queried by the application.
	/// 
	/// 
	/// 
	/// The data store contents are modified by reading data from the GL, and used as the source for GL
	/// drawing and image specification commands.
	__gshared void function(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage) glBufferData;
	/// Updates a subset of a buffer object's data store.
	/// 
	/// glBufferSubData redefines some or all of the data store for the buffer object currently 
	/// bound to target. Data starting at byte offset offset and
	/// extending for size bytes is copied to the data store from the memory pointed to by
	/// data. An error is thrown if offset and size
	/// together define a range beyond the bounds of the buffer object's data store.
	__gshared void function(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data) glBufferSubData;
	/// Check the completeness status of a framebuffer.
	/// 
	/// glCheckFramebufferStatus queries the completeness status of the framebuffer object currently bound to target.
	/// target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER.
	/// GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.
	/// 
	/// 
	/// 
	/// The return value is GL_FRAMEBUFFER_COMPLETE if the framebuffer bound to target is complete. Otherwise,
	/// the return value is determined as follows:
	/// GL_FRAMEBUFFER_UNDEFINED is returned if target is the default framebuffer, but the default framebuffer does not exist.
	/// GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT is returned if any of the framebuffer attachment points are framebuffer incomplete.
	/// GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT is returned if the framebuffer does not have at least one image attached to it.
	/// GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER is returned if the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
	/// is GL_NONE for any color attachment point(s) named by GL_DRAWBUFFERi.
	/// GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER is returned if GL_READ_BUFFER is not GL_NONE
	/// and the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_NONE for the color attachment point named
	/// by GL_READ_BUFFER.
	/// GL_FRAMEBUFFER_UNSUPPORTED is returned if the combination of internal formats of the attached images violates
	/// an implementation-dependent set of restrictions.
	/// GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE is returned if the value of GL_RENDERBUFFER_SAMPLES is not the same
	/// for all attached renderbuffers; if the value of GL_TEXTURE_SAMPLES is the not same for all attached textures; or, if the attached
	/// images are a mix of renderbuffers and textures, the value of GL_RENDERBUFFER_SAMPLES does not match the value of
	/// GL_TEXTURE_SAMPLES.
	/// GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE is also returned if the value of GL_TEXTURE_FIXED_SAMPLE_LOCATIONS is
	/// not the same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of GL_TEXTURE_FIXED_SAMPLE_LOCATIONS
	/// is not GL_TRUE for all attached textures.
	/// GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS is returned if any framebuffer attachment is layered, and any populated attachment is not layered,
	/// or if all populated color attachments are not from textures of the same target.
	/// 
	/// 
	/// GL_FRAMEBUFFER_UNDEFINED is returned if target is the default framebuffer, but the default framebuffer does not exist.
	/// 
	/// 
	/// GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT is returned if any of the framebuffer attachment points are framebuffer incomplete.
	/// 
	/// 
	/// GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT is returned if the framebuffer does not have at least one image attached to it.
	/// 
	/// 
	/// GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER is returned if the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
	/// is GL_NONE for any color attachment point(s) named by GL_DRAWBUFFERi.
	/// 
	/// 
	/// GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER is returned if GL_READ_BUFFER is not GL_NONE
	/// and the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_NONE for the color attachment point named
	/// by GL_READ_BUFFER.
	/// 
	/// 
	/// GL_FRAMEBUFFER_UNSUPPORTED is returned if the combination of internal formats of the attached images violates
	/// an implementation-dependent set of restrictions.
	/// 
	/// 
	/// GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE is returned if the value of GL_RENDERBUFFER_SAMPLES is not the same
	/// for all attached renderbuffers; if the value of GL_TEXTURE_SAMPLES is the not same for all attached textures; or, if the attached
	/// images are a mix of renderbuffers and textures, the value of GL_RENDERBUFFER_SAMPLES does not match the value of
	/// GL_TEXTURE_SAMPLES.
	/// 
	/// 
	/// GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE is also returned if the value of GL_TEXTURE_FIXED_SAMPLE_LOCATIONS is
	/// not the same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of GL_TEXTURE_FIXED_SAMPLE_LOCATIONS
	/// is not GL_TRUE for all attached textures.
	/// 
	/// 
	/// GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS is returned if any framebuffer attachment is layered, and any populated attachment is not layered,
	/// or if all populated color attachments are not from textures of the same target.
	/// 
	/// 
	/// 
	/// Additionally, if an error occurs, zero is returned.
	__gshared GLenum function(GLenum target) glCheckFramebufferStatus;
	/// Specify whether data read via glReadPixels should be clamped.
	/// 
	/// glClampColor controls color clamping that is performed during glReadPixels.
	/// target must be GL_CLAMP_READ_COLOR. If clamp is GL_TRUE,
	/// read color clamping is enabled; if clamp is GL_FALSE, read color clamping is disabled. If
	/// clamp is GL_FIXED_ONLY, read color clamping is enabled only if the selected read buffer has
	/// fixed point components and disabled otherwise.
	__gshared void function(GLenum target, GLenum clamp) glClampColor;
	/// Clear buffers to preset values.
	/// 
	/// glClear sets the bitplane area of the window to values previously selected
	/// by glClearColor, glClearDepth, and
	/// glClearStencil.
	/// Multiple color buffers can be cleared simultaneously by selecting
	/// more than one buffer at a time using glDrawBuffer.
	/// 
	/// 
	/// 
	/// The pixel ownership test,
	/// the scissor test,
	/// dithering, and the buffer writemasks affect the operation of glClear.
	/// The scissor box bounds the cleared region.
	/// Alpha function,
	/// blend function,
	/// logical operation,
	/// stenciling,
	/// texture mapping,
	/// and depth-buffering are ignored by glClear.
	/// 
	/// 
	/// glClear takes a single argument that is the bitwise OR of several
	/// values indicating which buffer is to be cleared.
	/// 
	/// 
	/// 
	/// The values are as follows:
	/// 
	/// 
	/// 
	/// Indicates the buffers currently enabled for color
	/// writing.
	/// 
	/// 
	/// 
	/// Indicates the depth buffer.
	/// 
	/// 
	/// 
	/// Indicates the stencil buffer.
	/// 
	/// 
	/// 
	/// The value to which each buffer is cleared depends on the setting of the
	/// clear value for that buffer.
	void glClear(GLbitfield mask);
	/// Clear individual buffers of the currently bound draw framebuffer.
	/// 
	/// glClearBuffer* clears the specified buffer to the specified value(s). If buffer is
	/// GL_COLOR, a particular draw buffer GL_DRAWBUFFERi is specified
	/// by passing i as drawBuffer. In this case, value points to
	/// a four-element vector specifying the R, G, B and A color to clear that draw buffer to. If buffer is
	/// one of GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT,
	/// or GL_FRONT_AND_BACK, identifying multiple buffers, each selected buffer is cleared to the same value.
	/// Clamping and conversion for fixed-point color buffers are performed in the same fashion as
	/// glClearColor.
	/// 
	/// 
	/// 
	/// If buffer is GL_DEPTH, drawBuffer must be zero, and value
	/// points to a single value to clear the depth buffer to. Only glClearBufferfv should be used to clear
	/// depth buffers. Clamping and conversion for fixed-point depth buffers are performed in the same fashion as
	/// glClearDepth.
	/// 
	/// 
	/// 
	/// If buffer is GL_STENCIL, drawBuffer must be zero, and value
	/// points to a single value to clear the stencil buffer to. Only glClearBufferiv should be used to clear
	/// stencil buffers. Masing and type conversion are performed in the same fashion as
	/// glClearStencil.
	/// 
	/// 
	/// glClearBufferfi may be used to clear the depth and stencil buffers. buffer must be
	/// GL_DEPTH_STENCIL and drawBuffer must be zero. depth and 
	/// stencil are the depth and stencil values, respectively.
	/// 
	/// 
	/// 
	/// The result of glClearBuffer is undefined if no conversion between the type of value
	/// and the buffer being cleared is defined. However, this is not an error.
	__gshared void function(GLenum buffer, GLint drawBuffer, const GLint * value) glClearBufferiv;
	/// Ditto
	__gshared void function(GLenum buffer, GLint drawBuffer, const GLuint * value) glClearBufferuiv;
	/// Ditto
	__gshared void function(GLenum buffer, GLint drawBuffer, const GLfloat * value) glClearBufferfv;
	/// Ditto
	__gshared void function(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil) glClearBufferfi;
	/// Specify clear values for the color buffers.
	/// 
	/// glClearColor specifies the red,
	/// green,
	/// blue,
	/// and alpha values used by glClear to clear the color buffers.
	/// Values specified by glClearColor are clamped to the range 
	/// 01.
	void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
	/// Specify the clear value for the depth buffer.
	/// 
	/// glClearDepth specifies the depth value used by glClear to clear the depth buffer.
	/// Values specified by glClearDepth are clamped to the range 
	/// 01.
	void glClearDepth(GLclampd depth);
	/// Ditto
	void glClearDepthf(GLclampf depth);
	/// Specify the clear value for the stencil buffer.
	/// 
	/// glClearStencil specifies the index used by glClear to clear the stencil buffer.
	/// s is masked with 
	/// 2m-1,
	/// where 
	/// m
	/// is the number of bits in the stencil buffer.
	void glClearStencil(GLint s);
	/// Block and wait for a sync object to become signaled.
	/// 
	/// glClientWaitSync causes the client to block and wait for the sync object specified by sync to become signaled. If
	/// sync is signaled when glClientWaitSync is called, glClientWaitSync returns immediately, otherwise
	/// it will block and wait for up to timeout nanoseconds for sync to become signaled.
	/// 
	/// 
	/// 
	/// The return value is one of four status values:
	/// GL_ALREADY_SIGNALED indicates that sync was signaled at the time that glClientWaitSync
	/// was called.
	/// GL_TIMEOUT_EXPIRED indicates that at least timeout nanoseconds passed and sync did not
	/// become signaled.
	/// GL_CONDITION_SATISFIED indicates that sync was signaled before the timeout expired.
	/// GL_WAIT_FAILED indicates that an error occurred. Additionally, an OpenGL error will be generated.
	/// 
	/// 
	/// GL_ALREADY_SIGNALED indicates that sync was signaled at the time that glClientWaitSync
	/// was called.
	/// 
	/// 
	/// GL_TIMEOUT_EXPIRED indicates that at least timeout nanoseconds passed and sync did not
	/// become signaled.
	/// 
	/// 
	/// GL_CONDITION_SATISFIED indicates that sync was signaled before the timeout expired.
	/// 
	/// 
	/// GL_WAIT_FAILED indicates that an error occurred. Additionally, an OpenGL error will be generated.
	__gshared GLenum function(GLsync sync, GLbitfield flags, GLint64 timeout) glClientWaitSync;
	/// Enable and disable writing of frame buffer color components.
	/// 
	/// glColorMask and glColorMaski specify whether the individual color components in the frame buffer
	/// can or cannot be written. glColorMaski sets the mask for a specific draw buffer, whereas
	/// glColorMask sets the mask for all draw buffers.
	/// If red is GL_FALSE,
	/// for example,
	/// no change is made to the red component of any pixel in any of the
	/// color buffers,
	/// regardless of the drawing operation attempted.
	/// 
	/// 
	/// 
	/// Changes to individual bits of components cannot be controlled.
	/// Rather,
	/// changes are either enabled or disabled for entire color components.
	void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
	/// Ditto
	void glColorMaski(GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
	/// Compiles a shader object.
	/// 
	/// glCompileShader compiles the source
	/// code strings that have been stored in the shader object
	/// specified by shader.
	/// 
	/// The compilation status will be stored as part of the
	/// shader object's state. This value will be set to
	/// GL_TRUE if the shader was compiled without
	/// errors and is ready for use, and GL_FALSE
	/// otherwise. It can be queried by calling
	/// glGetShader
	/// with arguments shader and
	/// GL_COMPILE_STATUS.
	/// 
	/// Compilation of a shader can fail for a number of reasons
	/// as specified by the OpenGL Shading Language Specification.
	/// Whether or not the compilation was successful, information about
	/// the compilation can be obtained from the shader object's
	/// information log by calling
	/// glGetShaderInfoLog.
	__gshared void function(GLuint shader) glCompileShader;
	/// Specify a one-dimensional texture image in a compressed format.
	/// 
	/// Texturing allows elements of an image array to be read by shaders.
	/// 
	/// 
	/// glCompressedTexImage1D loads a previously defined, and retrieved, compressed
	/// one-dimensional texture image if target is GL_TEXTURE_1D
	/// (see glTexImage1D).
	/// 
	/// 
	/// 
	/// If target is GL_PROXY_TEXTURE_1D, no data is read from data, but
	/// all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see glGetError). To query for an entire mipmap array, use an image array level greater than or equal to 1.
	/// 
	/// 
	/// internalformat must be an extension-specified compressed-texture format.
	/// When a texture is loaded with
	/// glTexImage1D using a generic compressed texture format
	/// (e.g., GL_COMPRESSED_RGB) the GL selects from one of
	/// its extensions supporting compressed textures. In order to load the
	/// compressed texture image using glCompressedTexImage1D, query the compressed texture image's size and
	/// format using glGetTexLevelParameter.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// specified, data is treated as a byte offset into the buffer object's data store.
	/// 
	/// 
	/// 
	/// If the compressed data are arranged into fixed-size blocks of texels, the pixel
	/// storage modes can be used to select a sub-rectangle from a larger containing rectangle.
	/// These pixel storage modes operate in the same way as they do for glTexImage1D.
	/// In the following description, denote by bs,
	/// bw,
	/// bh, and
	/// bd,
	/// the values of pixel storage modes GL_UNPACK_COMPRESSED_BLOCK_SIZE,
	/// GL_UNPACK_COMPRESSED_BLOCK_WIDTH, GL_UNPACK_COMPRESSED_BLOCK_HEIGHT,
	/// and GL_UNPACK_COMPRESSED_BLOCK_DEPTH, respectively.
	/// bs is
	/// the compressed block size in bytes; bw,
	/// bh,
	/// and bd are the compressed block width, height, and depth in pixels.
	/// 
	/// 
	/// 
	/// By default the pixel storage modes GL_UNPACK_ROW_LENGTH,
	/// GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_PIXELS,
	/// GL_UNPACK_IMAGE_HEIGHT and GL_UNPACK_SKIP_IMAGES
	/// are ignored for compressed images. To enable GL_UNPACK_SKIP_PIXELS
	/// and GL_UNPACK_ROW_LENGTH, bs
	/// and bw must both be non-zero.
	/// To also enable GL_UNPACK_SKIP_ROWS and GL_UNPACK_IMAGE_HEIGHT,
	/// bh must be non-zero.
	/// To also enable GL_UNPACK_SKIP_IMAGES, bd
	/// must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.
	/// 
	/// 
	/// 
	/// When selecting a sub-rectangle from a compressed image:
	/// the value of GL_UNPACK_SKIP_PIXELS must be a multiple of bw;
	/// 
	/// imageSize must be equal to:
	/// 
	/// 
	/// bswidthbw
	__gshared void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data) glCompressedTexImage1D;
	/// Specify a two-dimensional texture image in a compressed format.
	/// 
	/// Texturing allows elements of an image array to be read by shaders.
	/// 
	/// 
	/// glCompressedTexImage2D loads a previously defined, and retrieved, compressed two-dimensional
	/// texture image if target is GL_TEXTURE_2D, or one of the
	/// cube map faces such as GL_TEXTURE_CUBE_MAP_POSITIVE_X.
	/// (see glTexImage2D).
	/// 
	/// 
	/// 
	/// If target is GL_TEXTURE_1D_ARRAY, data
	/// is treated as an array of compressed 1D textures.
	/// 
	/// 
	/// 
	/// If target is GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY
	/// or GL_PROXY_CUBE_MAP, no data is read from data, but
	/// all of the texture image state is recalculated, checked for consistency,
	/// and checked against the implementation's capabilities. If the
	/// implementation cannot handle a texture of the requested texture size, it
	/// sets all of the image state to 0, but does not generate an error (see
	/// glGetError). To query for an entire mipmap array,
	/// use an image array level greater than or equal to 1.
	/// 
	/// 
	/// internalformat must be a known compressed image format (such as GL_RGTC)
	/// or an extension-specified compressed-texture format.
	/// When a texture is loaded with glTexImage2D using a generic compressed
	/// texture format (e.g., GL_COMPRESSED_RGB), the GL selects from one of
	/// its extensions supporting compressed textures. In order to load the
	/// compressed texture image using glCompressedTexImage2D, query the compressed texture image's
	/// size and format using glGetTexLevelParameter.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// specified, data is treated as a byte offset into the buffer object's data store.
	/// 
	/// 
	/// 
	/// If the compressed data are arranged into fixed-size blocks of texels, the pixel
	/// storage modes can be used to select a sub-rectangle from a larger containing rectangle.
	/// These pixel storage modes operate in the same way as they do for glTexImage2D.
	/// In the following description, denote by bs,
	/// bw,
	/// bh, and
	/// bd,
	/// the values of pixel storage modes GL_UNPACK_COMPRESSED_BLOCK_SIZE,
	/// GL_UNPACK_COMPRESSED_BLOCK_WIDTH, GL_UNPACK_COMPRESSED_BLOCK_HEIGHT,
	/// and GL_UNPACK_COMPRESSED_BLOCK_DEPTH, respectively.
	/// bs is
	/// the compressed block size in bytes; bw,
	/// bh,
	/// and bd are the compressed block width, height, and depth in pixels.
	/// 
	/// 
	/// 
	/// By default the pixel storage modes GL_UNPACK_ROW_LENGTH,
	/// GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_PIXELS,
	/// GL_UNPACK_IMAGE_HEIGHT and GL_UNPACK_SKIP_IMAGES
	/// are ignored for compressed images. To enable GL_UNPACK_SKIP_PIXELS
	/// and GL_UNPACK_ROW_LENGTH, bs
	/// and bw must both be non-zero.
	/// To also enable GL_UNPACK_SKIP_ROWS and GL_UNPACK_IMAGE_HEIGHT,
	/// bh must be non-zero.
	/// To also enable GL_UNPACK_SKIP_IMAGES, bd
	/// must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.
	/// 
	/// 
	/// 
	/// When selecting a sub-rectangle from a compressed image:
	/// the value of GL_UNPACK_SKIP_PIXELS must be a multiple of bw;the value of GL_UNPACK_SKIP_ROWS must be a multiple of bw.
	/// 
	/// imageSize must be equal to:
	/// 
	/// 
	/// bswidthbwheightbh
	__gshared void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data) glCompressedTexImage2D;
	/// Specify a three-dimensional texture image in a compressed format.
	/// 
	/// Texturing allows elements of an image array to be read by shaders.
	/// 
	/// 
	/// glCompressedTexImage3D loads a previously defined, and retrieved, compressed three-dimensional
	/// texture image if target is GL_TEXTURE_3D (see glTexImage3D).
	/// 
	/// 
	/// 
	/// If target is GL_TEXTURE_2D_ARRAY, data is
	/// treated as an array of compressed 2D textures.
	/// 
	/// 
	/// 
	/// If target is GL_PROXY_TEXTURE_3D or GL_PROXY_TEXTURE_2D_ARRAY,
	/// no data is read from data, but
	/// all of the texture image state is recalculated, checked for consistency,
	/// and checked against the implementation's capabilities. If the
	/// implementation cannot handle a texture of the requested texture size, it
	/// sets all of the image state to 0, but does not generate an error (see
	/// glGetError). To query for an entire mipmap array, use an image array level
	/// greater than or equal to 1.
	/// 
	/// 
	/// internalformat must be a known compressed image format (such as GL_RGTC)
	/// or an extension-specified compressed-texture format.
	/// When a texture is loaded with glTexImage2D using a generic compressed
	/// texture format (e.g., GL_COMPRESSED_RGB), the GL selects from one of
	/// its extensions supporting compressed textures. In order to load the
	/// compressed texture image using glCompressedTexImage3D, query the compressed texture image's
	/// size and format using glGetTexLevelParameter.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// specified, data is treated as a byte offset into the buffer object's data store.
	/// 
	/// 
	/// 
	/// If the compressed data are arranged into fixed-size blocks of texels, the pixel
	/// storage modes can be used to select a sub-rectangle from a larger containing rectangle.
	/// These pixel storage modes operate in the same way as they do for glTexImage1D.
	/// In the following description, denote by bs,
	/// bw,
	/// bh, and
	/// bd,
	/// the values of pixel storage modes GL_UNPACK_COMPRESSED_BLOCK_SIZE,
	/// GL_UNPACK_COMPRESSED_BLOCK_WIDTH, GL_UNPACK_COMPRESSED_BLOCK_HEIGHT,
	/// and GL_UNPACK_COMPRESSED_BLOCK_DEPTH, respectively.
	/// bs is
	/// the compressed block size in bytes; bw,
	/// bh,
	/// and bd are the compressed block width, height, and depth in pixels.
	/// 
	/// 
	/// 
	/// By default the pixel storage modes GL_UNPACK_ROW_LENGTH,
	/// GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_PIXELS,
	/// GL_UNPACK_IMAGE_HEIGHT and GL_UNPACK_SKIP_IMAGES
	/// are ignored for compressed images. To enable GL_UNPACK_SKIP_PIXELS
	/// and GL_UNPACK_ROW_LENGTH, bs
	/// and bw must both be non-zero.
	/// To also enable GL_UNPACK_SKIP_ROWS and GL_UNPACK_IMAGE_HEIGHT,
	/// bh must be non-zero.
	/// To also enable GL_UNPACK_SKIP_IMAGES, bd
	/// must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.
	/// 
	/// 
	/// 
	/// When selecting a sub-rectangle from a compressed image:
	/// the value of GL_UNPACK_SKIP_PIXELS must be a multiple of bw;the value of GL_UNPACK_SKIP_ROWS must be a multiple of bw;the value of GL_UNPACK_SKIP_IMAGES must be a multiple of bw.
	/// 
	/// imageSize must be equal to:
	/// 
	/// 
	/// bswidthbwheightbhdepthbd
	__gshared void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data) glCompressedTexImage3D;
	/// Specify a one-dimensional texture subimage in a compressed format.
	/// 
	/// Texturing allows elements of an image array to be read by shaders.
	/// 
	/// 
	/// glCompressedTexSubImage1D redefines a contiguous subregion of an existing one-dimensional
	/// texture image. The texels referenced by data replace the portion of the
	/// existing texture array with x indices xoffset and 
	/// xoffset+width-1,
	/// inclusive. This region may not include any texels
	/// outside the range of the texture array as it was originally specified. It
	/// is not an error to specify a subtexture with width of 0, but such a
	/// specification has no effect.
	/// 
	/// 
	/// internalformat must be a known compressed image format (such as GL_RGTC)
	/// or an extension-specified compressed-texture format.
	/// The format of the compressed texture
	/// image is selected by the GL implementation that compressed it (see
	/// glTexImage1D), and should be queried at the time the texture was
	/// compressed with glGetTexLevelParameter.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// specified, data is treated as a byte offset into the buffer object's data store.
	__gshared void function(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data) glCompressedTexSubImage1D;
	/// Specify a two-dimensional texture subimage in a compressed format.
	/// 
	/// Texturing allows elements of an image array to be read by shaders.
	/// 
	/// 
	/// glCompressedTexSubImage2D redefines a contiguous subregion of an existing two-dimensional
	/// texture image. The texels referenced by data replace the portion of the
	/// existing texture array with x indices xoffset and 
	/// xoffset+width-1,
	/// and the y indices yoffset and 
	/// yoffset+height-1,
	/// inclusive. 
	/// This region may not include any texels
	/// outside the range of the texture array as it was originally specified. It
	/// is not an error to specify a subtexture with width of 0, but such a
	/// specification has no effect.
	/// 
	/// 
	/// internalformat must be a known compressed image format (such as GL_RGTC)
	/// or an extension-specified compressed-texture format.
	/// The format of the compressed texture
	/// image is selected by the GL implementation that compressed it (see
	/// glTexImage2D) and should be queried at the time the texture was
	/// compressed with glGetTexLevelParameter.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// specified, data is treated as a byte offset into the buffer object's data store.
	__gshared void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data) glCompressedTexSubImage2D;
	/// Specify a three-dimensional texture subimage in a compressed format.
	/// 
	/// Texturing allows elements of an image array to be read by shaders.
	/// 
	/// 
	/// glCompressedTexSubImage3D redefines a contiguous subregion of an existing three-dimensional
	/// texture image. The texels referenced by data replace the portion of the
	/// existing texture array with x indices xoffset and
	/// xoffset+width-1,
	/// and the y indices yoffset and
	/// yoffset+height-1,
	/// and the z indices zoffset and
	/// zoffset+depth-1,
	/// inclusive. This region may not include
	/// any texels outside the range of the texture array as it was originally
	/// specified. It is not an error to specify a subtexture with width of 0,
	/// but such a specification has no effect.
	/// 
	/// 
	/// internalformat must be a known compressed image format (such as GL_RGTC)
	/// or an extension-specified compressed-texture format.
	/// The format of the compressed texture
	/// image is selected by the GL implementation that compressed it (see
	/// glTexImage3D) and should be queried at the time the texture was
	/// compressed with glGetTexLevelParameter.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// specified, data is treated as a byte offset into the buffer object's data store.
	__gshared void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data) glCompressedTexSubImage3D;
	/// Copy part of the data store of a buffer object to the data store of another buffer object.
	/// 
	/// glCopyBufferSubData copies part of the data store attached to readtarget to the
	/// data store attached to writetarget. The number of basic machine units indicated by size
	/// is copied from the source, at offset readoffset to the destination at writeoffset,
	/// also in basic machine units.
	/// 
	/// 
	/// readtarget and writetarget must be GL_ARRAY_BUFFER,
	/// GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER,
	/// GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER,
	/// GL_TRANSFORM_FEEDBACK_BUFFER or GL_UNIFORM_BUFFER. Any of these targets may be used,
	/// although the targets GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER are provided
	/// specifically to allow copies between buffers without disturbing other GL state.
	/// 
	/// 
	/// readoffset, writeoffset and size must all be greater than or equal to
	/// zero. Furthermore, readoffset + size must not exceeed the size of the buffer
	/// object bound to readtarget, and readoffset + size must not exceeed the
	/// size of the buffer bound to writetarget. If the same buffer object is bound to both readtarget
	/// and writetarget, then the ranges specified by readoffset, writeoffset
	/// and size must not overlap.
	__gshared void function(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size) glCopyBufferSubData;
	/// Copy pixels into a 1D texture image.
	/// 
	/// glCopyTexImage1D defines a one-dimensional texture image with pixels from the current
	/// GL_READ_BUFFER.
	/// 
	/// 
	/// 
	/// The screen-aligned pixel row with left corner at 
	/// xy
	/// and with a length of 
	/// width+2border
	/// defines the texture array
	/// at the mipmap level specified by level.
	/// internalformat specifies the internal format of the texture array.
	/// 
	/// 
	/// 
	/// The pixels in the row are processed exactly as if
	/// glReadPixels had been called, but the process stops just before
	/// final conversion.
	/// At this point all pixel component values are clamped to the range 
	/// 01
	/// and then converted to the texture's internal format for storage in the texel
	/// array.
	/// 
	/// 
	/// 
	/// Pixel ordering is such that lower 
	/// x
	/// screen coordinates correspond to
	/// lower texture coordinates.
	/// 
	/// 
	/// 
	/// If any of the pixels within the specified row of the current
	/// GL_READ_BUFFER are outside the window associated with the current
	/// rendering context, then the values obtained for those pixels are undefined.
	/// 
	/// 
	/// glCopyTexImage1D defines a one-dimensional texture image with pixels from the current
	/// GL_READ_BUFFER.
	/// 
	/// 
	/// 
	/// When internalformat is one of the sRGB types, the GL does not automatically convert the source pixels to the sRGB color space. In this case, the glPixelMap function can be used to accomplish the conversion.
	void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
	/// Copy pixels into a 2D texture image.
	/// 
	/// glCopyTexImage2D defines a two-dimensional texture image, or cube-map texture image
	/// with pixels from the current
	/// GL_READ_BUFFER.
	/// 
	/// 
	/// 
	/// The screen-aligned pixel rectangle with lower left corner at (x,
	/// y) and with a width of 
	/// width+2border
	/// and a height of
	/// height+2border
	/// defines the texture array
	/// at the mipmap level specified by level.
	/// internalformat specifies the internal format of the texture array.
	/// 
	/// 
	/// 
	/// The pixels in the rectangle are processed exactly as if
	/// glReadPixels had been called, but the process stops just before
	/// final conversion.
	/// At this point all pixel component values are clamped to the range 
	/// 01
	/// and then converted to the texture's internal format for storage in the texel
	/// array.
	/// 
	/// 
	/// 
	/// Pixel ordering is such that lower 
	/// x
	/// and 
	/// y
	/// screen coordinates correspond to
	/// lower 
	/// s
	/// and 
	/// t
	/// texture coordinates.
	/// 
	/// 
	/// 
	/// If any of the pixels within the specified rectangle of the current
	/// GL_READ_BUFFER are outside the window associated with the current
	/// rendering context, then the values obtained for those pixels are undefined.
	/// 
	/// 
	/// 
	/// When internalformat is one of the sRGB types, the GL does not automatically convert the source pixels to the sRGB color space. In this case, the glPixelMap function can be used to accomplish the conversion.
	void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
	/// Copy a one-dimensional texture subimage.
	/// 
	/// glCopyTexSubImage1D replaces a portion of a one-dimensional
	/// texture image with pixels from the current GL_READ_BUFFER (rather
	/// than from main memory, as is the case for glTexSubImage1D).
	/// 
	/// 
	/// 
	/// The screen-aligned pixel row with left corner at (x,\ y), and with
	/// length width replaces the portion of the
	/// texture array with x indices xoffset through 
	/// xoffset+width-1,
	/// inclusive. The destination in the texture array may not
	/// include any texels outside the texture array as it was
	/// originally specified.
	/// 
	/// 
	/// 
	/// The pixels in the row are processed exactly as if
	/// glReadPixels had been called, but the process stops just before
	/// final conversion.
	/// At this point, all pixel component values are clamped to the range 
	/// 01
	/// and then converted to the texture's internal format for storage in the texel
	/// array.
	/// 
	/// 
	/// 
	/// It is not an error to specify a subtexture with zero width, but
	/// such a specification has no effect.
	/// If any of the pixels within the specified row of the current
	/// GL_READ_BUFFER are outside the read window associated with the current
	/// rendering context, then the values obtained for those pixels are undefined.
	/// 
	/// 
	/// 
	/// No change is made to the internalformat, width,
	/// or border parameters of the specified texture
	/// array or to texel values outside the specified subregion.
	void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
	/// Copy a two-dimensional texture subimage.
	/// 
	/// glCopyTexSubImage2D replaces a rectangular portion of a two-dimensional texture image or
	/// cube-map texture image with pixels from the current GL_READ_BUFFER
	/// (rather than from main memory, as is the case for glTexSubImage2D).
	/// 
	/// 
	/// 
	/// The screen-aligned pixel rectangle with lower left corner at
	/// xy
	/// and with
	/// width width and height height replaces the portion of the
	/// texture array with x indices xoffset through 
	/// xoffset+width-1,
	/// inclusive, and y indices yoffset through 
	/// yoffset+height-1,
	/// inclusive, at the mipmap level specified by level.
	/// 
	/// 
	/// 
	/// The pixels in the rectangle are processed exactly as if
	/// glReadPixels had been called, but the process stops just before
	/// final conversion.
	/// At this point, all pixel component values are clamped to the range 
	/// 01
	/// and then converted to the texture's internal format for storage in the texel
	/// array.
	/// 
	/// 
	/// 
	/// The destination rectangle in the texture array may not include any texels
	/// outside the texture array as it was originally specified.
	/// It is not an error to specify a subtexture with zero width or height, but
	/// such a specification has no effect.
	/// 
	/// 
	/// 
	/// If any of the pixels within the specified rectangle of the current
	/// GL_READ_BUFFER are outside the read window associated with the current
	/// rendering context, then the values obtained for those pixels are undefined.
	/// 
	/// 
	/// 
	/// No change is made to the internalformat, width,
	/// height, or border parameters of the specified texture
	/// array or to texel values outside the specified subregion.
	void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	/// Copy a three-dimensional texture subimage.
	/// 
	/// glCopyTexSubImage3D replaces a rectangular portion of a three-dimensional
	/// texture image with pixels from the current GL_READ_BUFFER (rather
	/// than from main memory, as is the case for glTexSubImage3D).
	/// 
	/// 
	/// 
	/// The screen-aligned pixel rectangle with lower left corner at
	/// (x, y) and with
	/// width width and height height replaces the portion of the
	/// texture array with x indices xoffset through 
	/// xoffset+width-1,
	/// inclusive, and y indices yoffset through 
	/// yoffset+height-1,
	/// inclusive, at z index zoffset and at the mipmap level specified by level.
	/// 
	/// 
	/// 
	/// The pixels in the rectangle are processed exactly as if
	/// glReadPixels had been called, but the process stops just before
	/// final conversion.
	/// At this point, all pixel component values are clamped to the range 
	/// 01
	/// and then converted to the texture's internal format for storage in the texel
	/// array.
	/// 
	/// 
	/// 
	/// The destination rectangle in the texture array may not include any texels
	/// outside the texture array as it was originally specified.
	/// It is not an error to specify a subtexture with zero width or height, but
	/// such a specification has no effect.
	/// 
	/// 
	/// 
	/// If any of the pixels within the specified rectangle of the current
	/// GL_READ_BUFFER are outside the read window associated with the current
	/// rendering context, then the values obtained for those pixels are undefined.
	/// 
	/// 
	/// 
	/// No change is made to the internalformat, width,
	/// height, depth, or border parameters of the specified texture
	/// array or to texel values outside the specified subregion.
	__gshared void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) glCopyTexSubImage3D;
	/// Creates a program object.
	/// 
	/// glCreateProgram creates an empty
	/// program object and returns a non-zero value by which it can be
	/// referenced. A program object is an object to which shader
	/// objects can be attached. This provides a mechanism to specify
	/// the shader objects that will be linked to create a program. It
	/// also provides a means for checking the compatibility of the
	/// shaders that will be used to create a program (for instance,
	/// checking the compatibility between a vertex shader and a
	/// fragment shader). When no longer needed as part of a program
	/// object, shader objects can be detached.
	/// 
	/// One or more executables are created in a program object by
	/// successfully attaching shader objects to it with
	/// glAttachShader,
	/// successfully compiling the shader objects with
	/// glCompileShader,
	/// and successfully linking the program object with
	/// glLinkProgram.
	/// These executables are made part of current state when
	/// glUseProgram
	/// is called. Program objects can be deleted by calling
	/// glDeleteProgram.
	/// The memory associated with the program object will be deleted
	/// when it is no longer part of current rendering state for any
	/// context.
	__gshared GLuint function() glCreateProgram;
	/// Creates a shader object.
	/// 
	/// glCreateShader creates an empty
	/// shader object and returns a non-zero value by which it can be
	/// referenced. A shader object is used to maintain the source code
	/// strings that define a shader. shaderType
	/// indicates the type of shader to be created. Five types of shader
	/// are supported. A shader of type
	/// GL_VERTEX_SHADER is a shader that is
	/// intended to run on the programmable vertex processor.
	/// A shader of type GL_TESS_CONTROL_SHADER is a shader that
	/// is intended to run on the programmable tessellation processor in the control stage.
	/// A shader of type GL_TESS_EVALUATION_SHADER is a shader that
	/// is intended to run on the programmable tessellation processor in the evaluation stage.
	/// A shader of type
	/// GL_GEOMETRY_SHADER is a shader that is intended to
	/// run on the programmable geometry processor. A shader of
	/// type GL_FRAGMENT_SHADER is a shader that is
	/// intended to run on the programmable fragment processor.
	/// 
	/// When created, a shader object's
	/// GL_SHADER_TYPE parameter is set to either
	/// GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,
	/// GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER
	/// or GL_FRAGMENT_SHADER, depending on the value
	/// of shaderType.
	__gshared GLuint function(GLenum shaderType) glCreateShader;
	/// Create a stand-alone program from an array of null-terminated source code strings.
	/// 
	/// glCreateShaderProgram creates a program object containing compiled and linked
	/// shaders for a single stage specified by type. strings
	/// refers to an array of count strings from which to create the shader executables.
	/// 
	/// 
	/// glCreateShaderProgram is equivalent (assuming no errors are generated) to:
	/// 
	/// 
	/// 
	/// The program object created by glCreateShaderProgram has its GL_PROGRAM_SEPARABLE
	/// status set to GL_TRUE.
	__gshared GLuint function(GLenum type, GLsizei count, const char** strings) glCreateShaderProgramv;
	/// Specify whether front- or back-facing facets can be culled.
	/// 
	/// glCullFace specifies whether front- or back-facing facets are culled
	/// (as specified by mode) when facet culling is enabled. Facet
	/// culling is initially disabled.
	/// To enable and disable facet culling, call the
	/// glEnable and glDisable commands
	/// with the argument GL_CULL_FACE.
	/// Facets include triangles,
	/// quadrilaterals,
	/// polygons, and
	/// rectangles.
	/// 
	/// 
	/// glFrontFace specifies which of the clockwise and counterclockwise facets
	/// are front-facing and back-facing.
	/// See glFrontFace.
	void glCullFace(GLenum mode);
	/// Delete named buffer objects.
	/// 
	/// glDeleteBuffers deletes n buffer objects named by the elements of the array buffers.
	/// After a buffer object is deleted, it has no contents,
	/// and its name is free for reuse (for example by glGenBuffers).
	/// If a buffer object that is currently bound is deleted, the binding reverts
	/// to 0 (the absence of any buffer object).
	/// 
	/// 
	/// glDeleteBuffers silently ignores 0's and names that do not correspond to
	/// existing buffer objects.
	__gshared void function(GLsizei n, const GLuint * buffers) glDeleteBuffers;
	/// Delete framebuffer objects.
	/// 
	/// glDeleteFramebuffers deletes the n framebuffer objects whose names are stored in
	/// the array addressed by framebuffers. The name zero is reserved by the GL and is silently ignored, should it
	/// occur in framebuffers, as are other unused names. Once a framebuffer object is deleted, its name is again
	/// unused and it has no attachments. If a framebuffer that is currently bound to one or more of the targets GL_DRAW_FRAMEBUFFER
	/// or GL_READ_FRAMEBUFFER is deleted, it is as though glBindFramebuffer
	/// had been executed with the corresponding target and framebuffer zero.
	__gshared void function(GLsizei n, GLuint* framebuffers) glDeleteFramebuffers;
	/// Deletes a program object.
	/// 
	/// glDeleteProgram frees the memory and
	/// invalidates the name associated with the program object
	/// specified by program. This command
	/// effectively undoes the effects of a call to
	/// glCreateProgram.
	/// 
	/// If a program object is in use as part of current rendering
	/// state, it will be flagged for deletion, but it will not be
	/// deleted until it is no longer part of current state for any
	/// rendering context. If a program object to be deleted has shader
	/// objects attached to it, those shader objects will be
	/// automatically detached but not deleted unless they have already
	/// been flagged for deletion by a previous call to
	/// glDeleteShader.
	/// A value of 0 for program will be silently
	/// ignored.
	/// 
	/// To determine whether a program object has been flagged for
	/// deletion, call
	/// glGetProgram
	/// with arguments program and
	/// GL_DELETE_STATUS.
	__gshared void function(GLuint program) glDeleteProgram;
	/// Delete program pipeline objects.
	/// 
	/// glDeleteProgramPipelines deletes the n program pipeline objects
	/// whose names are stored in the array pipelines. Unused names in pipelines are
	/// ignored, as is the name zero. After a program pipeline object is deleted, its name is again unused and it
	/// has no contents. If program pipeline object that is currently bound is deleted, the binding for that object reverts to
	/// zero and no program pipeline object becomes current.
	__gshared void function(GLsizei n, const GLuint* pipelines) glDeleteProgramPipelines;
	/// Delete named query objects.
	/// 
	/// glDeleteQueries deletes n query objects named by the elements of the array ids.
	/// After a query object is deleted, it has no contents,
	/// and its name is free for reuse (for example by glGenQueries).
	/// 
	/// 
	/// glDeleteQueries silently ignores 0's and names that do not correspond to
	/// existing query objects.
	__gshared void function(GLsizei n, const GLuint * ids) glDeleteQueries;
	/// Delete renderbuffer objects.
	/// 
	/// glDeleteRenderbuffers deletes the n renderbuffer objects whose names are stored in
	/// the array addressed by renderbuffers. The name zero is reserved by the GL and is silently ignored, should it
	/// occur in renderbuffers, as are other unused names. Once a renderbuffer object is deleted, its name is again
	/// unused and it has no contents. If a renderbuffer that is currently bound to the target GL_RENDERBUFFER
	/// is deleted, it is as though glBindRenderbuffer
	/// had been executed with a target of GL_RENDERBUFFER and a name of zero.
	/// 
	/// 
	/// 
	/// If a renderbuffer object is attached to one or more attachment points in the currently bound framebuffer, then it as if
	/// glFramebufferRenderbuffer had been called, with a renderbuffer
	/// of zero for each attachment point to which this image was attached in the currently bound framebuffer. In other words,
	/// this renderbuffer object is first detached from all attachment ponits in the currently bound framebuffer. Note that the renderbuffer
	/// image is specifically not detached from any non-bound framebuffers.
	__gshared void function(GLsizei n, GLuint* renderbuffers) glDeleteRenderbuffers;
	/// Delete named sampler objects.
	/// 
	/// glDeleteSamplers deletes n sampler objects named by the elements of the array ids.
	/// After a sampler object is deleted, its name is again unused. If a sampler object that is currently bound to a sampler unit is deleted, it is as
	/// though glBindSampler is called with unit set to the unit the sampler is bound to and
	/// sampler zero. Unused names in samplers are silently ignored, as is the reserved name zero.
	__gshared void function(GLsizei n, const GLuint * ids) glDeleteSamplers;
	/// Deletes a shader object.
	/// 
	/// glDeleteShader frees the memory and
	/// invalidates the name associated with the shader object specified
	/// by shader. This command effectively
	/// undoes the effects of a call to
	/// glCreateShader.
	/// 
	/// If a shader object to be deleted is attached to a program
	/// object, it will be flagged for deletion, but it will not be
	/// deleted until it is no longer attached to any program object,
	/// for any rendering context (i.e., it must be detached from
	/// wherever it was attached before it will be deleted). A value of
	/// 0 for shader will be silently
	/// ignored.
	/// 
	/// To determine whether an object has been flagged for
	/// deletion, call
	/// glGetShader
	/// with arguments shader and
	/// GL_DELETE_STATUS.
	__gshared void function(GLuint shader) glDeleteShader;
	/// Delete a sync object.
	/// 
	/// glDeleteSync deletes the sync object specified by sync. If the fence command
	/// corresponding to the specified sync object has completed, or if no glWaitSync
	/// or glClientWaitSync commands are blocking on sync,
	/// the object is deleted immediately. Otherwise, sync is flagged for deletion and will be deleted when
	/// it is no longer associated with any fence command and is no longer blocking any glWaitSync
	/// or glClientWaitSync command. In either case, after
	/// glDeleteSync returns, the name sync is invalid and can no longer be used to
	/// refer to the sync object.
	/// 
	/// 
	/// glDeleteSync will silently ignore a sync value of zero.
	__gshared void function(GLsync sync) glDeleteSync;
	/// Delete named textures.
	/// 
	/// glDeleteTextures deletes n textures named by the elements of the array textures.
	/// After a texture is deleted, it has no contents or dimensionality,
	/// and its name is free for reuse (for example by glGenTextures).
	/// If a texture that is currently bound is deleted, the binding reverts
	/// to 0 (the default texture).
	/// 
	/// 
	/// glDeleteTextures silently ignores 0's and names that do not correspond to
	/// existing textures.
	void glDeleteTextures(GLsizei n, const GLuint * textures);
	/// Delete transform feedback objects.
	/// 
	/// glDeleteTransformFeedbacks deletes the n transform feedback objects
	/// whose names are stored in the array ids. Unused names in ids are
	/// ignored, as is the name zero. After a transform feedback object is deleted, its name is again unused and it
	/// has no contents. If an active transform feedback object is deleted, its name immediately becomes unused, but
	/// the underlying object is not deleted until it is no longer active.
	__gshared void function(GLsizei n, const GLuint* ids) glDeleteTransformFeedbacks;
	/// Delete vertex array objects.
	/// 
	/// glDeleteVertexArrays deletes n vertex array objects whose names are stored in the
	/// array addressed by arrays. Once a vertex array object is deleted it has no contents and its name is
	/// again unused. If a vertex array object that is currently bound is deleted, the binding for that object reverts to zero
	/// and the default vertex array becomes current. Unused names in arrays are silently ignored, as is the value zero.
	__gshared void function(GLsizei n, const GLuint* arrays) glDeleteVertexArrays;
	/// Specify the value used for depth buffer comparisons.
	/// 
	/// glDepthFunc specifies the function used to compare each incoming pixel depth value
	/// with the depth value present in the depth buffer.
	/// The comparison is performed only if depth testing is enabled.
	/// (See glEnable and glDisable of GL_DEPTH_TEST.)
	/// 
	/// 
	/// func specifies the conditions under which the pixel will be drawn.
	/// The comparison functions are as follows:
	/// 
	/// 
	/// 
	/// Never passes.
	/// 
	/// 
	/// 
	/// Passes if the incoming depth value is less than the stored depth value.
	/// 
	/// 
	/// 
	/// Passes if the incoming depth value is equal to the stored depth value.
	/// 
	/// 
	/// 
	/// Passes if the incoming depth value is less than or equal to
	/// the stored depth value.
	/// 
	/// 
	/// 
	/// Passes if the incoming depth value is greater than the stored depth value.
	/// 
	/// 
	/// 
	/// Passes if the incoming depth value is not equal to the stored depth value.
	/// 
	/// 
	/// 
	/// Passes if the incoming depth value is greater than or equal to
	/// the stored depth value.
	/// 
	/// 
	/// 
	/// Always passes.
	/// 
	/// 
	/// 
	/// The initial value of func is GL_LESS.
	/// Initially, depth testing is disabled. If depth testing is disabled or if no
	/// depth buffer exists, it is as if the depth test always passes.
	void glDepthFunc(GLenum func);
	/// Enable or disable writing into the depth buffer.
	/// 
	/// glDepthMask specifies whether the depth buffer is enabled for writing.
	/// If flag is GL_FALSE,
	/// depth buffer writing is disabled.
	/// Otherwise, it is enabled.
	/// Initially, depth buffer writing is enabled.
	void glDepthMask(GLboolean flag);
	/// Specify mapping of depth values from normalized device coordinates to window coordinates.
	/// 
	/// After clipping and division by w,
	/// depth coordinates range from 
	/// -1
	/// to 1,
	/// corresponding to the near and far clipping planes.
	/// glDepthRange specifies a linear mapping of the normalized depth coordinates
	/// in this range to window depth coordinates.
	/// Regardless of the actual depth buffer implementation,
	/// window coordinate depth values are treated as though they range
	/// from 0 through 1 (like color components).
	/// Thus,
	/// the values accepted by glDepthRange are both clamped to this range
	/// before they are accepted.
	/// 
	/// 
	/// 
	/// The setting of (0,1) maps the near plane to 0 and
	/// the far plane to 1.
	/// With this mapping,
	/// the depth buffer range is fully utilized.
	void glDepthRange(GLclampd nearVal, GLclampd farVal);
	/// Ditto
	void glDepthRangef(GLclampf nearVal, GLclampf farVal);
	/// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports.
	/// 
	/// After clipping and division by w,
	/// depth coordinates range from 
	/// -1
	/// to 1,
	/// corresponding to the near and far clipping planes.
	/// Each viewport has an independent depth range specified as a linear mapping of the normalized
	/// depth coordinates in this range to window depth coordinates.
	/// Regardless of the actual depth buffer implementation,
	/// window coordinate depth values are treated as though they range
	/// from 0 through 1 (like color components).
	/// glDepthRangeArray specifies a linear mapping of the normalized depth coordinates
	/// in this range to window depth coordinates for each viewport in the range [first,
	/// first + count$(RPAREN).
	/// Thus,
	/// the values accepted by glDepthRangeArray are both clamped to this range
	/// before they are accepted.
	/// 
	/// 
	/// 
	/// The first parameter specifies the index of the first viewport whose depth
	/// range to modify and must be less than the value of GL_MAX_VIEWPORTS.
	/// count specifies the number of viewports whose depth range to modify.
	/// first + count must be less than or equal to
	/// the value of GL_MAX_VIEWPORTS. v specifies the address of an
	/// array of pairs of double precision floating point values representing the near and far values of the
	/// depth range for each viewport, in that order.
	/// 
	/// 
	/// 
	/// The setting of (0,1) maps the near plane to 0 and
	/// the far plane to 1.
	/// With this mapping,
	/// the depth buffer range is fully utilized.
	__gshared void function(GLuint first, GLsizei count, const GLclampd* v) glDepthRangeArrayv;
	/// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport.
	/// 
	/// After clipping and division by w,
	/// depth coordinates range from 
	/// -1
	/// to 1,
	/// corresponding to the near and far clipping planes.
	/// Each viewport has an independent depth range specified as a linear mapping of the normalized
	/// depth coordinates in this range to window depth coordinates.
	/// Regardless of the actual depth buffer implementation,
	/// window coordinate depth values are treated as though they range
	/// from 0 through 1 (like color components).
	/// glDepthRangeIndexed specifies a linear mapping of the normalized depth coordinates
	/// in this range to window depth coordinates for a specified viewport.
	/// Thus,
	/// the values accepted by glDepthRangeIndexed are both clamped to this range
	/// before they are accepted.
	/// 
	/// 
	/// 
	/// The index parameter specifies the index of first viewport whose depth
	/// range to modify and must be less than the value of GL_MAX_VIEWPORTS.
	/// nearVal and farVal specify near and far values of the
	/// depth range for the specified viewport, respectively.
	/// 
	/// 
	/// 
	/// The setting of (0,1) maps the near plane to 0 and
	/// the far plane to 1.
	/// With this mapping,
	/// the depth buffer range is fully utilized.
	__gshared void function(GLuint index, GLclampd nearVal, GLclampd farVal) glDepthRangeIndexed;
	/// Detaches a shader object from a program object to which it is attached.
	/// 
	/// glDetachShader detaches the shader
	/// object specified by shader from the
	/// program object specified by program. This
	/// command can be used to undo the effect of the command
	/// glAttachShader.
	/// 
	/// If shader has already been flagged
	/// for deletion by a call to
	/// glDeleteShader
	/// and it is not attached to any other program object, it will be
	/// deleted after it has been detached.
	__gshared void function(GLuint program, GLuint shader) glDetachShader;
	/// Render primitives from array data.
	/// 
	/// glDrawArrays specifies multiple geometric primitives
	/// with very few subroutine calls. Instead of calling a GL procedure
	/// to pass each individual vertex, normal, texture coordinate, edge
	/// flag, or color, you can prespecify
	/// separate arrays of vertices, normals, and colors and use them to
	/// construct a sequence of primitives with a single
	/// call to glDrawArrays.
	/// 
	/// 
	/// 
	/// When glDrawArrays is called, it uses count sequential elements from each
	/// enabled array to construct a sequence of geometric primitives,
	/// beginning with element first. mode specifies what kind of
	/// primitives are constructed and how the array elements
	/// construct those primitives.
	/// 
	/// 
	/// 
	/// Vertex attributes that are modified by glDrawArrays have an
	/// unspecified value after glDrawArrays returns. Attributes that aren't
	/// modified remain well defined.
	void glDrawArrays(GLenum mode, GLint first, GLsizei count);
	/// Render primitives from array data, taking parameters from memory.
	/// 
	/// glDrawArraysIndirect specifies multiple geometric primitives
	/// with very few subroutine calls. glDrawArraysIndirect behaves
	/// similarly to glDrawArraysInstancedBaseInstance,
	/// execept that the parameters to glDrawArraysInstancedBaseInstance
	/// are stored in memory at the address given by indirect.
	/// 
	/// 
	/// 
	/// The parameters addressed by indirect are packed into a structure
	/// that takes the form (in C):
	/// typedef struct {
	/// uint count;
	/// uint primCount;
	/// uint first;
	/// uint baseInstance;
	/// } DrawArraysIndirectCommand;
	/// 
	/// const DrawArraysIndirectCommand *cmd = (const DrawArraysIndirectCommand *)indirect;
	/// glDrawArraysInstancedBaseInstance(mode, cmd->first, cmd->count, cmd->primCount, cmd->baseInstance);
	/// 
	/// 
	/// If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the time
	/// of a call to glDrawArraysIndirect, indirect
	/// is interpreted as an offset, in basic machine units, into that buffer and the parameter
	/// data is read from the buffer rather than from client memory.
	/// 
	/// 
	/// 
	/// In contrast to glDrawArraysInstancedBaseInstance,
	/// the first member of the parameter structure is unsigned, and out-of-range indices
	/// do not generate an error.
	/// 
	/// 
	/// 
	/// Vertex attributes that are modified by glDrawArraysIndirect have an
	/// unspecified value after glDrawArraysIndirect returns. Attributes that aren't
	/// modified remain well defined.
	__gshared void function(GLenum mode, const void* indirect) glDrawArraysIndirect;
	/// Draw multiple instances of a range of elements.
	/// 
	/// glDrawArraysInstanced behaves identically to glDrawArrays
	/// except that primcount instances of the range of elements are executed and the value of the internal counter
	/// instanceID advances for each iteration. instanceID is an internal 32-bit integer counter
	/// that may be read by a vertex shader as gl_InstanceID.
	/// 
	/// 
	/// glDrawArraysInstanced has the same effect as:
	/// if ( mode or count is invalid )
	/// generate appropriate error
	/// else {
	/// for (int i = 0; i < primcount ; i++) {
	/// instanceID = i;
	/// glDrawArrays(mode, first, count);
	/// }
	/// instanceID = 0;
	/// }
	__gshared void function(GLenum mode, GLint first, GLsizei count, GLsizei primcount) glDrawArraysInstanced;
	/// Draw multiple instances of a range of elements with offset applied to instanced attributes.
	/// 
	/// glDrawArraysInstancedBaseInstance behaves identically to glDrawArrays
	/// except that primcount instances of the range of elements are executed and the value of the internal counter
	/// instanceID advances for each iteration. instanceID is an internal 32-bit integer counter
	/// that may be read by a vertex shader as gl_InstanceID.
	/// 
	/// 
	/// glDrawArraysInstancedBaseInstance has the same effect as:
	/// if ( mode or count is invalid )
	/// generate appropriate error
	/// else {
	/// for (int i = 0; i < primcount ; i++) {
	/// instanceID = i;
	/// glDrawArrays(mode, first, count);
	/// }
	/// instanceID = 0;
	/// }
	/// 
	/// 
	/// Specific vertex attributes may be classified as instanced through the use of
	/// glVertexAttribDivisor. Instanced vertex attributes
	/// supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex
	/// attribute arrays is calculated as:
	/// gl_InstanceIDdivisorbaseInstance. Note that baseinstance does not affect the shader-visible value of gl_InstanceID.
	__gshared void function(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance) glDrawArraysInstancedBaseInstance;
	/// Specify which color buffers are to be drawn into.
	/// 
	/// When colors are written to the frame buffer,
	/// they are written into the color buffers specified by glDrawBuffer.
	/// The specifications are as follows:
	/// 
	/// 
	/// 
	/// No color buffers are written.
	/// 
	/// 
	/// 
	/// Only the front left color buffer is written.
	/// 
	/// 
	/// 
	/// Only the front right color buffer is written.
	/// 
	/// 
	/// 
	/// Only the back left color buffer is written.
	/// 
	/// 
	/// 
	/// Only the back right color buffer is written.
	/// 
	/// 
	/// 
	/// Only the front left and front right color buffers are written.
	/// If there is no front right color buffer,
	/// only the front left color buffer is written.
	/// 
	/// 
	/// 
	/// Only the back left and back right color buffers are written.
	/// If there is no back right color buffer,
	/// only the back left color buffer is written.
	/// 
	/// 
	/// 
	/// Only the front left and back left color buffers are written.
	/// If there is no back left color buffer,
	/// only the front left color buffer is written.
	/// 
	/// 
	/// 
	/// Only the front right and back right color buffers are written.
	/// If there is no back right color buffer,
	/// only the front right color buffer is written.
	/// 
	/// 
	/// 
	/// All the front and back color buffers
	/// (front left, front right, back left, back right)
	/// are written.
	/// If there are no back color buffers,
	/// only the front left and front right color buffers are written.
	/// If there are no right color buffers,
	/// only the front left and back left color buffers are written.
	/// If there are no right or back color buffers,
	/// only the front left color buffer is written.
	/// 
	/// 
	/// 
	/// If more than one color buffer is selected for drawing,
	/// then blending or logical operations are computed and applied independently
	/// for each color buffer and can produce different results in each buffer.
	/// 
	/// 
	/// 
	/// Monoscopic contexts include only
	/// left
	/// buffers, and stereoscopic contexts include both
	/// left
	/// and
	/// right
	/// buffers.
	/// Likewise, single-buffered contexts include only
	/// front
	/// buffers, and double-buffered contexts include both
	/// front
	/// and
	/// back
	/// buffers.
	/// The context is selected at GL initialization.
	void glDrawBuffer(GLenum mode);
	/// Specifies a list of color buffers to be drawn into.
	/// 
	/// glDrawBuffers defines an array of
	/// buffers into which outputs from the fragment shader data will
	/// be written. If a fragment shader writes a value
	/// to one or more user defined output
	/// variables, then the value of each variable will be written into the
	/// buffer specified at a location within bufs
	/// corresponding to the location assigned to that user defined output.
	/// The draw buffer used for user defined outputs assigned to locations
	/// greater than or equal to n is implicitly set
	/// to GL_NONE and any data written to such an output
	/// is discarded.
	/// 
	/// The symbolic constants contained in
	/// bufs may be any of the following:
	/// 
	/// The fragment shader output value is not written into
	/// any color buffer.
	/// 
	/// The fragment shader output value is written into the
	/// front left color buffer.
	/// 
	/// The fragment shader output value is written into the
	/// front right color buffer.
	/// 
	/// The fragment shader output value is written into the
	/// back left color buffer.
	/// 
	/// The fragment shader output value is written into the
	/// back right color buffer.
	/// 
	/// The fragment shader output value is written into the
	/// nth color attachment of the current framebuffer.
	/// n may range from 0 to the value of
	/// GL_MAX_COLOR_ATTACHMENTS.
	/// 
	/// Except for GL_NONE, the preceding
	/// symbolic constants may not appear more than once in
	/// bufs. The maximum number of draw buffers
	/// supported is implementation dependent and can be queried by
	/// calling
	/// glGet
	/// with the argument GL_MAX_DRAW_BUFFERS.
	void glDrawBuffers(GLsizei n, const GLenum* bufs);
	/// Render primitives from array data.
	/// 
	/// glDrawElements specifies multiple geometric primitives
	/// with very few subroutine calls. Instead of calling a GL function
	/// to pass each individual vertex, normal, texture coordinate, edge
	/// flag, or color, you can prespecify
	/// separate arrays of vertices, normals, and so on, and use them to
	/// construct a sequence of primitives with a single
	/// call to glDrawElements.
	/// 
	/// 
	/// 
	/// When glDrawElements is called, it uses count sequential elements from an
	/// enabled array, starting at indices to construct a sequence of
	/// geometric primitives. mode specifies what kind of primitives are
	/// constructed and how the array elements construct these primitives. If
	/// more than one array is enabled, each is used.
	/// 
	/// 
	/// 
	/// Vertex attributes that are modified by glDrawElements have an
	/// unspecified value after glDrawElements returns. Attributes that aren't
	/// modified maintain their previous values.
	void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices);
	/// Render primitives from array data with a per-element offset.
	/// 
	/// glDrawElementsBaseVertex behaves identically to
	/// glDrawElements except that the ith element
	/// transferred by the corresponding draw call will be taken from element indices[i] + basevertex
	/// of each enabled array. If the resulting value is larger than the maximum value representable by type,
	/// it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions).
	/// The operation is undefined if the sum would be negative.
	__gshared void function(GLenum mode, GLsizei count, GLenum type, GLvoid* indices, GLint basevertex) glDrawElementsBaseVertex;
	/// Render indexed primitives from array data, taking parameters from memory.
	/// 
	/// glDrawElementsIndirect specifies multiple indexed geometric primitives
	/// with very few subroutine calls. glDrawElementsIndirect behaves
	/// similarly to glDrawElementsInstancedBaseVertexBaseInstance,
	/// execpt that the parameters to glDrawElementsInstancedBaseVertexBaseInstance
	/// are stored in memory at the address given by indirect.
	/// 
	/// 
	/// 
	/// The parameters addressed by indirect are packed into a structure
	/// that takes the form (in C):
	/// typedef struct {
	/// uint count;
	/// uint primCount;
	/// uint firstIndex;
	/// uint baseVertex;
	/// uint baseInstance;
	/// } DrawElementsIndirectCommand;glDrawElementsIndirect is equivalent to:
	/// void glDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect)
	/// {
	/// const DrawElementsIndirectCommand *cmd = (const DrawElementsIndirectCommand *)indirect;
	/// glDrawElementsInstancedBaseVertexBaseInstance(mode,
	/// cmd->count,
	/// type,
	/// cmd->firstIndex + size-of-type,
	/// cmd->primCount,
	/// cmd->baseVertex,
	/// cmd->baseInstance);
	/// }
	/// 
	/// glDrawElementsIndirect is equivalent to:
	/// 
	/// 
	/// 
	/// If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the time
	/// of a call to glDrawElementsIndirect, indirect
	/// is interpreted as an offset, in basic machine units, into that buffer and the parameter
	/// data is read from the buffer rather than from client memory.
	/// 
	/// 
	/// 
	/// Note that indices stored in client memory are not supported. If no buffer is bound to the
	/// GL_ELEMENT_ARRAY_BUFFER binding, an error will be generated.
	/// 
	/// 
	/// 
	/// The results of the operation are undefined if the reservedMustBeZero member
	/// of the parameter structure is non-zero. However, no error is generated in this case.
	/// 
	/// 
	/// 
	/// Vertex attributes that are modified by glDrawElementsIndirect have an
	/// unspecified value after glDrawElementsIndirect returns. Attributes that aren't
	/// modified remain well defined.
	__gshared void function(GLenum mode, GLenum type, const void* indirect) glDrawElementsIndirect;
	/// Draw multiple instances of a set of elements.
	/// 
	/// glDrawElementsInstanced behaves identically to glDrawElements
	/// except that primcount instances of the set of elements are executed and the value of the internal counter
	/// instanceID advances for each iteration. instanceID is an internal 32-bit integer counter
	/// that may be read by a vertex shader as gl_InstanceID.
	/// 
	/// 
	/// glDrawElementsInstanced has the same effect as:
	/// if (mode, count, or type is invalid )
	/// generate appropriate error
	/// else {
	/// for (int i = 0; i < primcount ; i++) {
	/// instanceID = i;
	/// glDrawElements(mode, count, type, indices);
	/// }
	/// instanceID = 0;
	/// }
	__gshared void function(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount) glDrawElementsInstanced;
	/// Draw multiple instances of a set of elements with offset applied to instanced attributes.
	/// 
	/// glDrawElementsInstancedBaseInstance behaves identically to glDrawElements
	/// except that primcount instances of the set of elements are executed and the value of the internal counter
	/// instanceID advances for each iteration. instanceID is an internal 32-bit integer counter
	/// that may be read by a vertex shader as gl_InstanceID.
	/// 
	/// 
	/// glDrawElementsInstancedBaseInstance has the same effect as:
	/// if (mode, count, or type is invalid )
	/// generate appropriate error
	/// else {
	/// for (int i = 0; i < primcount ; i++) {
	/// instanceID = i;
	/// glDrawElements(mode, count, type, indices);
	/// }
	/// instanceID = 0;
	/// }
	/// 
	/// 
	/// Specific vertex attributes may be classified as instanced through the use of
	/// glVertexAttribDivisor. Instanced vertex attributes
	/// supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex
	/// attribute arrays is calculated as
	/// gl_InstanceIDdivisorbaseInstance. Note that baseinstance does not affect the shader-visible value of gl_InstanceID.
	__gshared void function(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount, GLuint baseinstance) glDrawElementsInstancedBaseInstance;
	/// Render multiple instances of a set of primitives from array data with a per-element offset.
	/// 
	/// glDrawElementsInstancedBaseVertex behaves identically to
	/// glDrawElementsInstanced except that the ith element
	/// transferred by the corresponding draw call will be taken from element indices[i] + basevertex
	/// of each enabled array. If the resulting value is larger than the maximum value representable by type,
	/// it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions).
	/// The operation is undefined if the sum would be negative.
	__gshared void function(GLenum mode, GLsizei count, GLenum type, GLvoid* indices, GLsizei primcount, GLint basevertex) glDrawElementsInstancedBaseVertex;
	/// Render multiple instances of a set of primitives from array data with a per-element offset.
	/// 
	/// glDrawElementsInstancedBaseVertexBaseInstance behaves identically to
	/// glDrawElementsInstanced except that the ith element
	/// transferred by the corresponding draw call will be taken from element indices[i] + basevertex
	/// of each enabled array. If the resulting value is larger than the maximum value representable by type,
	/// it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions).
	/// The operation is undefined if the sum would be negative. The basevertex has no effect on the
	/// shader-visible value of gl_VertexID.
	/// 
	/// 
	/// 
	/// Specific vertex attributes may be classified as instanced through the use of
	/// glVertexAttribDivisor. Instanced vertex attributes
	/// supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex
	/// attribute arrays is calculated as
	/// gl_InstanceIDdivisorbaseInstance. Note that baseinstance does not affect the shader-visible value of gl_InstanceID.
	__gshared void function(GLenum mode, GLsizei count, GLenum type, GLvoid* indices, GLsizei primcount, GLint basevertex, GLuint baseinstance) glDrawElementsInstancedBaseVertexBaseInstance;
	/// Render primitives from array data.
	/// 
	/// glDrawRangeElements is a restricted form of glDrawElements. mode, start, end,
	/// and count match the corresponding arguments to glDrawElements, with
	/// the additional constraint that all values in the arrays count must lie
	/// between start and end, inclusive.
	/// 
	/// 
	/// 
	/// Implementations denote recommended maximum amounts of vertex and
	/// index data,
	/// which may be queried by calling glGet with argument
	/// GL_MAX_ELEMENTS_VERTICES and GL_MAX_ELEMENTS_INDICES.
	/// If 
	/// end-start+1
	/// is greater than the value of
	/// GL_MAX_ELEMENTS_VERTICES, or if count is greater than the value of
	/// GL_MAX_ELEMENTS_INDICES, then the call may operate at reduced
	/// performance. There is no requirement that all vertices in the range
	/// startend
	/// be referenced. However, the implementation may
	/// partially process unused vertices, reducing performance from what could
	/// be achieved with an optimal index set.
	/// 
	/// 
	/// 
	/// When glDrawRangeElements is called, it uses count sequential elements from an
	/// enabled array, starting at start to construct a sequence of
	/// geometric primitives. mode specifies what kind of primitives are
	/// constructed, and how the array elements construct these primitives. If
	/// more than one array is enabled, each is used. 
	/// 
	/// 
	/// 
	/// Vertex attributes that are modified by glDrawRangeElements have an
	/// unspecified value after glDrawRangeElements returns. Attributes that aren't
	/// modified maintain their previous values.
	__gshared void function(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices) glDrawRangeElements;
	/// Render primitives from array data with a per-element offset.
	/// 
	/// glDrawRangeElementsBaseVertex is a restricted form of
	/// glDrawElementsBaseVertex. mode,
	/// start, end, count and basevertex match
	/// the corresponding arguments to glDrawElementsBaseVertex, with the additional
	/// constraint that all values in the array indices must lie between start and end,
	/// inclusive, prior to adding basevertex. Index values lying outside the range [start, end]
	/// are treated in the same way as glDrawElementsBaseVertex. The ith element
	/// transferred by the corresponding draw call will be taken from element indices[i] + basevertex of each enabled
	/// array. If the resulting value is larger than the maximum value representable by type, it is as if the calculation were upconverted to
	/// 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
	__gshared void function(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLvoid* indices, GLint basevertex) glDrawRangeElementsBaseVertex;
	/// Render primitives using a count derived from a transform feedback object.
	/// 
	/// glDrawTransformFeedback draws primitives of a type specified by mode using
	/// a count retrieved from the transform feedback specified by id. Calling glDrawTransformFeedback
	/// is equivalent to calling glDrawArrays with mode
	/// as specified, first set to zero, and count set to the number of vertices captured
	/// on vertex stream zero the last time transform feedback was active on the transform feedback object named by id.
	__gshared void function(GLenum mode, GLuint id) glDrawTransformFeedback;
	/// Render multiple instances of primitives using a count derived from a transform feedback object.
	/// 
	/// glDrawTransformFeedbackInstanced draws multiple copies of a range of primitives of a type specified by mode using
	/// a count retrieved from the transform feedback stream specified by stream of the transform feedback object
	/// specified by id. Calling glDrawTransformFeedbackInstanced
	/// is equivalent to calling glDrawArraysInstanced with mode
	/// and primcount as specified, first set to zero, and count set to the number of vertices captured
	/// on vertex stream zero the last time transform feedback was active on the transform feedback object named
	/// by id.
	/// 
	/// 
	/// 
	/// Calling glDrawTransformFeedbackInstanced is equivalent to calling glDrawTransformFeedbackStreamInstanced
	/// with stream set to zero.
	__gshared void function(GLenum mode, GLuint id, GLsizei primcount) glDrawTransformFeedbackInstanced;
	/// Render primitives using a count derived from a specifed stream of a transform feedback object.
	/// 
	/// glDrawTransformFeedbackStream draws primitives of a type specified by mode using
	/// a count retrieved from the transform feedback stream specified by stream of the transform feedback object
	/// specified by id. Calling glDrawTransformFeedbackStream
	/// is equivalent to calling glDrawArrays with mode
	/// as specified, first set to zero, and count set to the number of vertices captured
	/// on vertex stream stream the last time transform feedback was active on the transform feedback object named
	/// by id.
	/// 
	/// 
	/// 
	/// Calling glDrawTransformFeedback is equivalent to calling glDrawTransformFeedbackStream
	/// with stream set to zero.
	__gshared void function(GLenum mode, GLuint id, GLuint stream) glDrawTransformFeedbackStream;
	/// Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object.
	/// 
	/// glDrawTransformFeedbackStreamInstanced draws multiple copies of a range of primitives of a type specified by mode using
	/// a count retrieved from the transform feedback stream specified by stream of the transform feedback object
	/// specified by id. Calling glDrawTransformFeedbackStreamInstanced
	/// is equivalent to calling glDrawArraysInstanced with mode
	/// and primcount as specified, first set to zero, and count set to the number of vertices captured
	/// on vertex stream stream the last time transform feedback was active on the transform feedback object named
	/// by id.
	/// 
	/// 
	/// 
	/// Calling glDrawTransformFeedbackInstanced is equivalent to calling glDrawTransformFeedbackStreamInstanced
	/// with stream set to zero.
	__gshared void function(GLenum mode, GLuint id, GLuint stream, GLsizei primcount) glDrawTransformFeedbackStreamInstanced;
	/// Enable or disable server-side GL capabilities.
	/// 
	/// glEnable and glDisable enable and disable various capabilities.
	/// Use glIsEnabled or glGet to determine the current setting
	/// of any capability. The initial value for each capability with the
	/// exception of GL_DITHER and GL_MULTISAMPLE is
	/// GL_FALSE. The initial value for
	/// GL_DITHER and GL_MULTISAMPLE is GL_TRUE.
	/// 
	/// 
	/// 
	/// Both glEnable and glDisable take a single argument, cap,
	/// which can assume one of the following values:
	/// 
	/// 
	/// 
	/// Some of the GL's capabilities are indexed. glEnablei and glDisablei enable and disable
	/// indexed capabilities.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// blend the computed fragment color values with the values in the color
	/// buffers. See glBlendFunc.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled, clip geometry against user-defined half space i.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// apply the currently selected logical operation to the computed fragment
	/// color and color buffer values. See glLogicOp.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// cull polygons based on their winding in window coordinates.
	/// See glCullFace.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// the
	/// -wczcwc
	/// plane equation is ignored by view volume clipping (effectively, there is no near or
	/// far plane clipping).
	/// See glDepthRange.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// do depth comparisons and update the depth buffer. Note that even if
	/// the depth buffer exists and the depth mask is non-zero, the
	/// depth buffer is not updated if the depth test is disabled. See
	/// glDepthFunc and
	/// glDepthRange.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// dither color components or indices before they are written to the
	/// color buffer.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled
	/// and the value of GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING for the
	/// framebuffer attachment corresponding to the destination buffer is GL_SRGB,
	/// the R, G, and B destination color values (after conversion from fixed-point to floating-point)
	/// are considered to be encoded for the sRGB color space and hence are linearized prior to
	/// their use in blending.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// draw lines with correct filtering.
	/// Otherwise,
	/// draw aliased lines.
	/// See glLineWidth.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// use multiple fragment samples in computing the final color of a pixel.
	/// See glSampleCoverage.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled, and if the polygon is rendered in
	/// GL_FILL mode, an offset is added to depth values of a polygon's
	/// fragments before the depth comparison is performed.
	/// See glPolygonOffset.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled, and if the polygon is rendered in
	/// GL_LINE mode, an offset is added to depth values of a polygon's
	/// fragments before the depth comparison is performed.
	/// See glPolygonOffset.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled, an offset is added to depth values of a polygon's fragments
	/// before the depth comparison is performed, if the polygon is rendered in
	/// GL_POINT mode. See glPolygonOffset.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled, draw polygons with proper filtering.
	/// Otherwise, draw aliased polygons. For correct antialiased polygons,
	/// an alpha buffer is needed and the polygons must be sorted front to
	/// back.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Enables primitive restarting. If enabled, any one of the draw commands 
	/// which transfers a set of generic attribute array elements to the GL will restart 
	/// the primitive when the index of the vertex is equal to the primitive restart index.
	/// See glPrimitiveRestartIndex.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// compute a temporary coverage value where each bit is determined by the
	/// alpha value at the corresponding sample location. The temporary coverage
	/// value is then ANDed with the fragment coverage value.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// each sample alpha value is replaced by the maximum representable alpha value.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// the fragment's coverage is ANDed with the temporary coverage value. If
	/// GL_SAMPLE_COVERAGE_INVERT is set to GL_TRUE, invert the coverage
	/// value.
	/// See glSampleCoverage.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled, the active fragment shader is run once for each covered sample, or at
	/// fraction of this rate as determined by the current value of GL_MIN_SAMPLE_SHADING_VALUE.
	/// See glMinSampleShading.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled, the sample coverage mask generated for a fragment during rasterization
	/// will be ANDed with the value of GL_SAMPLE_MASK_VALUE before
	/// shading occurs.
	/// See glSampleMaski.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// discard fragments that are outside the scissor rectangle.
	/// See glScissor.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled,
	/// do stencil testing and update the stencil buffer.
	/// See glStencilFunc and glStencilOp.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled, cubemap textures are sampled such that when linearly sampling from the border
	/// between two adjacent faces, texels from both faces are used to generate the final sample
	/// value. When disabled, texels from only a single face are used to construct the final
	/// sample value.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If enabled
	/// and a vertex or geometry shader is active, then the derived point size is taken from the (potentially clipped) shader builtin
	/// gl_PointSize and clamped to the implementation-dependent point size range.
	void glEnable(GLenum cap);
	/// Ditto
	void glDisable(GLenum cap);
	/// Ditto
	void glEnablei(GLenum cap, GLuint index);
	/// Ditto
	void glDisablei(GLenum cap, GLuint index);
	/// Enable or disable a generic vertex attribute array.
	/// 
	/// glEnableVertexAttribArray enables the
	/// generic vertex attribute array specified by
	/// index.
	/// glDisableVertexAttribArray disables the
	/// generic vertex attribute array specified by
	/// index. By default, all client-side
	/// capabilities are disabled, including all generic vertex
	/// attribute arrays. If enabled, the values in the generic vertex
	/// attribute array will be accessed and used for rendering when
	/// calls are made to vertex array commands such as
	/// glDrawArrays,
	/// glDrawElements,
	/// glDrawRangeElements,
	/// glMultiDrawElements,
	/// or
	/// glMultiDrawArrays.
	__gshared void function(GLuint index) glEnableVertexAttribArray;
	/// Ditto
	__gshared void function(GLuint index) glDisableVertexAttribArray;
	/// Create a new sync object and insert it into the GL command stream.
	/// 
	/// glFenceSync creates a new fence sync object, inserts a fence command into the GL command stream and
	/// associates it with that sync object, and returns a non-zero name corresponding to the sync object.
	/// 
	/// 
	/// 
	/// When the specified condition of the sync object is satisfied by the fence command, the sync object
	/// is signaled by the GL, causing any glWaitSync,
	/// glClientWaitSync commands blocking in sync
	/// to unblock. No other state is affected by glFenceSync or by the execution
	/// of the associated fence command.
	/// 
	/// 
	/// condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. This condition is satisfied by 
	/// completion of the fence command corresponding to the sync object and all preceding commands in the same command stream.
	/// The sync object will not be signaled until all effects from these commands on GL client and server state and the
	/// framebuffer are fully realized. Note that completion of the fence command occurs once the state of the corresponding sync
	/// object has been changed, but commands waiting on that sync object may not be unblocked until after the fence command completes.
	__gshared GLsync function(GLenum condition, GLbitfield flags) glFenceSync;
	/// Block until all GL execution is complete.
	/// 
	/// glFinish does not return until the effects of all previously
	/// called GL commands are complete.
	/// Such effects include all changes to GL state,
	/// all changes to connection state,
	/// and all changes to the frame buffer contents.
	void glFinish();
	/// Force execution of GL commands in finite time.
	/// 
	/// Different GL implementations buffer commands in several different locations,
	/// including network buffers and the graphics accelerator itself.
	/// glFlush empties all of these buffers,
	/// causing all issued commands to be executed as quickly as
	/// they are accepted by the actual rendering engine.
	/// Though this execution may not be completed in any particular
	/// time period,
	/// it does complete in finite time.
	/// 
	/// 
	/// 
	/// Because any GL program might be executed over a network,
	/// or on an accelerator that buffers commands,
	/// all programs should call glFlush whenever they count on having
	/// all of their previously issued commands completed.
	/// For example,
	/// call glFlush before waiting for user input that depends on
	/// the generated image.
	void glFlush();
	/// Indicate modifications to a range of a mapped buffer.
	/// 
	/// glFlushMappedBufferRange indicates that modifications have been made to a range of a mapped buffer.
	/// The buffer must previously have been mapped with the GL_MAP_FLUSH_EXPLICIT flag. offset
	/// and length indicate the modified subrange of the mapping, in basic units. The specified subrange to flush
	/// is relative to the start of the currently mapped range of the buffer. glFlushMappedBufferRange may be called
	/// multiple times to indicate distinct subranges of the mapping which require flushing.
	__gshared GLsync function(GLenum target, GLintptr offset, GLsizeiptr length) glFlushMappedBufferRange;
	/// Attach a renderbuffer as a logical buffer to the currently bound framebuffer object.
	/// 
	/// glFramebufferRenderbuffer attaches a renderbuffer as one of the logical buffers of the
	/// currently bound framebuffer object. renderbuffer is the name of the renderbuffer object
	/// to attach and must be either zero, or the name of an existing renderbuffer object of type renderbuffertarget.
	/// If renderbuffer is not zero and if glFramebufferRenderbuffer is
	/// successful, then the renderbuffer name renderbuffer will be used as the logical buffer
	/// identified by attachment of the framebuffer currently bound to target.
	/// 
	/// 
	/// 
	/// The value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for the specified attachment point is
	/// set to GL_RENDERBUFFER and the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME
	/// is set to renderbuffer. All other state values of the attachment point specified by
	/// attachment are set to their default values. No change is made to the state of the renderbuuffer
	/// object and any previous attachment to the attachment logical buffer of the framebuffer
	/// target is broken.
	/// 
	/// 
	/// 
	/// Calling glFramebufferRenderbuffer with the renderbuffer name zero will detach the image, if any,
	/// identified by attachment, in the framebuffer currently bound to target.
	/// All state values of the attachment point specified by attachment in the object bound to target are set to their default values.
	/// 
	/// 
	/// 
	/// Setting attachment to the value GL_DEPTH_STENCIL_ATTACHMENT is a special
	/// case causing both the depth and stencil attachments of the framebuffer object to be set to renderbuffer,
	/// which should have the base internal format GL_DEPTH_STENCIL.
	__gshared GLsync function(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) glFramebufferRenderbuffer;
	/// Attach a level of a texture object as a logical buffer to the currently bound framebuffer object.
	/// 
	/// glFramebufferTexture, glFramebufferTexture1D, glFramebufferTexture2D,
	/// and glFramebufferTexture attach a selected mipmap level or image of a texture object as one of the
	/// logical buffers of the framebuffer object currently bound to target. target must
	/// be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER.
	/// GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.
	/// 
	/// 
	/// attachment specifies the logical attachment of the framebuffer and must be
	/// GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT,
	/// GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMMENT.
	/// i in GL_COLOR_ATTACHMENTi may range from zero to
	/// the value of GL_MAX_COLOR_ATTACHMENTS - 1. Attaching a level of a texture to
	/// GL_DEPTH_STENCIL_ATTACHMENT is equivalent to attaching that level to both the
	/// GL_DEPTH_ATTACHMENTand the GL_STENCIL_ATTACHMENT
	/// attachment points simultaneously.
	/// 
	/// 
	/// textarget specifies what type of texture is named by texture, and for
	/// cube map textures, specifies the face that is to be attached. If texture is not zero, it
	/// must be the name of an existing texture with type textarget, unless it is a cube map
	/// texture, in which case textarget must be GL_TEXTURE_CUBE_MAP_POSITIVE_XGL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
	/// GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or
	/// GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
	/// 
	/// 
	/// 
	/// If texture is non-zero, the specified level of the texture object named
	/// texture is attached to the framebfufer attachment point named by attachment.
	/// For glFramebufferTexture1D, glFramebufferTexture2D, and
	/// glFramebufferTexture3D, texture must be zero or the name of an existing
	/// texture with a target of textarget, or texture must be the name
	/// of an existing cube-map texture and textarget must be one of GL_TEXTURE_CUBE_MAP_POSITIVE_X,
	/// GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
	/// GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or
	/// GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
	/// 
	/// 
	/// 
	/// If textarget is GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE,
	/// or GL_TEXTURE_2D_MULTISAMPLE_ARRAY, then level must be zero. If textarget
	/// is GL_TEXTURE_3D, then level must be greater than or equal to zero and less than or equal to log2
	/// of the value of GL_MAX_3D_TEXTURE_SIZE. If textarget is one of GL_TEXTURE_CUBE_MAP_POSITIVE_X,
	/// GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
	/// GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, then level must be greater
	/// than or equal to zero and less than or equal to log2 of the value of GL_MAX_CUBE_MAP_TEXTURE_SIZE. For all other
	/// values of textarget, level must be greater than or equal to zero and no larger than log2
	/// of the value of GL_MAX_TEXTURE_SIZE.
	/// 
	/// 
	/// layer specifies the layer of a 2-dimensional image within a 3-dimensional texture.
	/// 
	/// 
	/// 
	/// For glFramebufferTexture1D, if texture is not zero, then textarget must
	/// be GL_TEXTURE_1D. For glFramebufferTexture2D, if texture is not zero,
	/// textarget must be one of GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE,
	/// GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
	/// GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
	/// GL_TEXTURE_2D_MULTISAMPLE. For glFramebufferTexture3D, if texture is
	/// not zero, then textarget must be GL_TEXTURE_3D.
	__gshared void function(GLenum target, GLenum attachment, GLuint texture, GLint level) glFramebufferTexture;
	/// Ditto
	__gshared void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) glFramebufferTexture1D;
	/// Ditto
	__gshared void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) glFramebufferTexture2D;
	/// Ditto
	__gshared void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer) glFramebufferTexture3D;
	/// Attach a single layer of a texture to a framebuffer.
	/// 
	/// glFramebufferTextureLayer operates like glFramebufferTexture,
	/// except that only a single layer of the texture level, given by layer, is attached to the attachment point.
	/// If texture is not zero, layer must be greater than or equal to zero.
	/// texture must either be zero or the name of an existing three-dimensional texture, one- or two-dimensional array texture,
	/// or multisample array texture.
	__gshared void function(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) glFramebufferTextureLayer;
	/// Define front- and back-facing polygons.
	/// 
	/// In a scene composed entirely of opaque closed surfaces,
	/// back-facing polygons are never visible.
	/// Eliminating these invisible polygons has the obvious benefit
	/// of speeding up the rendering of the image.
	/// To enable and disable elimination of back-facing polygons, call glEnable
	/// and glDisable with argument GL_CULL_FACE.
	/// 
	/// 
	/// 
	/// The projection of a polygon to window coordinates is said to have
	/// clockwise winding if an imaginary object following the path
	/// from its first vertex,
	/// its second vertex,
	/// and so on,
	/// to its last vertex,
	/// and finally back to its first vertex,
	/// moves in a clockwise direction about the interior of the polygon.
	/// The polygon's winding is said to be counterclockwise if the imaginary
	/// object following the same path moves in a counterclockwise direction
	/// about the interior of the polygon.
	/// glFrontFace specifies whether polygons with clockwise winding in window coordinates,
	/// or counterclockwise winding in window coordinates,
	/// are taken to be front-facing.
	/// Passing GL_CCW to mode selects counterclockwise polygons as
	/// front-facing;
	/// GL_CW selects clockwise polygons as front-facing.
	/// By default, counterclockwise polygons are taken to be front-facing.
	void glFrontFace(GLenum mode);
	/// Generate buffer object names.
	/// 
	/// glGenBuffers returns n buffer object names in buffers.
	/// There is no guarantee that the names form a contiguous set of integers;
	/// however, it is guaranteed that none of the returned names was in use
	/// immediately before the call to glGenBuffers.
	/// 
	/// 
	/// 
	/// Buffer object names returned by a call to glGenBuffers are not returned by
	/// subsequent calls, unless they are first deleted with
	/// glDeleteBuffers.
	/// 
	/// 
	/// 
	/// No buffer objects are associated with the returned buffer object names until they are first bound by calling
	/// glBindBuffer.
	__gshared void function(GLsizei n, GLuint * buffers) glGenBuffers;
	/// Generate mipmaps for a specified texture target.
	/// 
	/// glGenerateMipmap generates mipmaps for the texture attached
	/// to target of the active texture unit. For cube map textures,
	/// a GL_INVALID_OPERATION error is generated if the texture
	/// attached to target is not cube complete.
	/// 
	/// 
	/// 
	/// Mipmap generation replaces texel array levels
	/// levelbase+1
	/// through
	/// q
	/// with arrays derived from the
	/// levelbase
	/// array, regardless of their previous contents. All other mimap arrays,
	/// including the
	/// levelbase
	/// array, are left unchanged by this computation.
	/// 
	/// 
	/// 
	/// The internal formats of the derived mipmap arrays all match those of the
	/// levelbase
	/// array. The contents of the derived arrays are computed by repeated, filtered
	/// reduction of the
	/// levelbase
	/// array. For one- and two-dimensional texture arrays, each layer is filtered
	/// independently.
	__gshared void function(GLenum target) glGenerateMipmap;
	/// Generate framebuffer object names.
	/// 
	/// glGenFramebuffers returns n framebuffer object names in ids.
	/// There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names
	/// was in use immediately before the call to glGenFramebuffers.
	/// 
	/// 
	/// 
	/// Framebuffer object names returned by a call to glGenFramebuffers are not returned by subsequent calls, unless
	/// they are first deleted with glDeleteFramebuffers.
	/// 
	/// 
	/// 
	/// The names returned in ids are marked as used, for the purposes of glGenFramebuffers only,
	/// but they acquire state and type only when they are first bound.
	__gshared void function(GLsizei n, GLuint* ids) glGenFramebuffers;
	/// Reserve program pipeline object names.
	/// 
	/// glGenProgramPipelines returns n previously unused
	/// program pipeline object names in pipelines. These names are marked as used,
	/// for the purposes of glGenProgramPipelines only, but they
	/// acquire program pipeline state only when they are first bound.
	__gshared void function(GLsizei n, GLuint* pipelines) glGenProgramPipelines;
	/// Generate query object names.
	/// 
	/// glGenQueries returns n query object names in ids.
	/// There is no guarantee that the names form a contiguous set of integers;
	/// however, it is guaranteed that none of the returned names was in use
	/// immediately before the call to glGenQueries.
	/// 
	/// 
	/// 
	/// Query object names returned by a call to glGenQueries are not returned by
	/// subsequent calls, unless they are first deleted with
	/// glDeleteQueries. 
	/// 
	/// 
	/// 
	/// No query objects are associated with the returned query object names until they are first used by calling
	/// glBeginQuery.
	__gshared void function(GLsizei n, GLuint * ids) glGenQueries;
	/// Generate renderbuffer object names.
	/// 
	/// glGenRenderbuffers returns n renderbuffer object names in renderbuffers.
	/// There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names
	/// was in use immediately before the call to glGenRenderbuffers.
	/// 
	/// 
	/// 
	/// Renderbuffer object names returned by a call to glGenRenderbuffers are not returned by subsequent calls, unless
	/// they are first deleted with glDeleteRenderbuffers.
	/// 
	/// 
	/// 
	/// The names returned in renderbuffers are marked as used, for the purposes of glGenRenderbuffers only,
	/// but they acquire state and type only when they are first bound.
	__gshared void function(GLsizei n, GLuint* renderbuffers) glGenRenderbuffers;
	/// Generate sampler object names.
	/// 
	/// glGenSamplers returns n sampler object names in samplers.
	/// There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names
	/// was in use immediately before the call to glGenSamplers.
	/// 
	/// 
	/// 
	/// Sampler object names returned by a call to glGenSamplers are not returned by subsequent calls, unless
	/// they are first deleted with glDeleteSamplers.
	/// 
	/// 
	/// 
	/// The names returned in samplers are marked as used, for the purposes of glGenSamplers only,
	/// but they acquire state and type only when they are first bound.
	__gshared void function(GLsizei n, GLuint* samplers) glGenSamplers;
	/// Generate texture names.
	/// 
	/// glGenTextures returns n texture names in textures.
	/// There is no guarantee that the names form a contiguous set of integers;
	/// however, it is guaranteed that none of the returned names was in use
	/// immediately before the call to glGenTextures.
	/// 
	/// 
	/// 
	/// The generated textures have no dimensionality; they assume the dimensionality
	/// of the texture target to which they are first bound
	/// (see glBindTexture).
	/// 
	/// 
	/// 
	/// Texture names returned by a call to glGenTextures are not returned by
	/// subsequent calls, unless they are first deleted with
	/// glDeleteTextures.
	void glGenTextures(GLsizei n, GLuint * textures);
	/// Reserve transform feedback object names.
	/// 
	/// glGenTransformFeedbacks returns n previously unused
	/// transform feedback object names in ids. These names are marked as used,
	/// for the purposes of glGenTransformFeedbacks only, but they
	/// acquire transform feedback state only when they are first bound.
	__gshared void function(GLsizei n, GLuint* ids) glGenTransformFeedbacks;
	/// Generate vertex array object names.
	/// 
	/// glGenVertexArrays returns n vertex array object names in arrays.
	/// There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names
	/// was in use immediately before the call to glGenVertexArrays.
	/// 
	/// 
	/// 
	/// Vertex array object names returned by a call to glGenVertexArrays are not returned by subsequent calls, unless
	/// they are first deleted with glDeleteVertexArrays.
	/// 
	/// 
	/// 
	/// The names returned in arrays are marked as used, for the purposes of glGenVertexArrays only,
	/// but they acquire state and type only when they are first bound.
	__gshared void function(GLsizei n, GLuint* arrays) glGenVertexArrays;
	/// Return the value or values of a selected parameter.
	/// 
	/// These four commands return values for simple state variables in GL.
	/// pname is a symbolic constant indicating the state variable to be returned,
	/// and params is a pointer to an array of the indicated type in
	/// which to place the returned data.
	/// 
	/// 
	/// 
	/// Type conversion is performed if params has a different type than
	/// the state variable value being requested.
	/// If glGetBooleanv is called,
	/// a floating-point (or integer) value is converted to GL_FALSE if
	/// and only if it is 0.0 (or 0).
	/// Otherwise,
	/// it is converted to GL_TRUE.
	/// If glGetIntegerv is called, boolean values are returned as
	/// GL_TRUE or GL_FALSE, and most floating-point values are
	/// rounded to the nearest integer value. Floating-point colors and
	/// normals, however, are returned with a linear mapping that maps 1.0 to
	/// the most positive representable integer value
	/// and 
	/// -1.0
	/// to the most negative representable integer value.
	/// If glGetFloatv or glGetDoublev is called,
	/// boolean values are returned as GL_TRUE or GL_FALSE,
	/// and integer values are converted to floating-point values.
	/// 
	/// 
	/// 
	/// The following symbolic constants are accepted by pname:
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value indicating the active multitexture unit.
	/// The initial value is GL_TEXTURE0.
	/// See glActiveTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns a pair of values indicating the range of
	/// widths supported for aliased lines. See glLineWidth.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the buffer object
	/// currently bound to the target GL_ARRAY_BUFFER. If no buffer object
	/// is bound to this target, 0 is returned. The initial value is 0.
	/// See glBindBuffer.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether blending is
	/// enabled. The initial value is GL_FALSE.
	/// See glBlendFunc.
	/// 
	/// 
	/// 
	/// 
	/// params returns four values,
	/// the red, green, blue, and alpha values which are the components of
	/// the blend color.
	/// See glBlendColor.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the symbolic constant identifying the alpha destination blend
	/// function. The initial value is GL_ZERO.
	/// See glBlendFunc and glBlendFuncSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the symbolic constant identifying the RGB destination blend
	/// function. The initial value is GL_ZERO.
	/// See glBlendFunc and glBlendFuncSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value, a symbolic constant indicating whether
	/// the RGB blend equation is GL_FUNC_ADD, GL_FUNC_SUBTRACT, 
	/// GL_FUNC_REVERSE_SUBTRACT, GL_MIN or GL_MAX.
	/// See glBlendEquationSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value, a symbolic constant indicating whether
	/// the Alpha blend equation is GL_FUNC_ADD, GL_FUNC_SUBTRACT, 
	/// GL_FUNC_REVERSE_SUBTRACT, GL_MIN or GL_MAX.
	/// See glBlendEquationSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the symbolic constant identifying the alpha source blend function. The initial
	/// value is GL_ONE.
	/// See glBlendFunc and glBlendFuncSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the symbolic constant identifying the RGB source blend function. The initial
	/// value is GL_ONE.
	/// See glBlendFunc and glBlendFuncSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns four values:
	/// the red, green, blue, and alpha values used to clear the color buffers.
	/// Integer values,
	/// if requested,
	/// are linearly mapped from the internal floating-point representation such
	/// that 1.0 returns the most positive representable integer value,
	/// and 
	/// -1.0
	/// returns the most negative representable integer
	/// value. The initial value is (0, 0, 0, 0).
	/// See glClearColor.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether a fragment's
	/// RGBA color values are merged into the framebuffer using a logical
	/// operation. The initial value is GL_FALSE.
	/// See glLogicOp.
	/// 
	/// 
	/// 
	/// 
	/// params returns four boolean values:
	/// the red, green, blue, and alpha write enables for the color
	/// buffers. The initial value is (GL_TRUE, GL_TRUE,
	/// GL_TRUE, GL_TRUE).
	/// See glColorMask.
	/// 
	/// 
	/// 
	/// 
	/// params returns a list of symbolic
	/// constants of length GL_NUM_COMPRESSED_TEXTURE_FORMATS 
	/// indicating which compressed texture formats are available.
	/// See glCompressedTexImage2D.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the flags with which the context was created (such as debugging functionality).
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether polygon culling
	/// is enabled. The initial value is GL_FALSE.
	/// See glCullFace.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the name of the program object that is currently active, or 0 if no program object is active.
	/// See glUseProgram.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the value that is used to clear the depth buffer.
	/// Integer values,
	/// if requested,
	/// are linearly mapped from the internal floating-point representation such
	/// that 1.0 returns the most positive representable integer value,
	/// and 
	/// -1.0
	/// returns the most negative representable integer
	/// value. The initial value is 1.
	/// See glClearDepth.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the symbolic constant that indicates the depth comparison
	/// function. The initial value is GL_LESS.
	/// See glDepthFunc.
	/// 
	/// 
	/// 
	/// 
	/// params returns two values:
	/// the near and far mapping limits for the depth buffer.
	/// Integer values,
	/// if requested,
	/// are linearly mapped from the internal floating-point representation such
	/// that 1.0 returns the most positive representable integer value,
	/// and 
	/// -1.0
	/// returns the most negative representable integer
	/// value. The initial value is (0, 1).
	/// See glDepthRange.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether depth testing
	/// of fragments is enabled. The initial value is GL_FALSE.
	/// See glDepthFunc and glDepthRange.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating if the depth buffer
	/// is enabled for writing. The initial value is GL_TRUE.
	/// See glDepthMask.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether dithering of
	/// fragment colors and indices is enabled. The initial value is GL_TRUE.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether double buffering
	/// is supported.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating which buffers are being drawn to.
	/// See glDrawBuffer. The initial value is GL_BACK if there
	/// are back buffers, otherwise it is GL_FRONT.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating which buffers are being drawn to by the corresponding output color.
	/// See glDrawBuffers. 
	/// The initial value of GL_DRAW_BUFFER0 is GL_BACK if there
	/// are back buffers, otherwise it is GL_FRONT. The
	/// initial values of draw buffers for all other output colors is GL_NONE.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the name of the framebuffer object currently bound to the GL_DRAW_FRAMEBUFFER target.
	/// If the default framebuffer is bound, this value will be zero. The initial value is zero.
	/// See glBindFramebuffer.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the name of the framebuffer object currently bound to the GL_READ_FRAMEBUFFER target.
	/// If the default framebuffer is bound, this value will be zero. The initial value is zero.
	/// See glBindFramebuffer.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the buffer object
	/// currently bound to the target GL_ELEMENT_ARRAY_BUFFER. If no buffer object
	/// is bound to this target, 0 is returned. The initial value is 0.
	/// See glBindBuffer.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating the mode of the derivative accuracy hint 
	/// for fragment shaders. The initial value
	/// is GL_DONT_CARE.
	/// See glHint.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single GLenum value indicating
	/// the implementation's preferred pixel data format.
	/// See glReadPixels.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single GLenum value indicating
	/// the implementation's preferred pixel data type.
	/// See glReadPixels.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether antialiasing of
	/// lines is enabled. The initial value is GL_FALSE.
	/// See glLineWidth.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating the mode of the line antialiasing
	/// hint. The initial value is GL_DONT_CARE.
	/// See glHint.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the line width as specified with glLineWidth. The initial value is
	/// 1.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the implementation dependent specifc vertex of a primitive that is used to select the rendering layer. 
	/// If the value returned is equivalent to GL_PROVOKING_VERTEX, then the vertex 
	/// selection follows the convention specified by
	/// glProvokingVertex.
	/// If the value returned is equivalent to GL_FIRST_VERTEX_CONVENTION, then the 
	/// selection is always taken from the first vertex in the primitive.
	/// If the value returned is equivalent to GL_LAST_VERTEX_CONVENTION, then the 
	/// selection is always taken from the last vertex in the primitive.
	/// If the value returned is equivalent to GL_UNDEFINED_VERTEX, then the 
	/// selection is not guaranteed to be taken from any specific vertex in the primitive.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the width difference between adjacent supported widths for antialiased lines.
	/// See glLineWidth.
	/// 
	/// 
	/// 
	/// 
	/// params returns two values:
	/// the smallest and largest supported widths for antialiased
	/// lines.
	/// See glLineWidth.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating the selected logic operation
	/// mode. The initial value is GL_COPY.
	/// See glLogicOp.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the major version number of the OpenGL API supported by the current context.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a rough estimate of the largest 3D texture that the GL can handle.
	/// The value must be at least 64.
	/// Use GL_PROXY_TEXTURE_3D to determine if a texture is too large.
	/// See glTexImage3D.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value.
	/// The value indicates the maximum number of layers allowed in an array texture, and must be at least 256.
	/// See glTexImage2D.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of application-defined clipping distances. The value must be at least 8.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of samples in a color multisample texture.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the maximum number of atomic counters available to all active shaders.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number of words for fragment shader uniform variables in all uniform
	/// blocks (including default). The value must be at least 1.
	/// See glUniform.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number of words for geometry shader uniform variables in all uniform
	/// blocks (including default). The value must be at least 1.
	/// See glUniform.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value, the maximum supported texture image units that 
	/// can be used to access texture maps from the vertex shader and the fragment processor combined. 
	/// If both the vertex shader and the fragment processing stage access the same texture image
	/// unit, then that counts as using two texture image units against this limit.
	/// The value must be at least 48.
	/// See glActiveTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of uniform blocks per program. The value must be at least 36.
	/// See glUniformBlockBinding.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number of words for vertex shader uniform variables in all uniform
	/// blocks (including default). The value must be at least 1.
	/// See glUniform.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value.
	/// The value gives a rough estimate of the largest cube-map texture that
	/// the GL can handle. The value must be at least 1024.
	/// Use GL_PROXY_TEXTURE_CUBE_MAP
	/// to determine if a texture is too large.
	/// See glTexImage2D.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of samples in a multisample depth or depth-stencil texture.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value, the maximum number
	/// of simultaneous outputs that may be written in a fragment shader.
	/// The value must be at least 8.
	/// See glDrawBuffers.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value, the maximum number
	/// of active draw buffers when using dual-source blending. The value must be at least 1.
	/// See glBlendFunc and 
	/// glBlendFuncSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the recommended maximum number of vertex array indices.
	/// See glDrawRangeElements.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the recommended maximum number of vertex array vertices.
	/// See glDrawRangeElements.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the maximum number of atomic counters available to fragment shaders.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of components of the inputs read by the fragment shader, which must be at least 128.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of individual floating-point, integer, or boolean values that can be held 
	/// in uniform variable storage for a fragment shader. The value must be at least 1024.
	/// See glUniform.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of individual 4-vectors of floating-point, integer, or boolean values
	/// that can be held
	/// in uniform variable storage for a fragment shader. The value is equal to the value of
	/// GL_MAX_FRAGMENT_UNIFORM_COMPONENTS divided by 4 and must be at least 256.
	/// See glUniform.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of uniform blocks per fragment shader. The value must be at least 12.
	/// See glUniformBlockBinding.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the maximum number of atomic counters available to geometry shaders.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of components of inputs read by a geometry shader, which must be at least 64.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of components of outputs written by a geometry shader, which must be at least 128.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value, the maximum supported texture image units that 
	/// can be used to access texture maps from the geometry shader. The value must be at least 16.
	/// See glActiveTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of uniform blocks per geometry shader. The value must be at least 12.
	/// See glUniformBlockBinding.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of individual floating-point, integer, or boolean values that can be held 
	/// in uniform variable storage for a geometry shader. The value must be at least 1024.
	/// See glUniform.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of samples supported in integer format multisample buffers.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the minimum alignment in basic machine units of pointers returned fromglMapBuffer
	/// and glMapBufferRange. This value must be a power of two and must
	/// be at least 64.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum texel offset allowed in a texture lookup, which must be at least 7.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the minimum texel offset allowed in a texture lookup, which must be at most -8.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value.
	/// The value gives a rough estimate of the largest rectangular texture that
	/// the GL can handle. The value must be at least 1024.
	/// Use GL_PROXY_RECTANGLE_TEXTURE
	/// to determine if a texture is too large.
	/// See glTexImage2D.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value.
	/// The value indicates the maximum supported size for renderbuffers.
	/// See glFramebufferRenderbuffer.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of sample mask words.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum glWaitSync timeout interval.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the maximum number of atomic counters available to tessellation control shaders.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the maximum number of atomic counters available to tessellation evaluation shaders.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value.
	/// The value gives the maximum number of texels allowed in the texel array of a texture buffer object.
	/// Value must be at least 65536.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value, the maximum supported texture image units that 
	/// can be used to access texture maps from the fragment shader. 
	/// The value must be at least 16.
	/// See glActiveTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum, absolute value of the texture level-of-detail bias. The
	/// value must be at least 2.0.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value.
	/// The value gives a rough estimate of the largest texture that
	/// the GL can handle. The value must be at least 1024.
	/// Use a proxy texture target such as GL_PROXY_TEXTURE_1D or GL_PROXY_TEXTURE_2D
	/// to determine if a texture is too large.
	/// See glTexImage1D and glTexImage2D.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of uniform buffer binding points on the context, which must be at least 36.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum size in basic machine units of a uniform block, which must be at least 16384.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number components for varying variables, which must be at least 60.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number 4-vectors for varying variables, which is equal to the value of
	/// GL_MAX_VARYING_COMPONENTS and must be at least 15.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of interpolators available for processing varying variables used by
	/// vertex and fragment shaders. This value represents the number of individual floating-point 
	/// values that can be interpolated; varying variables declared as vectors, matrices, and arrays 
	/// will all consume multiple interpolators. The value must be at least 32.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the maximum number of atomic counters available to vertex shaders.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of 4-component generic vertex attributes accessible to a vertex shader. 
	/// The value must be at least 16.
	/// See glVertexAttrib.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value, the maximum supported texture image units that 
	/// can be used to access texture maps from the vertex shader. The value may be at least 16.
	/// See glActiveTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of individual floating-point, integer, or boolean values that can be held 
	/// in uniform variable storage for a vertex shader. The value must be at least 1024.
	/// See glUniform.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of 4-vectors that may be held in uniform variable storage for the vertex
	/// shader. The value of GL_MAX_VERTEX_UNIFORM_VECTORS is equal to the
	/// value of GL_MAX_VERTEX_UNIFORM_COMPONENTS and must be at least
	/// 256.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of components of output written by a vertex shader, which must be at least 64.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the maximum number of uniform blocks per vertex shader. The value must be at least 12.
	/// See glUniformBlockBinding.
	/// 
	/// 
	/// 
	/// 
	/// params returns two values:
	/// the maximum supported width and height of the viewport.
	/// These must be at least as large as the visible dimensions of the display
	/// being rendered to.
	/// See glViewport.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value, the maximum number
	/// of simultaneous viewports that are supported.
	/// The value must be at least 16.
	/// See glViewportIndexed.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the minor version number of the OpenGL API supported by the current context.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single integer value indicating the number of available
	/// compressed texture formats. The minimum value is 4.
	/// See glCompressedTexImage2D.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number of extensions supported by the GL implementation for the current context.
	/// See glGetString.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number of program binary formats supported by the implementation.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number of binary shader formats supported by the implementation. If this value is
	/// greater than zero, then the implementation supports loading binary shaders. If it is
	/// zero, then the loading of binary shaders by the implementation is not supported.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the byte alignment used for writing pixel data to memory. The initial
	/// value is 4.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the image height used for writing pixel data to memory. The initial
	/// value is 0.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether single-bit
	/// pixels being written to memory are written first to the least significant
	/// bit of each unsigned byte. The initial value is GL_FALSE.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the row length used for writing pixel data to memory. The initial value is
	/// 0.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number of pixel images skipped before the first pixel is written
	/// into memory. The initial value is 0.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number of pixel locations skipped before the first pixel is written
	/// into memory. The initial value is 0.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number of rows of pixel locations skipped before the first pixel is written
	/// into memory. The initial value is 0.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether the bytes of
	/// two-byte and four-byte pixel indices and components are swapped before being
	/// written to memory. The initial value is GL_FALSE.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the buffer object
	/// currently bound to the target GL_PIXEL_PACK_BUFFER. If no buffer object
	/// is bound to this target, 0 is returned. The initial value is 0.
	/// See glBindBuffer.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the buffer object
	/// currently bound to the target GL_PIXEL_UNPACK_BUFFER. If no buffer object
	/// is bound to this target, 0 is returned. The initial value is 0.
	/// See glBindBuffer.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the point size threshold for determining the point size.
	/// See glPointParameter.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the current primitive restart index. The initial value is 0.
	/// See glPrimitiveRestartIndex.
	/// 
	/// 
	/// 
	/// 
	/// params an array of GL_NUM_PROGRAM_BINARY_FORMATS values,
	/// indicating the proram binary formats supported by the implementation.
	/// 
	/// 
	/// 
	/// 
	/// params a single value, the name of the currently bound program pipeline
	/// object, or zero if no program pipeline object is bound.
	/// See glBindProgramPipeline.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the currently selected provoking vertex convention. The initial value is GL_LAST_VERTEX_CONVENTION.
	/// See glProvokingVertex.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the point size as specified by glPointSize.
	/// The initial value is 1.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the size difference between adjacent supported sizes for antialiased points.
	/// See glPointSize.
	/// 
	/// 
	/// 
	/// 
	/// params returns two values:
	/// the smallest and largest supported sizes for antialiased
	/// points. The smallest size must be at most 1, and the largest size must
	/// be at least 1.
	/// See glPointSize.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the scaling factor used to determine the variable offset that is added
	/// to the depth value of each fragment generated when a polygon is
	/// rasterized. The initial value is 0.
	/// See glPolygonOffset.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value.
	/// This value is multiplied by an implementation-specific value and then
	/// added to the depth value of each fragment
	/// generated when a polygon is rasterized. The initial value is 0.
	/// See glPolygonOffset.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether polygon offset
	/// is enabled for polygons in fill mode. The initial value is GL_FALSE.
	/// See glPolygonOffset.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether polygon offset
	/// is enabled for polygons in line mode. The initial value is GL_FALSE.
	/// See glPolygonOffset.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether polygon offset
	/// is enabled for polygons in point mode. The initial value is GL_FALSE.
	/// See glPolygonOffset.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether antialiasing of
	/// polygons is enabled. The initial value is GL_FALSE.
	/// See glPolygonMode.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating the mode of the polygon antialiasing
	/// hint. The initial value is GL_DONT_CARE.
	/// See glHint.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating which color buffer is selected for
	/// reading. The initial value is GL_BACK if there is a back buffer,
	/// otherwise it is GL_FRONT.
	/// See
	/// glReadPixels.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the renderbuffer object
	/// currently bound to the target GL_RENDERBUFFER. If no renderbuffer object
	/// is bound to this target, 0 is returned. The initial value is 0.
	/// See glBindRenderbuffer.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single integer value indicating the number of sample buffers
	/// associated with the framebuffer.
	/// See glSampleCoverage.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single positive floating-point value indicating the
	/// current sample coverage value.
	/// See glSampleCoverage.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating if the temporary
	/// coverage value should be inverted.
	/// See glSampleCoverage.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the sampler object
	/// currently bound to the active texture unit. The initial value is 0.
	/// See glBindSampler.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single integer value indicating the coverage mask size.
	/// See glSampleCoverage.
	/// 
	/// 
	/// 
	/// 
	/// params returns four values:
	/// the 
	/// x
	/// and 
	/// y
	/// window coordinates of the scissor box,
	/// followed by its width and height.
	/// Initially the 
	/// x
	/// and 
	/// y
	/// window coordinates are both 0 and the
	/// width and height are set to the size of the window.
	/// See glScissor.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether scissoring is
	/// enabled. The initial value is GL_FALSE.
	/// See glScissor.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether an online shader
	/// compiler is present in the implementation. All desktop OpenGL implementations must support
	/// online shader compilations, and therefore the value of GL_SHADER_COMPILER
	/// will always be GL_TRUE.
	/// 
	/// 
	/// 
	/// 
	/// params returns a pair of values indicating the range of
	/// widths supported for smooth (antialiased) lines. See glLineWidth.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value indicating the level of
	/// quantization applied to smooth line width parameters.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating what action is taken for back-facing polygons when the stencil
	/// test fails. The initial value is GL_KEEP.
	/// See glStencilOpSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating what function is used for back-facing polygons to compare the
	/// stencil reference value with the stencil buffer value. The initial value
	/// is GL_ALWAYS.
	/// See glStencilFuncSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating what action is taken for back-facing polygons when the stencil
	/// test passes,
	/// but the depth test fails. The initial value is GL_KEEP.
	/// See glStencilOpSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating what action is taken for back-facing polygons when the stencil
	/// test passes and the depth test passes. The initial value is GL_KEEP.
	/// See glStencilOpSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the reference value that is compared with the contents of the stencil
	/// buffer for back-facing polygons. The initial value is 0.
	/// See glStencilFuncSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the mask that is used for back-facing polygons to mask both the stencil reference value and the
	/// stencil buffer value before they are compared. The initial value is all 1's.
	/// See glStencilFuncSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the mask that controls writing of the stencil bitplanes for back-facing polygons. The initial value
	/// is all 1's.
	/// See glStencilMaskSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the index to which the stencil bitplanes are cleared. The initial value is
	/// 0.
	/// See glClearStencil.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating what action is taken when the stencil
	/// test fails. The initial value is GL_KEEP.
	/// See glStencilOp.
	/// This stencil state only affects non-polygons
	/// and front-facing polygons. Back-facing polygons use separate stencil state.
	/// See glStencilOpSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating what function is used to compare the
	/// stencil reference value with the stencil buffer value. The initial value
	/// is GL_ALWAYS.
	/// See glStencilFunc.
	/// This stencil state only affects non-polygons
	/// and front-facing polygons. Back-facing polygons use separate stencil state.
	/// See glStencilFuncSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating what action is taken when the stencil
	/// test passes,
	/// but the depth test fails. The initial value is GL_KEEP.
	/// See glStencilOp.
	/// This stencil state only affects non-polygons
	/// and front-facing polygons. Back-facing polygons use separate stencil state.
	/// See glStencilOpSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// a symbolic constant indicating what action is taken when the stencil
	/// test passes and the depth test passes. The initial value is GL_KEEP.
	/// See glStencilOp.
	/// This stencil state only affects non-polygons
	/// and front-facing polygons. Back-facing polygons use separate stencil state.
	/// See glStencilOpSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the reference value that is compared with the contents of the stencil
	/// buffer. The initial value is 0.
	/// See glStencilFunc.
	/// This stencil state only affects non-polygons
	/// and front-facing polygons. Back-facing polygons use separate stencil state.
	/// See glStencilFuncSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether stencil testing
	/// of fragments is enabled. The initial value is GL_FALSE.
	/// See glStencilFunc and glStencilOp.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the mask that is used to mask both the stencil reference value and the
	/// stencil buffer value before they are compared. The initial value is all 1's.
	/// See glStencilFunc.
	/// This stencil state only affects non-polygons
	/// and front-facing polygons. Back-facing polygons use separate stencil state.
	/// See glStencilFuncSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the mask that controls writing of the stencil bitplanes. The initial value
	/// is all 1's.
	/// See glStencilMask.
	/// This stencil state only affects non-polygons
	/// and front-facing polygons. Back-facing polygons use separate stencil state.
	/// See glStencilMaskSeparate.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether stereo buffers
	/// (left and right) are supported.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// an estimate of the number of bits of subpixel resolution that are used to
	/// position rasterized geometry in window coordinates. The value must be at least 4.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the texture
	/// currently bound to the target GL_TEXTURE_1D. The initial value is 0.
	/// See glBindTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the texture
	/// currently bound to the target GL_TEXTURE_1D_ARRAY. The initial value is 0.
	/// See glBindTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the texture
	/// currently bound to the target GL_TEXTURE_2D. The initial value is 0.
	/// See glBindTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the texture
	/// currently bound to the target GL_TEXTURE_2D_ARRAY. The initial value is 0.
	/// See glBindTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the texture
	/// currently bound to the target GL_TEXTURE_2D_MULTISAMPLE. The initial value is 0.
	/// See glBindTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the texture
	/// currently bound to the target GL_TEXTURE_2D_MULTISAMPLE_ARRAY. The initial value is 0.
	/// See glBindTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the texture
	/// currently bound to the target GL_TEXTURE_3D. The initial value is 0.
	/// See glBindTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the texture
	/// currently bound to the target GL_TEXTURE_BUFFER. The initial value is 0.
	/// See glBindTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the texture
	/// currently bound to the target GL_TEXTURE_CUBE_MAP. The initial value is 0.
	/// See glBindTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the texture
	/// currently bound to the target GL_TEXTURE_RECTANGLE. The initial value is 0.
	/// See glBindTexture.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value indicating the mode of the texture
	/// compression hint. The initial value is GL_DONT_CARE.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the name of the texture buffer object
	/// currently bound. The initial value is 0.
	/// See glBindBuffer.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the 64-bit value of the current
	/// GL time.
	/// See glQueryCounter.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// When used with non-indexed variants of glGet (such as glGetIntegerv),
	/// params returns a single value, the name of the buffer object
	/// currently bound to the target GL_TRANSFORM_FEEDBACK_BUFFER. If no buffer object
	/// is bound to this target, 0 is returned.
	/// When used with indexed variants of glGet (such as glGetIntegeri_v),
	/// params returns a single value, the name of the buffer object
	/// bound to the indexed transform feedback attribute stream. The initial value is 0 for all targets.
	/// See glBindBuffer, glBindBufferBase, and
	/// glBindBufferRange.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// When used with indexed variants of glGet (such as glGetInteger64i_v),
	/// params returns a single value, the start offset of the binding range for each
	/// transform feedback attribute stream. The initial value is 0 for all streams.
	/// See glBindBufferRange.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// When used with indexed variants of glGet (such as glGetInteger64i_v),
	/// params returns a single value, the size of the binding range for each
	/// transform feedback attribute stream. The initial value is 0 for all streams.
	/// See glBindBufferRange.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// When used with non-indexed variants of glGet (such as glGetIntegerv),
	/// params returns a single value, the name of the buffer object
	/// currently bound to the target GL_UNIFORM_BUFFER. If no buffer object
	/// is bound to this target, 0 is returned.
	/// When used with indexed variants of glGet (such as glGetIntegeri_v),
	/// params returns a single value, the name of the buffer object
	/// bound to the indexed uniform buffer binding point. The initial value is 0 for all targets.
	/// See glBindBuffer, glBindBufferBase, and
	/// glBindBufferRange.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the minimum required alignment
	/// for uniform buffer sizes and offset. The initial value is 1.
	/// See glUniformBlockBinding.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// When used with indexed variants of glGet (such as glGetInteger64i_v),
	/// params returns a single value, the size of the binding range for each
	/// indexed uniform buffer binding. The initial value is 0 for all bindings.
	/// See glBindBufferRange.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// When used with indexed variants of glGet (such as glGetInteger64i_v),
	/// params returns a single value, the start offset of the binding range for each
	/// indexed uniform buffer binding. The initial value is 0 for all bindings.
	/// See glBindBufferRange.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the byte alignment used for reading pixel data from memory. The initial
	/// value is 4.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the image height used for reading pixel data from memory. The initial
	/// is 0.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether single-bit
	/// pixels being read from memory are read first from the least significant
	/// bit of each unsigned byte. The initial value is GL_FALSE.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the row length used for reading pixel data from memory. The initial value
	/// is 0.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number of pixel images skipped before the first pixel is read
	/// from memory. The initial value is 0.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number of pixel locations skipped before the first pixel is read
	/// from memory. The initial value is 0.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the number of rows of pixel locations skipped before the first pixel is read
	/// from memory. The initial value is 0.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether the bytes of
	/// two-byte and four-byte pixel indices and components are swapped after being
	/// read from memory. The initial value is GL_FALSE.
	/// See glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating whether vertex
	/// program point size mode is enabled. If enabled, and a vertex shader is active, then the
	/// point size is taken from the shader built-in gl_PointSize. If disabled,
	/// and a vertex shader is active, then the point size is taken from the point state as specified
	/// by glPointSize.
	/// The initial value is GL_FALSE.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// When used with non-indexed variants of glGet (such as glGetIntegerv),
	/// params returns four values:
	/// the 
	/// x
	/// and 
	/// y
	/// window coordinates of the viewport, followed by its width and height.
	/// Initially the 
	/// x
	/// and 
	/// y
	/// window coordinates are both set to 0,
	/// and the width and height are set to the width and height of the window into
	/// which the GL will do its rendering.
	/// See glViewport.
	/// 
	/// When used with indexed variants of glGet (such as glGetIntegeri_v),
	/// params returns four values:
	/// the 
	/// x
	/// and 
	/// y
	/// window coordinates of the indexed viewport, followed by its width and height.
	/// Initially the 
	/// x
	/// and 
	/// y
	/// window coordinates are both set to 0,
	/// and the width and height are set to the width and height of the window into
	/// which the GL will do its rendering.
	/// See glViewportIndexedf.
	/// 
	/// 
	/// 
	/// 
	/// params returns two values, the minimum and maximum viewport bounds range.
	/// The minimum range should be at least [-32768, 32767].
	/// 
	/// 
	/// 
	/// 
	/// params returns one value,
	/// the implementation dependent specifc vertex of a primitive that is used to select the viewport index. 
	/// If the value returned is equivalent to GL_PROVOKING_VERTEX, then the vertex 
	/// selection follows the convention specified by
	/// glProvokingVertex.
	/// If the value returned is equivalent to GL_FIRST_VERTEX_CONVENTION, then the 
	/// selection is always taken from the first vertex in the primitive.
	/// If the value returned is equivalent to GL_LAST_VERTEX_CONVENTION, then the 
	/// selection is always taken from the last vertex in the primitive.
	/// If the value returned is equivalent to GL_UNDEFINED_VERTEX, then the 
	/// selection is not guaranteed to be taken from any specific vertex in the primitive.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value, the number of bits of sub-pixel precision which the GL 
	/// uses to interpret the floating point viewport bounds. The minimum value is 0.
	/// 
	/// 
	/// 
	/// Many of the boolean parameters can also be queried more easily using
	/// glIsEnabled.
	void glGetBooleanv(GLenum pname, GLboolean * params);
	/// Ditto
	void glGetDoublev(GLenum pname, GLdouble * params);
	/// Ditto
	void glGetFloatv(GLenum pname, GLfloat * params);
	/// Ditto
	void glGetIntegerv(GLenum pname, GLint * params);
	/// Ditto
	__gshared void function(GLenum pname, GLint64 * params) glGetInteger64v;
	/// Ditto
	__gshared void function(GLenum pname, GLuint index, GLboolean * data) glGetBooleani_v;
	/// Ditto
	__gshared void function(GLenum pname, GLuint index, GLint * data) glGetIntegeri_v;
	/// Ditto
	__gshared void function(GLenum pname, GLuint index, GLint64 * data) glGetInteger64i_v;
	/// Retrieve information about the set of active atomic counter buffers for a program.
	/// 
	/// glGetActiveAtomicCounterBufferiv retrieves information about the set of active
	/// atomic counter buffers for a program object. program is the name of a program
	/// object for which the command glLinkProgram
	/// has been issued in the past. It is not necessary for program to have been linked
	/// successfully. The link may have failed because the number of active atomic counters exceeded the limits.
	/// 
	/// 
	/// bufferIndex specifies the index of an active atomic counter buffer and must be in
	/// the range zero to the value of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS minus one. The value
	/// of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS for program indicates the
	/// number of active atomic counter buffer and can be queried with
	/// glGetProgram.
	/// 
	/// 
	/// 
	/// If no error occurs, the parameter(s) specified by pname are returned in params.
	/// If an error is generated, the contents of params are not modified.
	/// 
	/// 
	/// 
	/// If pname is GL_ATOMIC_COUNTER_BUFFER_BINDING, then the index of the
	/// counter buffer binding point associated with the active atomic counter buffer bufferIndex
	/// for program is returned.
	/// 
	/// 
	/// 
	/// If pname is GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE, then the implementation-dependent
	/// minimum total buffer object size, in baseic machine units, required to hold all active atomic counters in the
	/// atomic counter binding point identified by bufferIndex is returned.
	/// 
	/// 
	/// 
	/// If pname is GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS, then the number of active
	/// atomic counters for the atomic counter buffer identified by bufferIndex is returned.
	/// 
	/// 
	/// 
	/// If pname is GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES,
	/// then a list of the active atomic counter indices for the atomic counter buffer identified by bufferIndex
	/// is returned. The number of elements that will be written into params is the value of
	/// GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS for bufferIndex.
	/// 
	/// 
	/// 
	/// If pname is GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER,
	/// GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER,
	/// GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER,
	/// GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER, or
	/// GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER, then a boolean value indicating
	/// whether the atomic counter buffer identified by bufferIndex is referenced by the vertex,
	/// tessellation control, tessellation evaluation, geometry or fragment processing stages of program,
	/// respectively, is returned.
	__gshared void function(GLuint program, GLuint bufferIndex, GLenum pname, GLint* params) glGetActiveAtomicCounterBufferiv;
	/// Returns information about an active attribute variable for the specified program object.
	/// 
	/// glGetActiveAttrib returns information
	/// about an active attribute variable in the program object
	/// specified by program. The number of
	/// active attributes can be obtained by calling
	/// glGetProgram
	/// with the value GL_ACTIVE_ATTRIBUTES. A
	/// value of 0 for index selects the first
	/// active attribute variable. Permissible values for
	/// index range from 0 to the number of
	/// active attribute variables minus 1.
	/// 
	/// A vertex shader may use either built-in attribute
	/// variables, user-defined attribute variables, or both. Built-in
	/// attribute variables have a prefix of "gl_" and
	/// reference conventional OpenGL vertex attribtes (e.g.,
	/// gl_Vertex,
	/// gl_Normal, etc., see the OpenGL Shading
	/// Language specification for a complete list.) User-defined
	/// attribute variables have arbitrary names and obtain their values
	/// through numbered generic vertex attributes. An attribute
	/// variable (either built-in or user-defined) is considered active
	/// if it is determined during the link operation that it may be
	/// accessed during program execution. Therefore,
	/// program should have previously been the
	/// target of a call to
	/// glLinkProgram,
	/// but it is not necessary for it to have been linked
	/// successfully.
	/// 
	/// The size of the character buffer required to store the
	/// longest attribute variable name in
	/// program can be obtained by calling
	/// glGetProgram
	/// with the value
	/// GL_ACTIVE_ATTRIBUTE_MAX_LENGTH. This value
	/// should be used to allocate a buffer of sufficient size to store
	/// the returned attribute name. The size of this character buffer
	/// is passed in bufSize, and a pointer to
	/// this character buffer is passed in
	/// name.
	/// 
	/// glGetActiveAttrib returns the name of
	/// the attribute variable indicated by
	/// index, storing it in the character buffer
	/// specified by name. The string returned
	/// will be null terminated. The actual number of characters written
	/// into this buffer is returned in length,
	/// and this count does not include the null termination character.
	/// If the length of the returned string is not required, a value of
	/// NULL can be passed in the
	/// length argument.
	/// 
	/// The type argument specifies a
	/// pointer to a variable into which the attribute variable's data type
	/// will be written. The symbolic
	/// constants GL_FLOAT,
	/// GL_FLOAT_VEC2,
	/// GL_FLOAT_VEC3,
	/// GL_FLOAT_VEC4,
	/// GL_FLOAT_MAT2,
	/// GL_FLOAT_MAT3,
	/// GL_FLOAT_MAT4,
	/// GL_FLOAT_MAT2x3,
	/// GL_FLOAT_MAT2x4,
	/// GL_FLOAT_MAT3x2,
	/// GL_FLOAT_MAT3x4,
	/// GL_FLOAT_MAT4x2,
	/// GL_FLOAT_MAT4x3,
	/// GL_INT,
	/// GL_INT_VEC2,
	/// GL_INT_VEC3,
	/// GL_INT_VEC4,
	/// GL_UNSIGNED_INT_VEC,
	/// GL_UNSIGNED_INT_VEC2,
	/// GL_UNSIGNED_INT_VEC3,
	/// GL_UNSIGNED_INT_VEC4,
	/// DOUBLE,
	/// DOUBLE_VEC2,
	/// DOUBLE_VEC3,
	/// DOUBLE_VEC4,
	/// DOUBLE_MAT2,
	/// DOUBLE_MAT3,
	/// DOUBLE_MAT4,
	/// DOUBLE_MAT2x3,
	/// DOUBLE_MAT2x4,
	/// DOUBLE_MAT3x2,
	/// DOUBLE_MAT3x4,
	/// DOUBLE_MAT4x2, or
	/// DOUBLE_MAT4x3
	/// may be returned. The
	/// size argument will return the size of the
	/// attribute, in units of the type returned in
	/// type.
	/// 
	/// The list of active attribute variables may include both
	/// built-in attribute variables (which begin with the prefix
	/// "gl_") as well as user-defined attribute variable
	/// names.
	/// 
	/// This function will return as much information as it can
	/// about the specified active attribute variable. If no information
	/// is available, length will be 0, and
	/// name will be an empty string. This
	/// situation could occur if this function is called after a link
	/// operation that failed. If an error occurs, the return values
	/// length, size,
	/// type, and name
	/// will be unmodified.
	__gshared void function(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name) glGetActiveAttrib;
	/// Query the name of an active shader subroutine.
	/// 
	/// glGetActiveSubroutineName queries the name of an active shader subroutine uniform from the
	/// program object given in program. index specifies the index of
	/// the shader subroutine uniform within the shader stage given by stage, and must between
	/// zero and the value of GL_ACTIVE_SUBROUTINES minus one for the shader stage.
	/// 
	/// 
	/// 
	/// The name of the selected subroutine is returned as a null-terminated string in name. The
	/// actual number of characters written into name, not including the null-terminator, is
	/// is returned in length. If length is NULL,
	/// no length is returned. The maximum number of characters that may be written into name,
	/// including the null-terminator, is given in bufsize.
	__gshared void function(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name) glGetActiveSubroutineName;
	/// Query a property of an active shader subroutine uniform.
	/// 
	/// glGetActiveSubroutineUniform queries a parameter of an active shader subroutine uniform.
	/// program contains the name of the program containing the uniform. shadertype
	/// specifies the stage which which the uniform location, given by index, is valid. index
	/// must be between zero and the value of GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the
	/// shader stage.
	/// 
	/// 
	/// 
	/// If pname is GL_NUM_COMPATIBLE_SUBROUTINES, a single integer indicating the number
	/// of subroutines that can be assigned to the uniform is returned in values.
	/// 
	/// 
	/// 
	/// If pname is GL_COMPATIBLE_SUBROUTINES, an array of integers is returned in
	/// values, with each integer specifying the index of an active subroutine that can be assigned to
	/// the selected subroutine uniform. The number of integers returned is the same as the value returned for
	/// GL_NUM_COMPATIBLE_SUBROUTINES.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_SIZE, a single integer is returned in values.
	/// If the selected subroutine uniform is an array, the declared size of the array is returned; otherwise, one is returned.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_NAME_LENGTH, a single integer specifying the length of
	/// the subroutine uniform name (including the terminating null character) is returned in values.
	__gshared void function(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values) glGetActiveSubroutineUniformiv;
	/// Query the name of an active shader subroutine uniform.
	/// 
	/// glGetActiveSubroutineUniformName retrieves the name of an active shader subroutine uniform.
	/// program contains the name of the program containing the uniform. shadertype
	/// specifies the stage for which which the uniform location, given by index, is valid. index
	/// must be between zero and the value of GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the
	/// shader stage.
	/// 
	/// 
	/// 
	/// The uniform name is returned as a null-terminated string in name. The actual number of characters
	/// written into name, excluding the null terminator is returned in length.
	/// If length is NULL, no length is returned. The maximum number of characters
	/// that may be written into name, including the null terminator, is specified by bufsize.
	/// The length of the longest subroutine uniform name in program and shadertype is given
	/// by the value of GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, which can be queried with
	/// glGetProgramStage.
	__gshared void function(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name) glGetActiveSubroutineUniformName;
	/// Returns information about an active uniform variable for the specified program object.
	/// 
	/// glGetActiveUniform returns
	/// information about an active uniform variable in the program
	/// object specified by program. The number
	/// of active uniform variables can be obtained by calling
	/// glGetProgram
	/// with the value GL_ACTIVE_UNIFORMS. A value
	/// of 0 for index selects the first active
	/// uniform variable. Permissible values for
	/// index range from 0 to the number of
	/// active uniform variables minus 1.
	/// 
	/// Shaders may use either built-in uniform variables,
	/// user-defined uniform variables, or both. Built-in uniform
	/// variables have a prefix of "gl_" and reference
	/// existing OpenGL state or values derived from such state (e.g.,
	/// gl_DepthRangeParameters, see the OpenGL
	/// Shading Language specification for a complete list.)
	/// User-defined uniform variables have arbitrary names and obtain
	/// their values from the application through calls to
	/// glUniform.
	/// A uniform variable (either built-in or user-defined) is
	/// considered active if it is determined during the link operation
	/// that it may be accessed during program execution. Therefore,
	/// program should have previously been the
	/// target of a call to
	/// glLinkProgram,
	/// but it is not necessary for it to have been linked
	/// successfully.
	/// 
	/// The size of the character buffer required to store the
	/// longest uniform variable name in program
	/// can be obtained by calling
	/// glGetProgram
	/// with the value
	/// GL_ACTIVE_UNIFORM_MAX_LENGTH. This value
	/// should be used to allocate a buffer of sufficient size to store
	/// the returned uniform variable name. The size of this character
	/// buffer is passed in bufSize, and a
	/// pointer to this character buffer is passed in
	/// name.
	/// 
	/// glGetActiveUniform returns the name
	/// of the uniform variable indicated by
	/// index, storing it in the character buffer
	/// specified by name. The string returned
	/// will be null terminated. The actual number of characters written
	/// into this buffer is returned in length,
	/// and this count does not include the null termination character.
	/// If the length of the returned string is not required, a value of
	/// NULL can be passed in the
	/// length argument.
	/// 
	/// The type
	/// argument will return a pointer to the uniform variable's data
	/// type. The symbolic constants returned for uniform types are shown in the
	/// table below.
	/// 
	/// Returned Symbolic Contant
	/// 
	/// Shader Uniform Type
	/// GL_FLOATfloatGL_FLOAT_VEC2vec2GL_FLOAT_VEC3vec3GL_FLOAT_VEC4vec4GL_DOUBLEdoubleGL_DOUBLE_VEC2dvec2GL_DOUBLE_VEC3dvec3GL_DOUBLE_VEC4dvec4GL_INTintGL_INT_VEC2ivec2GL_INT_VEC3ivec3GL_INT_VEC4ivec4GL_UNSIGNED_INTunsigned intGL_UNSIGNED_INT_VEC2uvec2GL_UNSIGNED_INT_VEC3uvec3GL_UNSIGNED_INT_VEC4uvec4GL_BOOLboolGL_BOOL_VEC2bvec2GL_BOOL_VEC3bvec3GL_BOOL_VEC4bvec4GL_FLOAT_MAT2mat2GL_FLOAT_MAT3mat3GL_FLOAT_MAT4mat4GL_FLOAT_MAT2x3mat2x3GL_FLOAT_MAT2x4mat2x4GL_FLOAT_MAT3x2mat3x2GL_FLOAT_MAT3x4mat3x4GL_FLOAT_MAT4x2mat4x2GL_FLOAT_MAT4x3mat4x3GL_DOUBLE_MAT2dmat2GL_DOUBLE_MAT3dmat3GL_DOUBLE_MAT4dmat4GL_DOUBLE_MAT2x3dmat2x3GL_DOUBLE_MAT2x4dmat2x4GL_DOUBLE_MAT3x2dmat3x2GL_DOUBLE_MAT3x4dmat3x4GL_DOUBLE_MAT4x2dmat4x2GL_DOUBLE_MAT4x3dmat4x3GL_SAMPLER_1Dsampler1DGL_SAMPLER_2Dsampler2DGL_SAMPLER_3Dsampler3DGL_SAMPLER_CUBEsamplerCubeGL_SAMPLER_1D_SHADOWsampler1DShadowGL_SAMPLER_2D_SHADOWsampler2DShadowGL_SAMPLER_1D_ARRAYsampler1DArrayGL_SAMPLER_2D_ARRAYsampler2DArrayGL_SAMPLER_1D_ARRAY_SHADOWsampler1DArrayShadowGL_SAMPLER_2D_ARRAY_SHADOWsampler2DArrayShadowGL_SAMPLER_2D_MULTISAMPLEsampler2DMSGL_SAMPLER_2D_MULTISAMPLE_ARRAYsampler2DMSArrayGL_SAMPLER_CUBE_SHADOWsamplerCubeShadowGL_SAMPLER_BUFFERsamplerBufferGL_SAMPLER_2D_RECTsampler2DRectGL_SAMPLER_2D_RECT_SHADOWsampler2DRectShadowGL_INT_SAMPLER_1Disampler1DGL_INT_SAMPLER_2Disampler2DGL_INT_SAMPLER_3Disampler3DGL_INT_SAMPLER_CUBEisamplerCubeGL_INT_SAMPLER_1D_ARRAYisampler1DArrayGL_INT_SAMPLER_2D_ARRAYisampler2DArrayGL_INT_SAMPLER_2D_MULTISAMPLEisampler2DMSGL_INT_SAMPLER_2D_MULTISAMPLE_ARRAYisampler2DMSArrayGL_INT_SAMPLER_BUFFERisamplerBufferGL_INT_SAMPLER_2D_RECTisampler2DRectGL_UNSIGNED_INT_SAMPLER_1Dusampler1DGL_UNSIGNED_INT_SAMPLER_2Dusampler2DGL_UNSIGNED_INT_SAMPLER_3Dusampler3DGL_UNSIGNED_INT_SAMPLER_CUBEusamplerCubeGL_UNSIGNED_INT_SAMPLER_1D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLEusampler2DMSGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAYusampler2DMSArrayGL_UNSIGNED_INT_SAMPLER_BUFFERusamplerBufferGL_UNSIGNED_INT_SAMPLER_2D_RECTusampler2DRectGL_IMAGE_1Dimage1DGL_IMAGE_2Dimage2DGL_IMAGE_3Dimage3DGL_IMAGE_2D_RECTimage2DRectGL_IMAGE_CUBEimageCubeGL_IMAGE_BUFFERimageBufferGL_IMAGE_1D_ARRAYimage1DArrayGL_IMAGE_2D_ARRAYimage2DArrayGL_IMAGE_2D_MULTISAMPLEimage2DMSGL_IMAGE_2D_MULTISAMPLE_ARRAYimage2DMSArrayGL_INT_IMAGE_1Diimage1DGL_INT_IMAGE_2Diimage2DGL_INT_IMAGE_3Diimage3DGL_INT_IMAGE_2D_RECTiimage2DRectGL_INT_IMAGE_CUBEiimageCubeGL_INT_IMAGE_BUFFERiimageBufferGL_INT_IMAGE_1D_ARRAYiimage1DArrayGL_INT_IMAGE_2D_ARRAYiimage2DArrayGL_INT_IMAGE_2D_MULTISAMPLEiimage2DMSGL_INT_IMAGE_2D_MULTISAMPLE_ARRAYiimage2DMSArrayGL_UNSIGNED_INT_IMAGE_1Duimage1DGL_UNSIGNED_INT_IMAGE_2Duimage2DGL_UNSIGNED_INT_IMAGE_3Duimage3DGL_UNSIGNED_INT_IMAGE_2D_RECTuimage2DRectGL_UNSIGNED_INT_IMAGE_CUBEuimageCubeGL_UNSIGNED_INT_IMAGE_BUFFERuimageBufferGL_UNSIGNED_INT_IMAGE_1D_ARRAYuimage1DArrayGL_UNSIGNED_INT_IMAGE_2D_ARRAYuimage2DArrayGL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLEuimage2DMSGL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAYuimage2DMSArrayGL_UNSIGNED_INT_ATOMIC_COUNTERatomic_uint
	/// 
	/// If one or more elements of an array are active, the name
	/// of the array is returned in name, the
	/// type is returned in type, and the
	/// size parameter returns the highest array
	/// element index used, plus one, as determined by the compiler
	/// and/or linker. Only one active uniform variable will be reported
	/// for a uniform array.
	/// 
	/// Uniform variables that are declared as structures or
	/// arrays of structures will not be returned directly by this
	/// function. Instead, each of these uniform variables will be
	/// reduced to its fundamental components containing the
	/// "." and "[]" operators such that each of the
	/// names is valid as an argument to
	/// glGetUniformLocation.
	/// Each of these reduced uniform variables is counted as one active
	/// uniform variable and is assigned an index. A valid name cannot
	/// be a structure, an array of structures, or a subcomponent of a
	/// vector or matrix.
	/// 
	/// The size of the uniform variable will be returned in
	/// size. Uniform variables other than arrays
	/// will have a size of 1. Structures and arrays of structures will
	/// be reduced as described earlier, such that each of the names
	/// returned will be a data type in the earlier list. If this
	/// reduction results in an array, the size returned will be as
	/// described for uniform arrays; otherwise, the size returned will
	/// be 1.
	/// 
	/// The list of active uniform variables may include both
	/// built-in uniform variables (which begin with the prefix
	/// "gl_") as well as user-defined uniform variable
	/// names.
	/// 
	/// This function will return as much information as it can
	/// about the specified active uniform variable. If no information
	/// is available, length will be 0, and
	/// name will be an empty string. This
	/// situation could occur if this function is called after a link
	/// operation that failed. If an error occurs, the return values
	/// length, size,
	/// type, and name
	/// will be unmodified.
	__gshared void function(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name) glGetActiveUniform;
	/// Query information about an active uniform block.
	/// 
	/// glGetActiveUniformBlockiv retrieves information about an active uniform block within program.
	/// 
	/// 
	/// program must be the name of a program object for which the command
	/// glLinkProgram must have been called in the past, although it is not required that
	/// glLinkProgram must have succeeded. The link could have failed because the number
	/// of active uniforms exceeded the limit.
	/// 
	/// 
	/// uniformBlockIndex is an active uniform block index of program, and must be less than the value
	/// of GL_ACTIVE_UNIFORM_BLOCKS.
	/// 
	/// 
	/// 
	/// Upon success, the uniform block parameter(s) specified by pname are returned in params. If an error
	/// occurs, nothing will be written to params.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_BLOCK_BINDING, then the index of the uniform buffer binding point
	/// last selected by the uniform block specified by uniformBlockIndex for program is returned. If
	/// no uniform block has been previously specified, zero is returned.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_BLOCK_DATA_SIZE, then the implementation-dependent minimum total buffer
	/// object size, in basic machine units, required to hold all active uniforms in the uniform block identified by uniformBlockIndex
	/// is returned. It is neither guaranteed nor expected that a given implementation will arrange uniform values as tightly packed in a buffer
	/// object. The exception to this is the std140 uniform block layout, which guarantees specific packing behavior and does not
	/// require the application to query for offsets and strides. In this case the minimum size may still be queried, even though it is determined in
	/// advance based only on the uniform block declaration.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_BLOCK_NAME_LENGTH, then the total length (including the nul terminator) of
	/// the name of the uniform block identified by uniformBlockIndex is returned.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS, then the number of active uniforms in the uniform
	/// block identified by uniformBlockIndex is returned.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES, then a list of the active uniform indices
	/// for the uniform block identified by uniformBlockIndex is returned. The number of elements that will be written to
	/// params is the value of GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS for uniformBlockIndex.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER, GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER,
	/// or GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER, then a boolean value indicating whether the uniform block identified by
	/// uniformBlockIndex is referenced by the vertex, geometry, or fragment programming stages of program, respectively, is returned.
	__gshared void function(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params) glGetActiveUniformBlockiv;
	/// Retrieve the name of an active uniform block.
	/// 
	/// glGetActiveUniformBlockName retrieves the name of the active uniform block at uniformBlockIndex
	/// within program.
	/// 
	/// 
	/// program must be the name of a program object for which the command
	/// glLinkProgram must have been called in the past, although it is not required that
	/// glLinkProgram must have succeeded. The link could have failed because the number
	/// of active uniforms exceeded the limit.
	/// 
	/// 
	/// uniformBlockIndex is an active uniform block index of program, and must be less than the value
	/// of GL_ACTIVE_UNIFORM_BLOCKS.
	/// 
	/// 
	/// 
	/// Upon success, the name of the uniform block identified by unifomBlockIndex is returned into
	/// uniformBlockName. The name is nul-terminated. The actual number of characters written into uniformBlockName,
	/// excluding the nul terminator, is returned in length. If length is NULL, no length is returned.
	/// 
	/// 
	/// bufSize contains the maximum number of characters (including the nul terminator) that will be written into
	/// uniformBlockName.
	/// 
	/// 
	/// 
	/// If an error occurs, nothing will be written to uniformBlockName or length.
	__gshared void function(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName) glGetActiveUniformBlockName;
	/// Query the name of an active uniform.
	/// 
	/// glGetActiveUniformName returns the name of the active uniform at uniformIndex within program.
	/// If uniformName is not NULL, up to bufSize characters (including a nul-terminator) will be written into
	/// the array whose address is specified by uniformName. If length is not NULL, the number of characters
	/// that were (or would have been) written into uniformName (not including the nul-terminator) will be placed in the variable whose address
	/// is specified in length. If length is NULL, no length is returned. The length of the longest uniform
	/// name in program is given by the value of GL_ACTIVE_UNIFORM_MAX_LENGTH, which can be queried with
	/// glGetProgram.
	/// 
	/// 
	/// 
	/// If glGetActiveUniformName is not successful, nothing is written to length or uniformName.
	/// 
	/// 
	/// program must be the name of a program for which the command glLinkProgram
	/// has been issued in the past. It is not necessary for program to have been linked successfully. The link could have failed because
	/// the number of active uniforms exceeded the limit.
	/// 
	/// 
	/// uniformIndex must be an active uniform index of the program program, in the range zero to
	/// GL_ACTIVE_UNIFORMS - 1. The value of GL_ACTIVE_UNIFORMS can be queried with
	/// glGetProgram.
	__gshared void function(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName) glGetActiveUniformName;
	/// Returns information about several active uniform variables for the specified program object.
	/// 
	/// glGetActiveUniformsiv queries the value of the parameter named pname
	/// for each of the uniforms within program whose indices are specified in the array of
	/// uniformCount unsigned integers uniformIndices. Upon success,
	/// the value of the parameter for each uniform is written into the corresponding entry in the array whose
	/// address is given in params. If an error is generated, nothing is written into
	/// params.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_TYPE, then an array identifying the types
	/// of uniforms specified by the corresponding array of uniformIndices is returned. The
	/// returned types can be any of the values from the following table:
	/// 
	/// Returned Symbolic Contant
	/// 
	/// Shader Uniform Type
	/// GL_FLOATfloatGL_FLOAT_VEC2vec2GL_FLOAT_VEC3vec3GL_FLOAT_VEC4vec4GL_DOUBLEdoubleGL_DOUBLE_VEC2dvec2GL_DOUBLE_VEC3dvec3GL_DOUBLE_VEC4dvec4GL_INTintGL_INT_VEC2ivec2GL_INT_VEC3ivec3GL_INT_VEC4ivec4GL_UNSIGNED_INTunsigned intGL_UNSIGNED_INT_VEC2uvec2GL_UNSIGNED_INT_VEC3uvec3GL_UNSIGNED_INT_VEC4uvec4GL_BOOLboolGL_BOOL_VEC2bvec2GL_BOOL_VEC3bvec3GL_BOOL_VEC4bvec4GL_FLOAT_MAT2mat2GL_FLOAT_MAT3mat3GL_FLOAT_MAT4mat4GL_FLOAT_MAT2x3mat2x3GL_FLOAT_MAT2x4mat2x4GL_FLOAT_MAT3x2mat3x2GL_FLOAT_MAT3x4mat3x4GL_FLOAT_MAT4x2mat4x2GL_FLOAT_MAT4x3mat4x3GL_DOUBLE_MAT2dmat2GL_DOUBLE_MAT3dmat3GL_DOUBLE_MAT4dmat4GL_DOUBLE_MAT2x3dmat2x3GL_DOUBLE_MAT2x4dmat2x4GL_DOUBLE_MAT3x2dmat3x2GL_DOUBLE_MAT3x4dmat3x4GL_DOUBLE_MAT4x2dmat4x2GL_DOUBLE_MAT4x3dmat4x3GL_SAMPLER_1Dsampler1DGL_SAMPLER_2Dsampler2DGL_SAMPLER_3Dsampler3DGL_SAMPLER_CUBEsamplerCubeGL_SAMPLER_1D_SHADOWsampler1DShadowGL_SAMPLER_2D_SHADOWsampler2DShadowGL_SAMPLER_1D_ARRAYsampler1DArrayGL_SAMPLER_2D_ARRAYsampler2DArrayGL_SAMPLER_1D_ARRAY_SHADOWsampler1DArrayShadowGL_SAMPLER_2D_ARRAY_SHADOWsampler2DArrayShadowGL_SAMPLER_2D_MULTISAMPLEsampler2DMSGL_SAMPLER_2D_MULTISAMPLE_ARRAYsampler2DMSArrayGL_SAMPLER_CUBE_SHADOWsamplerCubeShadowGL_SAMPLER_BUFFERsamplerBufferGL_SAMPLER_2D_RECTsampler2DRectGL_SAMPLER_2D_RECT_SHADOWsampler2DRectShadowGL_INT_SAMPLER_1Disampler1DGL_INT_SAMPLER_2Disampler2DGL_INT_SAMPLER_3Disampler3DGL_INT_SAMPLER_CUBEisamplerCubeGL_INT_SAMPLER_1D_ARRAYisampler1DArrayGL_INT_SAMPLER_2D_ARRAYisampler2DArrayGL_INT_SAMPLER_2D_MULTISAMPLEisampler2DMSGL_INT_SAMPLER_2D_MULTISAMPLE_ARRAYisampler2DMSArrayGL_INT_SAMPLER_BUFFERisamplerBufferGL_INT_SAMPLER_2D_RECTisampler2DRectGL_UNSIGNED_INT_SAMPLER_1Dusampler1DGL_UNSIGNED_INT_SAMPLER_2Dusampler2DGL_UNSIGNED_INT_SAMPLER_3Dusampler3DGL_UNSIGNED_INT_SAMPLER_CUBEusamplerCubeGL_UNSIGNED_INT_SAMPLER_1D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLEusampler2DMSGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAYusampler2DMSArrayGL_UNSIGNED_INT_SAMPLER_BUFFERusamplerBufferGL_UNSIGNED_INT_SAMPLER_2D_RECTusampler2DRect
	/// 
	/// 
	/// If pname is GL_UNIFORM_SIZE, then an array identifying the
	/// size of the uniforms specified by the corresponding array of uniformIndices is
	/// returned. The sizes returned are in units of the type returned by a query of GL_UNIFORM_TYPE.
	/// For active uniforms that are arrays, the size is the number of active elements in the array;
	/// for all other uniforms, the size is one.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_NAME_LENGTH, then an array identifying the
	/// length, including the terminating null character, of the uniform name strings specified by the corresponding
	/// array of uniformIndices is returned.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_BLOCK_INDEX, then an array identifying the
	/// the uniform block index of each of the uniforms specified by the corresponding array of uniformIndices
	/// is returned. The uniform block index of a uniform associated with the default uniform block is -1.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_OFFSET, then an array of uniform buffer
	/// offsets is returned. For uniforms in a named uniform block, the returned value will be its offset, in basic
	/// machine units, relative to the beginning of the uniform block in the buffer object data store.
	/// For atomic counter uniforms, the returned value will be its offset relative to the beginning of its active
	/// atomic counter buffer.
	/// For all other uniforms, -1 will be returned.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_ARRAY_STRIDE, then an array identifying the
	/// stride between elements of each of the uniforms specified by the corresponding array of
	/// uniformIndices is returned.
	/// For uniforms in named uniform blocks and for uniforms declared as atomic counters, the stride is the difference,
	/// in basic machine units, of consecutive elements in an array, or zero for uniforms not declared as an array.
	/// For all other uniforms, a stride of -1 will be returned.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_MATRIX_STRIDE, then an array identifying the stride
	/// between columns of a column-major matrix or rows of a row-major matrix, in basic machine units, of each of the uniforms
	/// specified by the corresponding array of uniformIndices is returned. The matrix stride of a
	/// uniform associated with the default uniform block is -1. Note that this information only makes sense for uniforms
	/// that are matrices. For uniforms that are not matrices, but are declared in a named uniform block, a matrix stride of
	/// zero is returned.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_IS_ROW_MAJOR, then an array identifying whether each
	/// of the uniforms specified by the corresponding array of uniformIndices is a row-major matrix or not is returned. A
	/// value of one indicates a row-major matrix, and a value of zero indicates a column-major matrix, a matrix in the default
	/// uniform block, or a non-matrix.
	/// 
	/// 
	/// 
	/// If pname is GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX, then an array
	/// identifying the active atomic counter buffer index of each of the uniforms specified by the corresponding array
	/// of uniformIndices is returned. For uniforms other than atomic counters, the returned buffer
	/// index is -1. The returned indices may be passed to glGetActiveAtomicCounterBufferiv
	/// to query the properties of the associated buffer, and not necessarily the binding point specified in the uniform declaration.
	__gshared void function(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params) glGetActiveUniformsiv;
	/// Returns the handles of the shader objects attached to a program object.
	/// 
	/// glGetAttachedShaders returns the
	/// names of the shader objects attached to
	/// program. The names of shader objects that
	/// are attached to program will be returned
	/// in shaders. The actual number of shader
	/// names written into shaders is returned in
	/// count. If no shader objects are attached
	/// to program, count
	/// is set to 0. The maximum number of shader names that may be
	/// returned in shaders is specified by
	/// maxCount. 
	/// 
	/// If the number of names actually returned is not required
	/// (for instance, if it has just been obtained by calling
	/// glGetProgram),
	/// a value of NULL may be passed for count. If
	/// no shader objects are attached to
	/// program, a value of 0 will be returned in
	/// count. The actual number of attached
	/// shaders can be obtained by calling
	/// glGetProgram
	/// with the value GL_ATTACHED_SHADERS.
	__gshared void function(GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders) glGetAttachedShaders;
	/// Returns the location of an attribute variable.
	/// 
	/// glGetAttribLocation queries the
	/// previously linked program object specified by
	/// program for the attribute variable
	/// specified by name and returns the index
	/// of the generic vertex attribute that is bound to that attribute
	/// variable. If name is a matrix attribute
	/// variable, the index of the first column of the matrix is
	/// returned. If the named attribute variable is not an active
	/// attribute in the specified program object or if
	/// name starts with the reserved prefix
	/// "gl_", a value of -1 is returned.
	/// 
	/// The association between an attribute variable name and a
	/// generic attribute index can be specified at any time by calling
	/// glBindAttribLocation.
	/// Attribute bindings do not go into effect until
	/// glLinkProgram
	/// is called. After a program object has been linked successfully,
	/// the index values for attribute variables remain fixed until the
	/// next link command occurs. The attribute values can only be
	/// queried after a link if the link was successful.
	/// glGetAttribLocation returns the binding
	/// that actually went into effect the last time
	/// glLinkProgram
	/// was called for the specified program object. Attribute bindings
	/// that have been specified since the last link operation are not
	/// returned by glGetAttribLocation.
	__gshared GLint function(GLuint program, const GLchar* name) glGetAttribLocation;
	/// Return parameters of a buffer object.
	/// 
	/// glGetBufferParameteriv returns in data a selected parameter of the buffer object
	/// specified by target.
	/// 
	/// 
	/// value names a specific buffer object parameter, as follows:
	/// 
	/// 
	/// params returns the access policy set while mapping the buffer object. 
	/// The initial value is GL_READ_WRITE.
	/// 
	/// 
	/// params returns a flag indicating whether the buffer object is currently 
	/// mapped. The initial value is GL_FALSE.
	/// 
	/// 
	/// params returns the size of the buffer object, measured in bytes. 
	/// The initial value is 0.
	/// 
	/// 
	/// params returns the buffer object's usage pattern. The initial value is
	/// GL_STATIC_DRAW.
	__gshared void function(GLenum target, GLenum value, GLint * data) glGetBufferParameteriv;
	/// Return the pointer to a mapped buffer object's data store.
	/// 
	/// glGetBufferPointerv returns pointer information. pname is a symbolic constant
	/// indicating the pointer to be returned, which must be GL_BUFFER_MAP_POINTER, the pointer
	/// to which the buffer object's data store is mapped. If the data store is not currently mapped, NULL is returned.
	/// params is a pointer to a location in which to place the returned pointer value.
	__gshared void function(GLenum target, GLenum pname, GLvoid ** params) glGetBufferPointerv;
	/// Returns a subset of a buffer object's data store.
	/// 
	/// glGetBufferSubData returns some or all of the data from the buffer object currently 
	/// bound to target. Data starting at byte offset offset and
	/// extending for size bytes is copied from the data store to the memory pointed to by
	/// data. An error is thrown if the buffer object is currently mapped, or if
	/// offset and size together define a range beyond the bounds 
	/// of the buffer object's data store.
	__gshared void function(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid * data) glGetBufferSubData;
	/// Return a compressed texture image.
	/// 
	/// glGetCompressedTexImage returns the compressed texture image associated with target and lod
	/// into img. img should be an array of
	/// GL_TEXTURE_COMPRESSED_IMAGE_SIZE bytes.
	/// target specifies whether the desired texture image was one specified by
	/// glTexImage1D (GL_TEXTURE_1D),
	/// glTexImage2D (GL_TEXTURE_2D or any of GL_TEXTURE_CUBE_MAP_*), or
	/// glTexImage3D (GL_TEXTURE_3D).
	/// lod specifies the level-of-detail number of the desired image.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// requested, img is treated as a byte offset into the buffer object's data store.
	/// 
	/// 
	/// 
	/// To minimize errors, first verify that the texture is compressed by calling
	/// glGetTexLevelParameter with argument GL_TEXTURE_COMPRESSED. If
	/// the texture is compressed, then determine the amount of memory required to
	/// store the compressed texture by calling glGetTexLevelParameter with
	/// argument GL_TEXTURE_COMPRESSED_IMAGE_SIZE. Finally, retrieve the
	/// internal format of the texture by calling glGetTexLevelParameter with
	/// argument GL_TEXTURE_INTERNAL_FORMAT.
	/// To store the texture for later use, associate the internal format and size
	/// with the retrieved texture image. These data can be used by the respective
	/// texture or subtexture loading routine used for loading target textures.
	__gshared void function(GLenum target, GLint lod, GLvoid * img) glGetCompressedTexImage;
	/// Return error information.
	/// 
	/// glGetError returns the value of the error flag.
	/// Each detectable error is assigned a numeric code and symbolic name.
	/// When an error occurs,
	/// the error flag is set to the appropriate error code value.
	/// No other errors are recorded until glGetError is called,
	/// the error code is returned,
	/// and the flag is reset to GL_NO_ERROR.
	/// If a call to glGetError returns GL_NO_ERROR,
	/// there has been no detectable error since the last call to glGetError,
	/// or since the GL was initialized.
	/// 
	/// 
	/// 
	/// To allow for distributed implementations,
	/// there may be several error flags.
	/// If any single error flag has recorded an error,
	/// the value of that flag is returned
	/// and that flag is reset to GL_NO_ERROR
	/// when glGetError is called.
	/// If more than one flag has recorded an error,
	/// glGetError returns and clears an arbitrary error flag value.
	/// Thus, glGetError should always be called in a loop,
	/// until it returns GL_NO_ERROR,
	/// if all error flags are to be reset.
	/// 
	/// 
	/// 
	/// Initially, all error flags are set to GL_NO_ERROR.
	/// 
	/// 
	/// 
	/// The following errors are currently defined:
	/// 
	/// 
	/// 
	/// No error has been recorded.
	/// The value of this symbolic constant is guaranteed to be 0.
	/// 
	/// 
	/// 
	/// An unacceptable value is specified for an enumerated argument.
	/// The offending command is ignored
	/// and has no other side effect than to set the error flag.
	/// 
	/// 
	/// 
	/// A numeric argument is out of range.
	/// The offending command is ignored
	/// and has no other side effect than to set the error flag.
	/// 
	/// 
	/// 
	/// The specified operation is not allowed in the current state.
	/// The offending command is ignored
	/// and has no other side effect than to set the error flag.
	/// 
	/// 
	/// 
	/// The framebuffer object is not complete. The offending command
	/// is ignored and has no other side effect than to set the error flag.
	/// 
	/// 
	/// 
	/// There is not enough memory left to execute the command.
	/// The state of the GL is undefined,
	/// except for the state of the error flags,
	/// after this error is recorded.
	/// 
	/// 
	/// 
	/// When an error flag is set,
	/// results of a GL operation are undefined only if GL_OUT_OF_MEMORY
	/// has occurred.
	/// In all other cases,
	/// the command generating the error is ignored and has no effect on the GL state
	/// or frame buffer contents.
	/// If the generating command returns a value, it returns 0.
	/// If glGetError itself generates an error, it returns 0.
	GLenum glGetError();
	/// Query the bindings of color indices to user-defined varying out variables.
	/// 
	/// glGetFragDataIndex returns the index of the fragment color to which the variable name
	/// was bound when the program object program was last linked. If name is not a varying out
	/// variable of program, or if an error occurs, -1 will be returned.
	__gshared GLint function(GLuint program, const char * name) glGetFragDataIndex;
	/// Query the bindings of color numbers to user-defined varying out variables.
	/// 
	/// glGetFragDataLocation retrieves the assigned color number binding for the user-defined
	/// varying out variable name for program program. program
	/// must have previously been linked. name must be a null-terminated string. If name
	/// is not the name of an active user-defined varying out fragment shader variable within program, -1 will
	/// be returned.
	__gshared GLint function(GLuint program, const char * name) glGetFragDataLocation;
	/// Retrieve information about attachments of a bound framebuffer object.
	/// 
	/// glGetFramebufferAttachmentParameter returns information about attachments of a bound framebuffer
	/// object. target specifies the framebuffer binding point and must be GL_DRAW_FRAMEBUFFER,
	/// GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent
	/// to GL_DRAW_FRAMEBUFFER.
	/// 
	/// 
	/// 
	/// If the default framebuffer is bound to target then attachment must be one of
	/// GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, or
	/// GL_BACK_RIGHT, identifying a color buffer, GL_DEPTH, identifying the depth buffer,
	/// or GL_STENCIL, identifying the stencil buffer.
	/// 
	/// 
	/// 
	/// If a framebuffer object is bound, then attachment must be one of GL_COLOR_ATTACHMENTi,
	/// GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT, or GL_DEPTH_STENCIL_ATTACHMENT.
	/// i in GL_COLOR_ATTACHMENTi must be in the range zero to the value of
	/// GL_MAX_COLOR_ATTACHMENTS - 1.
	/// 
	/// 
	/// 
	/// If attachment is GL_DEPTH_STENCIL_ATTACHMENT and different objects are bound
	/// to the depth and stencil attachment points of target the query will fail. If the same object
	/// is bound to both attachment points, information about that object will be returned.
	/// 
	/// 
	/// 
	/// Upon successful return from glGetFramebufferAttachmentParameteriv, if pname is
	/// GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, then params will contain one of GL_NONE,
	/// GL_FRAMEBUFFER_DEFAULT, GL_TEXTURE, or GL_RENDERBUFFER, identifying the type of
	/// object which contains the attached image. Other values accepted for pname depend on the type of object, as described below.
	/// 
	/// 
	/// 
	/// If the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_NONE, no framebuffer is bound to
	/// target. In this case querying pnameGL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME
	/// will return zero, and all other queries will generate an error.
	/// 
	/// 
	/// 
	/// If the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is not GL_NONE, these queries apply to all other
	/// framebuffer types:
	/// 
	/// 
	/// 
	/// If pname is GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE,
	/// GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE, GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE,
	/// GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE,
	/// or GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE, then params will contain the number
	/// of bits in the corresponding red, green, blue, alpha, depth, or stencil component of the specified attachment. Zero is returned
	/// if the requested component is not present in attachment.
	/// 
	/// 
	/// 
	/// If pname is GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE, params will
	/// contain the format of components of the specified attachment, one of GL_FLOAT, GL_INT,
	/// GL_UNSIGNED_INT, GL_SIGNED_NORMALIZED, or GL_UNSIGNED_NORMALIZED
	/// for floating-point, signed integer, unsigned integer, signed normalized fixed-point, or unsigned normalized fixed-point components
	/// respectively. Only color buffers may have integer components.
	/// 
	/// 
	/// 
	/// If pname is GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, param will
	/// contain the encoding of components of the specified attachment, one of GL_LINEAR or GL_SRGB
	/// for linear or sRGB-encoded components, respectively. Only color buffer components may be sRGB-encoded; such components
	/// are treated as described in sections 4.1.7 and 4.1.8. For the default framebuffer, color encoding is determined by the implementation.
	/// For framebuffer objects, components are sRGB-encoded if the internal format of a color attachment is one of the color-renderable SRGB
	/// formats.
	/// 
	/// 
	/// 
	/// If the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_RENDERBUFFER, then:
	/// 
	/// 
	/// 
	/// If pname is GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, params will contain
	/// the name of the renderbuffer object which contains the attached image.
	/// 
	/// 
	/// 
	/// If the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_TEXTURE, then:
	/// 
	/// 
	/// 
	/// If pname is GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, then params will
	/// contain the name of the texture object which contains the attached image.
	/// 
	/// 
	/// 
	/// If pname is GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, then params
	/// will contain the mipmap level of the texture object which contains the attached image.
	/// 
	/// 
	/// 
	/// If pname is GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE and the texture object named
	/// GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is a cube map texture, then params will contain the cube map
	/// face of the cubemap texture object which contains the attached image. Otherwise params will contain the value
	/// zero.
	/// 
	/// 
	/// 
	/// If pname is GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER and the texture object named
	/// GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is a layer of a three-dimensional texture or a one-or two-dimensional
	/// array texture, then params will contain the number of the texture layer which contains the attached image.
	/// Otherwise params will contain the value zero.
	/// 
	/// 
	/// 
	/// If pname is GL_FRAMEBUFFER_ATTACHMENT_LAYERED, then params will
	/// contain GL_TRUE if an entire level of a three-dimesional texture, cube map texture, or one-or two-dimensional
	/// array texture is attached. Otherwise, params will contain GL_FALSE.
	/// 
	/// 
	/// 
	/// Any combinations of framebuffer type and pname not described above will generate an error.
	__gshared void function(GLenum target, GLenum attachment, GLenum pname, GLint* params) glGetFramebufferAttachmentParameter;
	/// Retrieve information about implementation-dependent support for internal formats.
	/// 
	/// glGetInternalFormativ retrieves information about implementation-dependent support for
	/// internal formats. target indicates the target with which the internal format will
	/// be used and must be one of GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE,
	/// or GL_TEXTURE_2D_MULTISAMPLE_ARRAY, corresponding to usage as a renderbuffer, two-dimensional
	/// multisample texture or two-dimensional multisample array texture, respectively.
	/// 
	/// 
	/// internalformat specifies the internal format about which to retrieve information and
	/// must be a color-renderable, depth-renderable or stencil-renderable format.
	/// 
	/// 
	/// 
	/// The information retrieved will be written to memory addressed by the pointer specified in params. No
	/// more than bufSize basic machine units will be written to this memory.
	/// 
	/// 
	/// 
	/// If pname is GL_NUM_SAMPLE_COUNTS, the number of sample counts that would be
	/// returned by querying GL_SAMPLES will be returned in params.
	/// 
	/// 
	/// 
	/// If pname is GL_SAMPLES, the sample counts supported for internalformat
	/// and target are written into params in descending numeric order. Only positive values are returned.
	/// Querying GL_SAMPLES with bufSize of one will return just the maximum supported number of
	/// samples for this format. The maximum value in GL_SAMPLES is guaranteed to be at least the lowest of the following:
	/// The value of GL_MAX_INTEGER_SAMPLES if internalformat is a signed or unsigned integer format.The value of GL_MAX_DEPTH_TEXTURE_SAMPLES if internalformat is a depth- or stencil-renderable format and
	/// target is GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY.The value of GL_MAX_COLOR_TEXTURE_SAMPLES if internalformat is a color-renderable format and
	/// target is GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.The value of GL_MAX_SAMPLES.
	__gshared void function(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params) glGetInternalFormativ;
	/// Retrieve the location of a sample.
	/// 
	/// glGetMultisamplefv queries the location of a given sample. pname
	/// specifies the sample parameter to retrieve and must be GL_SAMPLE_POSITION. index
	/// corresponds to the sample for which the location should be returned. The sample location is returned as two floating-point
	/// values in val[0] and val[1], each between 0 and 1, corresponding to the x
	/// and y locations respectively in the GL pixel space of that sample. (0.5, 0.5) this corresponds to the
	/// pixel center. index must be between zero and the value of GL_SAMPLES - 1.
	/// 
	/// 
	/// 
	/// If the multisample mode does not have fixed sample locations, the returned values may only reflect the locations of samples
	/// within some pixels.
	__gshared void function(GLenum pname, GLuint index, GLfloat* val) glGetMultisamplefv;
	/// Returns a parameter from a program object.
	/// 
	/// glGetProgram
	/// returns in params
	/// the value of a parameter for a specific program object. The following parameters are defined:
	/// 
	/// 
	/// 
	/// params returns
	/// GL_TRUE if
	/// program is currently flagged
	/// for deletion, and GL_FALSE
	/// otherwise.
	/// 
	/// 
	/// 
	/// params returns
	/// GL_TRUE if the last link
	/// operation on program was
	/// successful, and GL_FALSE
	/// otherwise.
	/// 
	/// 
	/// 
	/// params returns
	/// GL_TRUE or if the last
	/// validation operation on
	/// program was successful, and
	/// GL_FALSE
	/// otherwise.
	/// 
	/// 
	/// 
	/// params returns the
	/// number of characters in the information log for
	/// program including the null
	/// termination character (i.e., the size of the
	/// character buffer required to store the information
	/// log). If program has no
	/// information log, a value of 0 is
	/// returned.
	/// 
	/// 
	/// 
	/// params returns the
	/// number of shader objects attached to
	/// program.
	/// 
	/// 
	/// 
	/// params returns the
	/// number of active attribute atomic counter buffers used by
	/// program.
	/// 
	/// 
	/// 
	/// params returns the
	/// number of active attribute variables for
	/// program.
	/// 
	/// 
	/// 
	/// params returns the
	/// length of the longest active attribute name for
	/// program, including the null
	/// termination character (i.e., the size of the
	/// character buffer required to store the longest
	/// attribute name). If no active attributes exist, 0 is
	/// returned.
	/// 
	/// 
	/// 
	/// params returns the
	/// number of active uniform variables for
	/// program.
	/// 
	/// 
	/// 
	/// params returns the
	/// length of the longest active uniform variable name
	/// for program, including the
	/// null termination character (i.e., the size of the
	/// character buffer required to store the longest
	/// uniform variable name). If no active uniform
	/// variables exist, 0 is returned.
	/// 
	/// 
	/// 
	/// params returns the
	/// length of the program binary, in bytes that will be returned by
	/// a call to glGetProgramBinary.
	/// When a progam's GL_LINK_STATUS is GL_FALSE,
	/// its program binary length is zero.
	/// 
	/// 
	/// 
	/// 
	/// params returns a symbolic constant
	/// indicating the buffer mode used when transform feedback is active.
	/// This may be GL_SEPARATE_ATTRIBS or
	/// GL_INTERLEAVED_ATTRIBS.
	/// 
	/// 
	/// 
	/// params returns the number of varying
	/// variables to capture in transform feedback mode for the program.
	/// 
	/// 
	/// 
	/// params returns the length of the longest
	/// variable name to be used for transform feedback, including the null-terminator.
	/// 
	/// 
	/// 
	/// params returns the maximum number of vertices
	/// that the geometry shader in program will output.
	/// 
	/// 
	/// 
	/// params returns a symbolic constant indicating
	/// the primitive type accepted as input to the geometry shader contained in
	/// program.
	/// 
	/// 
	/// 
	/// params returns a symbolic constant indicating
	/// the primitive type that will be output by the geometry shader contained
	/// in program.
	__gshared void function(GLuint program, GLenum pname, GLint* params) glGetProgramiv;
	/// Return a binary representation of a program object's compiled and linked executable source.
	/// 
	/// glGetProgramBinary returns a binary representation of the compiled
	/// and linked executable for program into the array of bytes whose
	/// address is specified in binary. The maximum number of bytes that
	/// may be written into binary is specified by bufSize.
	/// If the program binary is greater in size than bufSize bytes,
	/// then an error is generated, otherwise the actual number of bytes written into binary
	/// is returned in the variable whose address is given by length. If
	/// length is NULL, then no length is returned.
	/// 
	/// 
	/// 
	/// The format of the program binary written into binary is returned in
	/// the variable whose address is given by binaryFormat, and may be implementation dependent. The binary produced
	/// by the GL may subsequently be returned to the GL by calling glProgramBinary,
	/// with binaryFormat and length set to the values
	/// returned by glGetProgramBinary, and passing the returned binary data
	/// in the binary parameter.
	__gshared void function(GLuint program, GLsizei bufsize, GLsizei* length, GLenum* binaryFormat, void* binary) glGetProgramBinary;
	/// Returns the information log for a program object.
	/// 
	/// glGetProgramInfoLog returns the
	/// information log for the specified program object. The
	/// information log for a program object is modified when the
	/// program object is linked or validated. The string that is
	/// returned will be null terminated.
	/// 
	/// glGetProgramInfoLog returns in
	/// infoLog as much of the information log as
	/// it can, up to a maximum of maxLength
	/// characters. The number of characters actually returned,
	/// excluding the null termination character, is specified by
	/// length. If the length of the returned
	/// string is not required, a value of NULL can
	/// be passed in the length argument. The
	/// size of the buffer required to store the returned information
	/// log can be obtained by calling
	/// glGetProgram
	/// with the value GL_INFO_LOG_LENGTH. 
	/// 
	/// The information log for a program object is either an
	/// empty string, or a string containing information about the last
	/// link operation, or a string containing information about the
	/// last validation operation. It may contain diagnostic messages,
	/// warning messages, and other information. When a program object
	/// is created, its information log will be a string of length
	/// 0.
	__gshared void function(GLuint program, GLsizei maxLength, GLsizei* length, GLchar* infoLog) glGetProgramInfoLog;
	/// Retrieve properties of a program pipeline object.
	/// 
	/// glGetProgramPipelineiv retrieves the value of a property of the program
	/// pipeline object pipeline. pname specifies the
	/// name of the parameter whose value to retrieve. The value of the parameter is written to
	/// the variable whose address is given by params.
	/// 
	/// 
	/// 
	/// If pname is GL_ACTIVE_PROGRAM, the name of the
	/// active program object of the program pipeline object is returned in params.
	/// 
	/// 
	/// 
	/// If pname is GL_VERTEX_SHADER, the name of the
	/// current program object for the vertex shader type of the program pipeline object is
	/// returned in params.
	/// 
	/// 
	/// 
	/// If pname is GL_TESS_CONTROL_SHADER, the name of the
	/// current program object for the tessellation control shader type of the program pipeline object is
	/// returned in params.
	/// 
	/// 
	/// 
	/// If pname is GL_TESS_EVALUATION_SHADER, the name of the
	/// current program object for the tessellation evaluation shader type of the program pipeline object is
	/// returned in params.
	/// 
	/// 
	/// 
	/// If pname is GL_GEOMETRY_SHADER, the name of the
	/// current program object for the geometry shader type of the program pipeline object is
	/// returned in params.
	/// 
	/// 
	/// 
	/// If pname is GL_FRAGMENT_SHADER, the name of the
	/// current program object for the fragment shader type of the program pipeline object is
	/// returned in params.
	/// 
	/// 
	/// 
	/// If pname is GL_INFO_LOG_LENGTH, the length of the
	/// info log, including the null terminator, is returned in params. If there
	/// is no info log, zero is returned.
	__gshared void function(GLuint pipeline, GLenum pname, GLint* params) glGetProgramPipelineiv;
	/// Retrieve the info log string from a program pipeline object.
	/// 
	/// glGetProgramPipelineInfoLog retrieves the info log for the program
	/// pipeline object pipeline. The info log, including its null terminator,
	/// is written into the array of characters whose address is given by infoLog.
	/// The maximum number of characters that may be written into infoLog
	/// is given by bufSize, and the actual number of characters written
	/// into infoLog is returned in the integer whose address is given
	/// by length. If length is NULL,
	/// no length is returned.
	/// 
	/// 
	/// 
	/// The actual length of the info log for the program pipeline may be determined by calling
	/// glGetProgramPipeline with
	/// pname set to GL_INFO_LOG_LENGTH.
	__gshared void function(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog) glGetProgramPipelineInfoLog;
	/// Retrieve properties of a program object corresponding to a specified shader stage.
	/// 
	/// glGetProgramStage queries a parameter of a shader stage attached to a program object.
	/// program contains the name of the program to which the shader is attached. shadertype
	/// specifies the stage from which to query the parameter. pname specifies which parameter
	/// should be queried. The value or values of the parameter to be queried is returned in the variable whose address
	/// is given in values.
	/// 
	/// 
	/// 
	/// If pname is GL_ACTIVE_SUBROUTINE_UNIFORMS, the number
	/// of active subroutine variables in the stage is returned in values.
	/// 
	/// 
	/// 
	/// If pname is GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS,
	/// the number of active subroutine variable locations in the stage is returned in values.
	/// 
	/// 
	/// 
	/// If pname is GL_ACTIVE_SUBROUTINES,
	/// the number of active subroutines in the stage is returned in values.
	/// 
	/// 
	/// 
	/// If pname is GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH,
	/// the length of the longest subroutine uniform for the stage is returned in values.
	/// 
	/// 
	/// 
	/// If pname is GL_ACTIVE_SUBROUTINE_MAX_LENGTH,
	/// the length of the longest subroutine name for the stage is returned in values. The
	/// returned name length includes space for the null-terminator.
	/// 
	/// 
	/// 
	/// If there is no shader present of type shadertype, the returned value will be consistent
	/// with a shader containing no subroutines or subroutine uniforms.
	__gshared void function(GLuint program, GLenum shadertype, GLenum pname, GLint* values) glGetProgramStageiv;
	/// Return parameters of an indexed query object target.
	/// 
	/// glGetQueryIndexediv returns in params a selected parameter of the indexed query object target
	/// specified by target and index. index specifies the index of the
	/// query object target and must be between zero and a target-specific maxiumum.
	/// 
	/// 
	/// pname names a specific query object target parameter. When pname is
	/// GL_CURRENT_QUERY, the name of the currently active query for the specified index of target,
	/// or zero if no query is active, will be placed in params.
	/// If pname is GL_QUERY_COUNTER_BITS, the implementation-dependent number
	/// of bits used to hold the result of queries for target is returned in params.
	__gshared void function(GLenum target, GLuint index, GLenum pname, GLint * params) glGetQueryIndexediv;
	/// Return parameters of a query object target.
	/// 
	/// glGetQueryiv returns in params a selected parameter of the query object target
	/// specified by target.
	/// 
	/// 
	/// pname names a specific query object target parameter. When pname is
	/// GL_CURRENT_QUERY, the name of the currently active query for target,
	/// or zero if no query is active, will be placed in params.
	/// If pname is GL_QUERY_COUNTER_BITS, the implementation-dependent number
	/// of bits used to hold the result of queries for target is returned in params.
	__gshared void function(GLenum target, GLenum pname, GLint * params) glGetQueryiv;
	/// Return parameters of a query object.
	/// 
	/// glGetQueryObject returns in params a selected parameter of the query object
	/// specified by id.
	/// 
	/// 
	/// pname names a specific query object parameter. pname can be as follows:
	/// 
	/// 
	/// params returns the value of the query object's passed samples counter. 
	/// The initial value is 0.
	/// 
	/// 
	/// params returns whether the passed samples counter is immediately available.
	/// If a delay would occur waiting for the query result, GL_FALSE is returned. 
	/// Otherwise, GL_TRUE is returned, which also indicates that the results of all
	/// previous queries are available as well.
	__gshared void function(GLuint id, GLenum pname, GLint * params) glGetQueryObjectiv;
	/// Ditto
	__gshared void function(GLuint id, GLenum pname, GLuint * params) glGetQueryObjectuiv;
	/// Ditto
	__gshared void function(GLuint id, GLenum pname, GLint64 * params) glGetQueryObjecti64v;
	/// Ditto
	__gshared void function(GLuint id, GLenum pname, GLint64 * params) glGetQueryObjectui64v;
	/// Retrieve information about a bound renderbuffer object.
	/// 
	/// glGetRenderbufferParameteriv retrieves information about a bound renderbuffer object. target
	/// specifies the target of the query operation and must be GL_RENDERBUFFER. pname specifies
	/// the parameter whose value to query and must be one of GL_RENDERBUFFER_WIDTH, GL_RENDERBUFFER_HEIGHT,
	/// GL_RENDERBUFFER_INTERNAL_FORMAT, GL_RENDERBUFFER_RED_SIZE, GL_RENDERBUFFER_GREEN_SIZE,
	/// GL_RENDERBUFFER_BLUE_SIZE, GL_RENDERBUFFER_ALPHA_SIZE, GL_RENDERBUFFER_DEPTH_SIZE,
	/// GL_RENDERBUFFER_DEPTH_SIZE, GL_RENDERBUFFER_STENCIL_SIZE, or GL_RENDERBUFFER_SAMPLES.
	/// 
	/// 
	/// 
	/// Upon a successful return from glGetRenderbufferParameteriv, if pname is GL_RENDERBUFFER_WIDTH,
	/// GL_RENDERBUFFER_HEIGHT, GL_RENDERBUFFER_INTERNAL_FORMAT, or GL_RENDERBUFFER_SAMPLES,
	/// then params will contain the width in pixels, the height in pixels, the internal format, or the number of samples, respectively,
	/// of the image of the renderbuffer currently bound to target.
	/// 
	/// 
	/// 
	/// If pname is GL_RENDERBUFFER_RED_SIZE, GL_RENDERBUFFER_GREEN_SIZE,
	/// GL_RENDERBUFFER_BLUE_SIZE, GL_RENDERBUFFER_ALPHA_SIZE, GL_RENDERBUFFER_DEPTH_SIZE,
	/// or GL_RENDERBUFFER_STENCIL_SIZE, then params will contain the actual resolutions (not the resolutions
	/// specified when the image array was defined) for the red, green, blue, alpha depth, or stencil components, respectively, of the image of the
	/// renderbuffer currently bound to target.
	__gshared void function(GLenum target, GLenum pname, GLint* params) glGetRenderbufferParameteriv;
	/// Return sampler parameter values.
	/// 
	/// glGetSamplerParameter returns in params the value or values of the sampler parameter
	/// specified as pname.
	/// sampler defines the target sampler, and must be the name of an existing sampler object, returned from a previous call
	/// to glGenSamplers.
	/// pname accepts the same symbols as glSamplerParameter,
	/// with the same interpretations:
	/// 
	/// 
	/// 
	/// Returns the single-valued texture magnification filter,
	/// a symbolic constant. The initial value is GL_LINEAR.
	/// 
	/// 
	/// 
	/// Returns the single-valued texture minification filter,
	/// a symbolic constant. The initial value is GL_NEAREST_MIPMAP_LINEAR.
	/// 
	/// 
	/// 
	/// Returns the single-valued texture minimum level-of-detail value. The
	/// initial value is 
	/// -1000.
	/// 
	/// 
	/// 
	/// Returns the single-valued texture maximum level-of-detail value. The
	/// initial value is 1000.
	/// 
	/// 
	/// 
	/// Returns the single-valued wrapping function for texture coordinate 
	/// s,
	/// a symbolic constant. The initial value is GL_REPEAT.
	/// 
	/// 
	/// 
	/// Returns the single-valued wrapping function for texture coordinate 
	/// t,
	/// a symbolic constant. The initial value is GL_REPEAT.
	/// 
	/// 
	/// 
	/// Returns the single-valued wrapping function for texture coordinate 
	/// r,
	/// a symbolic constant. The initial value is GL_REPEAT.
	/// 
	/// 
	/// 
	/// Returns four integer or floating-point numbers that comprise the RGBA color
	/// of the texture border.
	/// Floating-point values are returned in the range 
	/// 01.
	/// Integer values are returned as a linear mapping of the internal floating-point
	/// representation such that 1.0 maps to the most positive representable
	/// integer and 
	/// -1.0
	/// maps to the most negative representable
	/// integer. The initial value is (0, 0, 0, 0).
	/// 
	/// 
	/// 
	/// Returns a single-valued texture comparison mode, a symbolic constant. The
	/// initial value is GL_NONE. See glSamplerParameter.
	/// 
	/// 
	/// 
	/// Returns a single-valued texture comparison function, a symbolic constant. The
	/// initial value is GL_LEQUAL. See glSamplerParameter.
	__gshared void function(GLuint sampler, GLenum pname, GLfloat * params) glGetSamplerParameterfv;
	/// Ditto
	__gshared void function(GLuint sampler, GLenum pname, GLint * params) glGetSamplerParameteriv;
	/// Returns a parameter from a shader object.
	/// 
	/// glGetShader
	/// returns in params
	/// the value of a parameter for a specific shader object. The
	/// following parameters are defined:
	/// 
	/// params returns
	/// GL_VERTEX_SHADER if
	/// shader is a vertex shader
	/// object, GL_GEOMETRY_SHADER if shader
	/// is a geometry shader object, and GL_FRAGMENT_SHADER
	/// if shader is a fragment
	/// shader object.
	/// 
	/// params returns
	/// GL_TRUE if
	/// shader is currently flagged
	/// for deletion, and GL_FALSE
	/// otherwise.
	/// 
	/// params returns
	/// GL_TRUE if the last compile
	/// operation on shader was
	/// successful, and GL_FALSE
	/// otherwise.
	/// 
	/// params returns the
	/// number of characters in the information log for
	/// shader including the null
	/// termination character (i.e., the size of the
	/// character buffer required to store the information
	/// log). If shader has no
	/// information log, a value of 0 is returned.
	/// 
	/// params returns the
	/// length of the concatenation of the source strings
	/// that make up the shader source for the
	/// shader, including the null
	/// termination character. (i.e., the size of the
	/// character buffer required to store the shader
	/// source). If no source code exists, 0 is
	/// returned.
	__gshared void function(GLuint shader, GLenum pname, GLint* params) glGetShaderiv;
	/// Returns the information log for a shader object.
	/// 
	/// glGetShaderInfoLog returns the
	/// information log for the specified shader object. The information
	/// log for a shader object is modified when the shader is compiled.
	/// The string that is returned will be null terminated.
	/// 
	/// glGetShaderInfoLog returns in
	/// infoLog as much of the information log as
	/// it can, up to a maximum of maxLength
	/// characters. The number of characters actually returned,
	/// excluding the null termination character, is specified by
	/// length. If the length of the returned
	/// string is not required, a value of NULL can
	/// be passed in the length argument. The
	/// size of the buffer required to store the returned information
	/// log can be obtained by calling
	/// glGetShader
	/// with the value GL_INFO_LOG_LENGTH.
	/// 
	/// The information log for a shader object is a string that
	/// may contain diagnostic messages, warning messages, and other
	/// information about the last compile operation. When a shader
	/// object is created, its information log will be a string of
	/// length 0.
	__gshared void function(GLuint shader, GLsizei maxLength, GLsizei* length, GLchar* infoLog) glGetShaderInfoLog;
	/// Retrieve the range and precision for numeric formats supported by the shader compiler.
	/// 
	/// glGetShaderPrecisionFormat retrieves the numeric range and precision for
	/// the implementation's representation of quantities in different numeric formats in specified
	/// shader type. shaderType specifies the type of shader for which the numeric
	/// precision and range is to be retrieved and must be one of GL_VERTEX_SHADER
	/// or GL_FRAGMENT_SHADER. precisionType specifies the
	/// numeric format to query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOATGL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT,
	/// or GL_HIGH_INT.
	/// 
	/// 
	/// range points to an array of two integers into which the format's numeric range
	/// will be returned. If min and max are the smallest values representable in the format, then the values
	/// returned are defined to be: range[0] = floor(log2(|min|)) and
	/// range[1] = floor(log2(|max|)).
	/// 
	/// 
	/// precision specifies the address of an integer into which will be written
	/// the log2 value of the number of bits of precision of the format. If the smallest representable
	/// value greater than 1 is 1 + eps, then the integer addressed by precision
	/// will contain floor(-log2(eps)).
	__gshared void function(GLenum shaderType, GLenum precisionType, GLint* range, GLint* precision) glGetShaderPrecisionFormat;
	/// Returns the source code string from a shader object.
	/// 
	/// glGetShaderSource returns the
	/// concatenation of the source code strings from the shader object
	/// specified by shader. The source code
	/// strings for a shader object are the result of a previous call to
	/// glShaderSource.
	/// The string returned by the function will be null
	/// terminated.
	/// 
	/// glGetShaderSource returns in
	/// source as much of the source code string
	/// as it can, up to a maximum of bufSize
	/// characters. The number of characters actually returned,
	/// excluding the null termination character, is specified by
	/// length. If the length of the returned
	/// string is not required, a value of NULL can
	/// be passed in the length argument. The
	/// size of the buffer required to store the returned source code
	/// string can be obtained by calling
	/// glGetShader
	/// with the value
	/// GL_SHADER_SOURCE_LENGTH.
	__gshared void function(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source) glGetShaderSource;
	/// Return a string describing the current GL connection.
	/// 
	/// glGetString returns a pointer to a static string
	/// describing some aspect of the current GL connection.
	/// name can be one of the following:
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Returns the company responsible for this GL implementation.
	/// This name does not change from release to release.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Returns the name of the renderer.
	/// This name is typically specific to a particular configuration of a hardware
	/// platform.
	/// It does not change from release to release.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Returns a version or release number.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Returns a version or release number for the shading language.
	/// 
	/// 
	/// glGetStringi returns a pointer to a static string
	/// indexed by index.
	/// name can be one of the following:
	/// 
	/// 
	/// 
	/// 
	/// 
	/// For glGetStringi only, returns the extension string
	/// supported by the implementation at index.
	/// 
	/// 
	/// 
	/// Strings GL_VENDOR and GL_RENDERER together uniquely specify
	/// a platform. They do not change from release to release and should be used
	/// by platform-recognition algorithms.
	/// 
	/// 
	/// 
	/// The GL_VERSION and GL_SHADING_LANGUAGE_VERSION strings begin with a version number.
	/// The version number uses one
	/// of these forms:
	/// 
	/// 
	/// major_number.minor_numbermajor_number.minor_number.release_number
	/// 
	/// 
	/// Vendor-specific information may follow the version
	/// number. Its format depends on the implementation, but
	/// a space always separates the version number and
	/// the vendor-specific information.
	/// 
	/// 
	/// 
	/// All strings are null-terminated.
	const(GLubyte*) glGetString(GLenum name);
	/// Ditto
	const(GLubyte*) glGetStringi(GLenum name, GLuint index);
	/// Retrieve the index of a subroutine uniform of a given shader stage within a program.
	/// 
	/// glGetSubroutineIndex returns the index of a subroutine uniform within a shader stage attached to a program object.
	/// program contains the name of the program to which the shader is attached. shadertype
	/// specifies the stage from which to query shader subroutine index. name contains the null-terminated
	/// name of the subroutine uniform whose name to query.
	/// 
	/// 
	/// 
	/// If name is not the name of a subroutine uniform in the shader stage, GL_INVALID_INDEX
	/// is returned, but no error is generated. If name is the name of a subroutine uniform in the shader stage,
	/// a value between zero and the value of GL_ACTIVE_SUBROUTINES minus one will be returned. Subroutine indices
	/// are assigned using consecutive integers in the range from zero to the value of GL_ACTIVE_SUBROUTINES minus
	/// one for the shader stage.
	__gshared GLuint function(GLuint program, GLenum shadertype, const GLchar* name) glGetSubroutineIndex;
	/// Retrieve the location of a subroutine uniform of a given shader stage within a program.
	/// 
	/// glGetSubroutineUniformLocation returns the location of the subroutine uniform variable
	/// name in the shader stage of type shadertype attached to
	/// program, with behavior otherwise identical to
	/// glGetUniformLocation.
	/// 
	/// 
	/// 
	/// If name is not the name of a subroutine uniform in the shader stage, -1
	/// is returned, but no error is generated. If name is the name of a subroutine uniform in the shader stage,
	/// a value between zero and the value of GL_ACTIVE_SUBROUTINE_LOCATIONS minus one will be returned.
	/// Subroutine locations are assigned using consecutive integers in the range from zero to the value
	/// of GL_ACTIVE_SUBROUTINE_LOCATIONS minus one for the shader stage. For active subroutine uniforms
	/// declared as arrays, the declared array elements are assigned consecutive locations.
	__gshared GLint function(GLuint program, GLenum shadertype, const GLchar* name) glGetSubroutineUniformLocation;
	/// Query the properties of a sync object.
	/// 
	/// glGetSynciv retrieves properties of a sync object. sync specifies the name of the sync
	/// object whose properties to retrieve.
	/// 
	/// 
	/// 
	/// On success, glGetSynciv replaces up to bufSize integers in values with the
	/// corresponding property values of the object being queried. The actual number of integers replaced is returned in the variable whose address is
	/// specified in length. If length is NULL, no length is returned.
	/// 
	/// 
	/// 
	/// If pname is GL_OBJECT_TYPE, a single value representing the specific type of the sync object is
	/// placed in values. The only type supported is GL_SYNC_FENCE.
	/// 
	/// 
	/// 
	/// If pname is GL_SYNC_STATUS, a single value representing the status of the sync object
	/// (GL_SIGNALED or GL_UNSIGNALED) is placed in values.
	/// 
	/// 
	/// 
	/// If pname is GL_SYNC_CONDITION, a single value representing the condition of the sync object
	/// is placed in values. The only condition supported is GL_SYNC_GPU_COMMANDS_COMPLETE.
	/// 
	/// 
	/// 
	/// If pname is GL_SYNC_FLAGS, a single value representing the flags with which the sync object
	/// was created is placed in values. No flags are currently supportedflags is
	/// expected to be used in future extensions to the sync objects..
	/// 
	/// 
	/// flags is
	/// expected to be used in future extensions to the sync objects.
	/// 
	/// 
	/// If an error occurs, nothing will be written to values or length.
	__gshared void function(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values) glGetSynciv;
	/// Return a texture image.
	/// 
	/// glGetTexImage returns a texture image into img.
	/// target specifies whether the desired texture image is one specified by
	/// glTexImage1D (GL_TEXTURE_1D),
	/// glTexImage2D (GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE,
	/// GL_TEXTURE_2D or any of
	/// GL_TEXTURE_CUBE_MAP_*),
	/// or
	/// glTexImage3D (GL_TEXTURE_2D_ARRAY,
	/// GL_TEXTURE_3D).
	/// level specifies the level-of-detail number of the desired image.
	/// format and type specify the format and type of the desired image array.
	/// See the reference page for glTexImage1D
	/// for a description of the acceptable values for the format and type
	/// parameters, respectively.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// requested, img is treated as a byte offset into the buffer object's data store.
	/// 
	/// 
	/// 
	/// To understand the operation of glGetTexImage, consider the selected internal
	/// four-component texture image to be an RGBA color buffer the size of the image.
	/// The semantics of glGetTexImage are then identical to those of glReadPixels,
	/// with the exception that no pixel transfer operations are performed,
	/// when called with the same format and type,
	/// with x and y set to 0,
	/// width set to the width of the texture image
	/// and height set to 1 for 1D images,
	/// or to the height of the texture image
	/// for 2D images.
	/// 
	/// 
	/// 
	/// If the selected texture image does not contain four components,
	/// the following mappings are applied.
	/// Single-component textures are treated as RGBA buffers with red set
	/// to the single-component value,
	/// green set to 0, blue set to 0, and alpha set to 1.
	/// Two-component textures are treated as RGBA buffers with red set to
	/// the value of component zero,
	/// alpha set to the value of component one,
	/// and green and blue set to 0.
	/// Finally,
	/// three-component textures are treated as RGBA buffers with red set to
	/// component zero,
	/// green set to component one,
	/// blue set to component two,
	/// and alpha set to 1.
	/// 
	/// 
	/// 
	/// To determine the required size of img,
	/// use glGetTexLevelParameter to determine the dimensions of the
	/// internal texture image,
	/// then scale the required number of pixels by the storage required for
	/// each pixel,
	/// based on format and type.
	/// Be sure to take the pixel storage parameters into account,
	/// especially GL_PACK_ALIGNMENT.
	void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid * img);
	/// Return texture parameter values for a specific level of detail.
	/// 
	/// glGetTexLevelParameter returns in params texture parameter values for a specific
	/// level-of-detail value,
	/// specified as level.
	/// target defines the target texture,
	/// either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D,
	/// GL_PROXY_TEXTURE_1D,
	/// GL_PROXY_TEXTURE_2D,
	/// GL_PROXY_TEXTURE_3D,
	/// GL_TEXTURE_CUBE_MAP_POSITIVE_X,
	/// GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
	/// GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
	/// GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
	/// GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
	/// GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
	/// GL_PROXY_TEXTURE_CUBE_MAP.
	/// 
	/// 
	/// GL_MAX_TEXTURE_SIZE, and GL_MAX_3D_TEXTURE_SIZE are not really
	/// descriptive enough.
	/// It has to report the largest square texture image that can be
	/// accommodated with mipmaps and borders,
	/// but a long skinny texture, or a texture without mipmaps and borders, may
	/// easily fit in texture memory.
	/// The proxy targets allow the user to more accurately query
	/// whether the GL can accommodate a texture of a given configuration.
	/// If the texture cannot be accommodated, the texture state variables, which
	/// may be queried with glGetTexLevelParameter, are set to 0. If the texture can be accommodated,
	/// the texture state values will be set as they would be set for a
	/// non-proxy target.
	/// 
	/// 
	/// pname specifies the texture parameter whose value or values
	/// will be returned.
	/// 
	/// 
	/// 
	/// The accepted parameter names are as follows:
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value,
	/// the width of the texture image.
	/// This value includes the border of the texture image. The initial value is
	/// 0.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value,
	/// the height of the texture image.
	/// This value includes the border of the texture image. The initial value is
	/// 0.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value,
	/// the depth of the texture image.
	/// This value includes the border of the texture image. The initial value is
	/// 0.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single value,
	/// the internal format of the texture image.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// The data type used to store the component.
	/// The types GL_NONE, GL_SIGNED_NORMALIZED,
	/// GL_UNSIGNED_NORMALIZED, GL_FLOAT,
	/// GL_INT, and GL_UNSIGNED_INT may be returned
	/// to indicate signed normalized fixed-point, unsigned normalized fixed-point, floating-point, integer unnormalized, and
	/// unsigned integer unnormalized components, respectively.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// The internal storage resolution of an individual component.
	/// The resolution chosen by the GL will be a close match for the resolution
	/// requested by the user with the component argument of glTexImage1D,
	/// glTexImage2D, glTexImage3D, glCopyTexImage1D, and
	/// glCopyTexImage2D. The initial value is 0.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single boolean value indicating if the texture image is
	/// stored in a compressed internal format. The initiali value is GL_FALSE.
	/// 
	/// 
	/// 
	/// 
	/// params returns a single integer value, the number of unsigned bytes of the
	/// compressed texture image that would be returned from
	/// glGetCompressedTexImage.
	void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params);
	/// Ditto
	void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params);
	/// Return texture parameter values.
	/// 
	/// glGetTexParameter returns in params the value or values of the texture parameter
	/// specified as pname.
	/// target defines the target texture.
	/// GL_TEXTURE_1D,
	/// GL_TEXTURE_2D,
	/// GL_TEXTURE_3D,
	/// GL_TEXTURE_1D_ARRAY,
	/// GL_TEXTURE_2D_ARRAY,
	/// GL_TEXTURE_RECTANGLE,
	/// GL_TEXTURE_CUBE_MAP,
	/// GL_TEXTURE_CUBE_MAP_ARRAY
	/// specify one-, two-, or three-dimensional, one-dimensional array, two-dimensional array, rectangle, cube-mapped or cube-mapped array texturing, respectively.
	/// pname accepts the same symbols as glTexParameter,
	/// with the same interpretations:
	/// 
	/// 
	/// 
	/// Returns the single-valued texture magnification filter,
	/// a symbolic constant. The initial value is GL_LINEAR.
	/// 
	/// 
	/// 
	/// Returns the single-valued texture minification filter,
	/// a symbolic constant. The initial value is GL_NEAREST_MIPMAP_LINEAR.
	/// 
	/// 
	/// 
	/// Returns the single-valued texture minimum level-of-detail value. The
	/// initial value is 
	/// -1000.
	/// 
	/// 
	/// 
	/// Returns the single-valued texture maximum level-of-detail value. The
	/// initial value is 1000.
	/// 
	/// 
	/// 
	/// Returns the single-valued base texture mipmap level. The initial value is 0.
	/// 
	/// 
	/// 
	/// Returns the single-valued maximum texture mipmap array level. The initial
	/// value is 1000.
	/// 
	/// 
	/// 
	/// Returns the red component swizzle. The initial value is GL_RED.
	/// 
	/// 
	/// 
	/// Returns the green component swizzle. The initial value is GL_GREEN.
	/// 
	/// 
	/// 
	/// Returns the blue component swizzle. The initial value is GL_BLUE.
	/// 
	/// 
	/// 
	/// Returns the alpha component swizzle. The initial value is GL_ALPHA.
	/// 
	/// 
	/// 
	/// Returns the component swizzle for all channels in a single query.
	/// 
	/// 
	/// 
	/// Returns the single-valued wrapping function for texture coordinate 
	/// s,
	/// a symbolic constant. The initial value is GL_REPEAT.
	/// 
	/// 
	/// 
	/// Returns the single-valued wrapping function for texture coordinate 
	/// t,
	/// a symbolic constant. The initial value is GL_REPEAT.
	/// 
	/// 
	/// 
	/// Returns the single-valued wrapping function for texture coordinate 
	/// r,
	/// a symbolic constant. The initial value is GL_REPEAT.
	/// 
	/// 
	/// 
	/// Returns four integer or floating-point numbers that comprise the RGBA color
	/// of the texture border.
	/// Floating-point values are returned in the range 
	/// 01.
	/// Integer values are returned as a linear mapping of the internal floating-point
	/// representation such that 1.0 maps to the most positive representable
	/// integer and 
	/// -1.0
	/// maps to the most negative representable
	/// integer. The initial value is (0, 0, 0, 0).
	/// 
	/// 
	/// 
	/// Returns a single-valued texture comparison mode, a symbolic constant. The
	/// initial value is GL_NONE. See glTexParameter.
	/// 
	/// 
	/// 
	/// Returns a single-valued texture comparison function, a symbolic constant. The
	/// initial value is GL_LEQUAL. See glTexParameter.
	/// 
	/// 
	/// 
	/// In addition to the parameters that may be set with glTexParameter,
	/// glGetTexParameter accepts the following read-only parameters:
	/// 
	/// 
	/// 
	/// Returns non-zero if the texture has an immutable format. Textures become
	/// immutable if their storage is specified with glTexStorage1D,
	/// glTexStorage2D or glTexStorage3D.
	/// The initial value is GL_FALSE.
	void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params);
	/// Ditto
	void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params);
	/// Ditto
	__gshared void function(GLenum target, GLenum pname, GLint * params) glGetTexParameterIiv;
	/// Ditto
	__gshared void function(GLenum target, GLenum pname, GLuint * params) glGetTexParameterIuiv;
	/// Retrieve information about varying variables selected for transform feedback.
	/// 
	/// Information about the set of varying variables in a linked program that will be captured
	/// during transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
	/// glGetTransformFeedbackVarying provides information about the varying
	/// variable selected by index. An index of 0 selects
	/// the first varying variable specified in the varyings array passed
	/// to glTransformFeedbackVaryings, and
	/// an index of GL_TRANSFORM_FEEDBACK_VARYINGS-1 selects
	/// the last such variable.
	/// 
	/// 
	/// 
	/// The name of the selected varying is returned as a null-terminated string in
	/// name. The actual number of characters written into name,
	/// excluding the null terminator, is returned in length. If length
	/// is NULL, no length is returned. The maximum number of characters that may be written into name,
	/// including the null terminator, is specified by bufSize.
	/// 
	/// 
	/// 
	/// The length of the longest varying name in program is given by GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH,
	/// which can be queried with glGetProgram.
	/// 
	/// 
	/// 
	/// For the selected varying variable, its type is returned into type. The size of
	/// the varying is returned into size. The value in size is
	/// in units of the type returned in type. The type returned can be any of the
	/// scalar, vector, or matrix attribute types returned by glGetActiveAttrib.
	/// If an error occurred, the return parameters length, size,
	/// type and name will be unmodified. This command will return as much
	/// information about the varying variables as possible. If no information is available, length
	/// will be set to zero and name will be an empty string. This situation could
	/// arise if glGetTransformFeedbackVarying is called after a failed link.
	__gshared void function(GLsizei* length, GLenum* type, char* name) glGetTransformFeedbackVarying;
	/// Returns the value of a uniform variable.
	/// 
	/// glGetUniform returns in
	/// params the value(s) of the specified
	/// uniform variable. The type of the uniform variable specified by
	/// location determines the number of values
	/// returned. If the uniform variable is defined in the shader as a
	/// boolean, int, or float, a single value will be returned. If it
	/// is defined as a vec2, ivec2, or bvec2, two values will be
	/// returned. If it is defined as a vec3, ivec3, or bvec3, three
	/// values will be returned, and so on. To query values stored in
	/// uniform variables declared as arrays, call
	/// glGetUniform for each element of the array.
	/// To query values stored in uniform variables declared as
	/// structures, call glGetUniform for each
	/// field in the structure. The values for uniform variables
	/// declared as a matrix will be returned in column major
	/// order.
	/// 
	/// The locations assigned to uniform variables are not known
	/// until the program object is linked. After linking has occurred,
	/// the command
	/// glGetUniformLocation
	/// can be used to obtain the location of a uniform variable. This
	/// location value can then be passed to
	/// glGetUniform in order to query the current
	/// value of the uniform variable. After a program object has been
	/// linked successfully, the index values for uniform variables
	/// remain fixed until the next link command occurs. The uniform
	/// variable values can only be queried after a link if the link was
	/// successful.
	__gshared void function(GLuint program, GLint location, GLfloat* params) glGetUniformfv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLint* params) glGetUniformiv;
	/// Retrieve the index of a named uniform block.
	/// 
	/// glGetUniformBlockIndex retrieves the index of a uniform block within program.
	/// 
	/// 
	/// program must be the name of a program object for which the command
	/// glLinkProgram must have been called in the past, although it is not required that
	/// glLinkProgram must have succeeded. The link could have failed because the number
	/// of active uniforms exceeded the limit.
	/// 
	/// 
	/// uniformBlockName must contain a nul-terminated string specifying the name of the uniform block.
	/// 
	/// 
	/// glGetUniformBlockIndex returns the uniform block index for the uniform block named uniformBlockName
	/// of program. If uniformBlockName does not identify an active uniform block of program,
	/// glGetUniformBlockIndex returns the special identifier, GL_INVALID_INDEX. Indices of the active uniform
	/// blocks of a program are assigned in consecutive order, beginning with zero.
	__gshared GLuint function(GLuint program, const GLchar* uniformBlockName) glGetUniformBlockIndex;
	/// Retrieve the index of a named uniform block.
	/// 
	/// glGetUniformIndices retrieves the indices of a number of uniforms within program.
	/// 
	/// 
	/// program must be the name of a program object for which the command
	/// glLinkProgram must have been called in the past, although it is not required that
	/// glLinkProgram must have succeeded. The link could have failed because the number
	/// of active uniforms exceeded the limit.
	/// 
	/// 
	/// uniformCount indicates both the number of elements in the array of names uniformNames and the
	/// number of indices that may be written to uniformIndices.
	/// 
	/// 
	/// uniformNames contains a list of uniformCount name strings identifying the uniform names to be
	/// queried for indices. For each name string in uniformNames, the index assigned to the active uniform of that name will
	/// be written to the corresponding element of uniformIndices. If a string in uniformNames is not
	/// the name of an active uniform, the special value GL_INVALID_INDEX will be written to the corresponding element of
	/// uniformIndices.
	/// 
	/// 
	/// 
	/// If an error occurs, nothing is written to uniformIndices.
	__gshared GLuint function(GLuint program, GLsizei uniformCount, const GLchar** uniformNames, GLuint* uniformIndices) glGetUniformIndices;
	/// Returns the location of a uniform variable.
	/// 
	/// glGetUniformLocation returns an
	/// integer that represents the location of a specific uniform
	/// variable within a program object. name
	/// must be a null terminated string that contains no white space.
	/// name must be an active uniform variable
	/// name in program that is not a structure,
	/// an array of structures, or a subcomponent of a vector or a
	/// matrix. This function returns -1 if name
	/// does not correspond to an active uniform variable in
	/// program, if name
	/// starts with the reserved prefix "gl_", or if
	/// name is associated with an atomic counter or
	/// a named uniform block.
	/// 
	/// Uniform variables that are structures or arrays of
	/// structures may be queried by calling
	/// glGetUniformLocation for each field within
	/// the structure. The array element operator "[]" and the
	/// structure field operator "." may be used in
	/// name in order to select elements within
	/// an array or fields within a structure. The result of using these
	/// operators is not allowed to be another structure, an array of
	/// structures, or a subcomponent of a vector or a matrix. Except if
	/// the last part of name indicates a uniform
	/// variable array, the location of the first element of an array
	/// can be retrieved by using the name of the array, or by using the
	/// name appended by "[0]".
	/// 
	/// The actual locations assigned to uniform variables are not
	/// known until the program object is linked successfully. After
	/// linking has occurred, the command
	/// glGetUniformLocation can be used to obtain
	/// the location of a uniform variable. This location value can then
	/// be passed to
	/// glUniform
	/// to set the value of the uniform variable or to
	/// glGetUniform
	/// in order to query the current value of the uniform variable.
	/// After a program object has been linked successfully, the index
	/// values for uniform variables remain fixed until the next link
	/// command occurs. Uniform variable locations and values can only
	/// be queried after a link if the link was successful.
	__gshared GLint function(GLuint program, const GLchar* name) glGetUniformLocation;
	/// Retrieve the value of a subroutine uniform of a given shader stage of the current program.
	/// 
	/// glGetUniformSubroutine retrieves the value of the subroutine uniform at location
	/// location for shader stage shadertype of the current
	/// program. location must be less than the value of
	/// GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader currently in use at
	/// shader stage shadertype. The value of the subroutine uniform is returned in
	/// values.
	__gshared void function(GLenum shadertype, GLint location, GLuint* values) glGetUniformSubroutineuiv;
	/// Return a generic vertex attribute parameter.
	/// 
	/// glGetVertexAttrib returns in
	/// params the value of a generic vertex
	/// attribute parameter. The generic vertex attribute to be queried
	/// is specified by index, and the parameter
	/// to be queried is specified by pname.
	/// 
	/// The accepted parameter names are as follows:
	/// 
	/// 
	/// 
	/// params returns a
	/// single value, the name of the buffer object currently bound to
	/// the binding point corresponding to generic vertex attribute array 
	/// index. If no buffer object is bound, 
	/// 0 is returned. The initial value is 0.
	/// 
	/// 
	/// 
	/// params returns a
	/// single value that is non-zero (true) if the vertex
	/// attribute array for index is
	/// enabled and 0 (false) if it is disabled. The initial
	/// value is GL_FALSE.
	/// 
	/// 
	/// 
	/// params returns a
	/// single value, the size of the vertex attribute array
	/// for index. The size is the
	/// number of values for each element of the vertex
	/// attribute array, and it will be 1, 2, 3, or 4. The
	/// initial value is 4.
	/// 
	/// 
	/// 
	/// params returns a
	/// single value, the array stride for (number of bytes
	/// between successive elements in) the vertex attribute
	/// array for index. A value of 0
	/// indicates that the array elements are stored
	/// sequentially in memory. The initial value is 0.
	/// 
	/// 
	/// 
	/// params returns a
	/// single value, a symbolic constant indicating the
	/// array type for the vertex attribute array for
	/// index. Possible values are
	/// GL_BYTE,
	/// GL_UNSIGNED_BYTE,
	/// GL_SHORT,
	/// GL_UNSIGNED_SHORT,
	/// GL_INT,
	/// GL_UNSIGNED_INT,
	/// GL_FLOAT, and
	/// GL_DOUBLE. The initial value is
	/// GL_FLOAT.
	/// 
	/// 
	/// 
	/// params returns a
	/// single value that is non-zero (true) if fixed-point
	/// data types for the vertex attribute array indicated
	/// by index are normalized when
	/// they are converted to floating point, and 0 (false)
	/// otherwise. The initial value is
	/// GL_FALSE.
	/// 
	/// 
	/// 
	/// params returns a
	/// single value that is non-zero (true) if fixed-point
	/// data types for the vertex attribute array indicated
	/// by index have integer data types, and 0 (false)
	/// otherwise. The initial value is
	/// 0 (GL_FALSE).
	/// 
	/// 
	/// 
	/// params returns a
	/// single value that is the frequency divisor used for instanced
	/// rendering. See glVertexAttribDivisor.
	/// The initial value is 0.
	/// 
	/// 
	/// 
	/// params returns four
	/// values that represent the current value for the
	/// generic vertex attribute specified by index. Generic
	/// vertex attribute 0 is unique in that it has no
	/// current state, so an error will be generated if
	/// index is 0. The initial value
	/// for all other generic vertex attributes is
	/// (0,0,0,1).
	/// 
	/// glGetVertexAttribdv and glGetVertexAttribfv
	/// return the current attribute values as four single-precision floating-point values;
	/// glGetVertexAttribiv reads them as floating-point values and
	/// converts them to four integer values; glGetVertexAttribIiv and
	/// glGetVertexAttribIuiv read and return them as signed or unsigned
	/// integer values, respectively; glGetVertexAttribLdv reads and returns
	/// them as four double-precision floating-point values.
	/// 
	/// 
	/// All of the parameters except GL_CURRENT_VERTEX_ATTRIB
	/// represent state stored in the currently bound vertex array object.
	__gshared void function(GLuint index, GLenum pname, GLdouble* params) glGetVertexAttribdv;
	/// Ditto
	__gshared void function(GLuint index, GLenum pname, GLfloat* params) glGetVertexAttribfv;
	/// Ditto
	__gshared void function(GLuint index, GLenum pname, GLint* params) glGetVertexAttribiv;
	/// Ditto
	__gshared void function(GLuint index, GLenum pname, GLint* params) glGetVertexAttribIiv;
	/// Ditto
	__gshared void function(GLuint index, GLenum pname, GLuint* params) glGetVertexAttribIuiv;
	/// Ditto
	__gshared void function(GLuint index, GLenum pname, GLdouble* params) glGetVertexAttribLdv;
	/// Return the address of the specified generic vertex attribute pointer.
	/// 
	/// glGetVertexAttribPointerv returns
	/// pointer information. index is the generic
	/// vertex attribute to be queried, pname is
	/// a symbolic constant indicating the pointer to be returned, and
	/// params is a pointer to a location in
	/// which to place the returned data.
	/// 
	/// The pointer returned is a byte offset into the data store of the buffer object
	/// that was bound to the GL_ARRAY_BUFFER target
	/// (see glBindBuffer) when the desired pointer was previously specified.
	__gshared void function(GLuint index, GLenum pname, GLvoid** pointer) glGetVertexAttribPointerv;
	/// Specify implementation-specific hints.
	/// 
	/// Certain aspects of GL behavior,
	/// when there is room for interpretation,
	/// can be controlled with hints.
	/// A hint is specified with two arguments.
	/// target is a symbolic
	/// constant indicating the behavior to be controlled,
	/// and mode is another symbolic constant indicating the desired
	/// behavior. The initial value for each target is GL_DONT_CARE.
	/// mode can be one of the following:
	/// 
	/// 
	/// 
	/// 
	/// 
	/// The most efficient option should be chosen.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// The most correct,
	/// or highest quality,
	/// option should be chosen.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// No preference.
	/// 
	/// 
	/// 
	/// Though the implementation aspects that can be hinted are well defined,
	/// the interpretation of the hints depends on the implementation.
	/// The hint aspects that can be specified with target,
	/// along with suggested semantics,
	/// are as follows:
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Indicates the accuracy of the derivative calculation for the GL shading language fragment processing built-in functions:
	/// dFdx, dFdy, and fwidth.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Indicates the sampling quality of antialiased lines.
	/// If a larger filter function is applied, hinting GL_NICEST can
	/// result in more pixel fragments being generated during rasterization.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Indicates the sampling quality of antialiased polygons.
	/// Hinting GL_NICEST can result in more pixel fragments being generated
	/// during rasterization,
	/// if a larger filter function is applied.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Indicates the quality and performance of the compressing texture images.
	/// Hinting GL_FASTEST indicates that texture images should be compressed
	/// as quickly as possible, while GL_NICEST indicates that texture images
	/// should be compressed with as little image quality loss as possible.
	/// GL_NICEST should be selected if the texture is to be retrieved by
	/// glGetCompressedTexImage for reuse.
	void glHint(GLenum target, GLenum mode);
	/// Determine if a name corresponds to a buffer object.
	/// 
	/// glIsBuffer returns GL_TRUE if buffer is currently the name of a buffer object.
	/// If buffer is zero, or is a non-zero value that is not currently the
	/// name of a buffer object, or if an error occurs, glIsBuffer returns GL_FALSE.
	/// 
	/// 
	/// 
	/// A name returned by glGenBuffers, but not yet associated with a buffer object
	/// by calling glBindBuffer, is not the name of a buffer object.
	__gshared GLboolean function(GLuint buffer) glIsBuffer;
	/// Test whether a capability is enabled.
	/// 
	/// glIsEnabled returns GL_TRUE if cap is an enabled capability
	/// and returns GL_FALSE otherwise. Boolean states that are indexed may be tested with glIsEnabledi.
	/// For glIsEnabledi, index specifies the index of the capability to test. index
	/// must be between zero and the count of indexed capabilities for cap.
	/// Initially all capabilities except GL_DITHER are disabled;
	/// GL_DITHER is initially enabled.
	/// 
	/// 
	/// 
	/// The following capabilities are accepted for cap:
	GLboolean glIsEnabled(GLenum cap);
	/// Ditto
	GLboolean glIsEnabledi(GLenum cap, GLuint index);
	/// Determine if a name corresponds to a framebuffer object.
	/// 
	/// glIsFramebuffer returns GL_TRUE if framebuffer is currently the name of a framebuffer
	/// object. If framebuffer is zero, or if framebuffer is not the name of a framebuffer object, or if an error
	/// occurs, glIsFramebuffer returns GL_FALSE. If framebuffer is a name returned by
	/// glGenFramebuffers, by that has not yet been bound through a call to
	/// glBindFramebuffer, then the name is not a framebuffer object and glIsFramebuffer
	/// returns GL_FALSE.
	__gshared GLboolean function(GLuint framebuffer) glIsFramebuffer;
	/// Determines if a name corresponds to a program object.
	/// 
	/// glIsProgram returns
	/// GL_TRUE if program
	/// is the name of a program object previously created with 
	/// glCreateProgram 
	/// and not yet deleted with glDeleteProgram.
	/// If program is zero or a non-zero value that
	/// is not the name of a program object, or if an error occurs, 
	/// glIsProgram returns GL_FALSE.
	__gshared GLboolean function(GLuint program) glIsProgram;
	/// Determine if a name corresponds to a program pipeline object.
	/// 
	/// glIsProgramPipeline returns GL_TRUE if
	/// pipeline is currently the name of a program pipeline object.
	/// If pipeline is zero, or if pipeline is not the
	/// name of a program pipeline object, or if an error occurs, glIsProgramPipeline
	/// returns GL_FALSE. If pipeline is a name returned by
	/// glGenProgramPipelines, but that
	/// has not yet been bound through a call to glBindProgramPipeline,
	/// then the name is not a program pipeline object and glIsProgramPipeline
	/// returns GL_FALSE.
	__gshared GLboolean function(GLuint pipeline) glIsProgramPipeline;
	/// Determine if a name corresponds to a query object.
	/// 
	/// glIsQuery returns GL_TRUE if id is currently the name of a query object.
	/// If id is zero, or is a non-zero value that is not currently the
	/// name of a query object, or if an error occurs, glIsQuery returns GL_FALSE.
	/// 
	/// 
	/// 
	/// A name returned by glGenQueries, but not yet associated with a query object
	/// by calling glBeginQuery, is not the name of a query object.
	__gshared GLboolean function(GLuint id) glIsQuery;
	/// Determine if a name corresponds to a renderbuffer object.
	/// 
	/// glIsRenderbuffer returns GL_TRUE if renderbuffer is currently the name of a renderbuffer
	/// object. If renderbuffer is zero, or if renderbuffer is not the name of a renderbuffer object, or if an error
	/// occurs, glIsRenderbuffer returns GL_FALSE. If renderbuffer is a name returned by
	/// glGenRenderbuffers, by that has not yet been bound through a call to
	/// glBindRenderbuffer or glFramebufferRenderbuffer,
	/// then the name is not a renderbuffer object and glIsRenderbuffer returns GL_FALSE.
	__gshared GLboolean function(GLuint renderbuffer) glIsRenderbuffer;
	/// Determine if a name corresponds to a sampler object.
	/// 
	/// glIsSampler returns GL_TRUE if id is currently the name of a sampler object.
	/// If id is zero, or is a non-zero value that is not currently the
	/// name of a sampler object, or if an error occurs, glIsSampler returns GL_FALSE.
	/// 
	/// 
	/// 
	/// A name returned by glGenSamplers, is the name of a sampler object.
	__gshared GLboolean function(GLuint id) glIsSampler;
	/// Determines if a name corresponds to a shader object.
	/// 
	/// glIsShader returns
	/// GL_TRUE if shader is
	/// the name of a shader object previously created with 
	/// glCreateShader 
	/// and not yet deleted with glDeleteShader. 
	/// If shader is
	/// zero or a non-zero value that is not the name of a shader
	/// object, or if an error occurs, glIsShader returns
	/// GL_FALSE.
	__gshared GLboolean function(GLuint shader) glIsShader;
	/// Determine if a name corresponds to a sync object.
	/// 
	/// glIsSync returns GL_TRUE if sync is currently the name of a sync object.
	/// If sync is not the name of a sync object, or if an error occurs, glIsSync returns
	/// GL_FALSE. Note that zero is not the name of a sync object.
	__gshared GLboolean function(GLsync sync) glIsSync;
	/// Determine if a name corresponds to a texture.
	/// 
	/// glIsTexture returns GL_TRUE if texture is currently the name of a texture.
	/// If texture is zero, or is a non-zero value that is not currently the
	/// name of a texture, or if an error occurs, glIsTexture returns GL_FALSE.
	/// 
	/// 
	/// 
	/// A name returned by glGenTextures, but not yet associated with a texture
	/// by calling glBindTexture, is not the name of a texture.
	GLboolean glIsTexture(GLuint texture);
	/// Determine if a name corresponds to a transform feedback object.
	/// 
	/// glIsTransformFeedback returns GL_TRUE if id is currently the name of a transform feedback
	/// object. If id is zero, or if id is not the name of a transform feedback object, or if an error
	/// occurs, glIsTransformFeedback returns GL_FALSE. If id is a name returned by
	/// glGenTransformFeedbacks, but that has not yet been bound through a call to
	/// glBindTransformFeedback, then the name is not a transform feedback object and glIsTransformFeedback
	/// returns GL_FALSE.
	__gshared GLboolean function(GLuint id) glIsTransformFeedback;
	/// Determine if a name corresponds to a vertex array object.
	/// 
	/// glIsVertexArray returns GL_TRUE if array is currently the name of a renderbuffer
	/// object. If renderbuffer is zero, or if array is not the name of a renderbuffer object, or if an error
	/// occurs, glIsVertexArray returns GL_FALSE. If array is a name returned by
	/// glGenVertexArrays, by that has not yet been bound through a call to
	/// glBindVertexArray, then the name is not a vertex array object and
	/// glIsVertexArray returns GL_FALSE.
	__gshared GLboolean function(GLuint array) glIsVertexArray;
	/// Specify the width of rasterized lines.
	/// 
	/// glLineWidth specifies the rasterized width of both aliased and antialiased
	/// lines.
	/// Using a line width other than 1 has different effects,
	/// depending on whether line antialiasing is enabled.
	/// To enable and disable line antialiasing, call
	/// glEnable and glDisable
	/// with argument GL_LINE_SMOOTH. Line antialiasing is initially
	/// disabled.
	/// 
	/// 
	/// 
	/// If line antialiasing is disabled,
	/// the actual width is determined by rounding the supplied width
	/// to the nearest integer.
	/// (If the rounding results in the value 0,
	/// it is as if the line width were 1.)
	/// If
	/// x>=y,
	/// i pixels are filled in each column that is rasterized,
	/// where i is the rounded value of width.
	/// Otherwise,
	/// i pixels are filled in each row that is rasterized.
	/// 
	/// 
	/// 
	/// If antialiasing is enabled,
	/// line rasterization produces a fragment for each pixel square
	/// that intersects the region lying within the rectangle having width
	/// equal to the current line width,
	/// length equal to the actual length of the line,
	/// and centered on the mathematical line segment.
	/// The coverage value for each fragment is the window coordinate area
	/// of the intersection of the rectangular region with the corresponding
	/// pixel square.
	/// This value is saved and used in the final rasterization step.
	/// 
	/// 
	/// 
	/// Not all widths can be supported when line antialiasing is enabled. If an
	/// unsupported width is requested, the nearest supported width is used.
	/// Only width 1 is guaranteed to be supported; others depend on the
	/// implementation. Likewise, there is a range for aliased line widths as well.
	/// To query the range of supported widths and the size
	/// difference between supported widths within the range, call glGet
	/// with arguments GL_ALIASED_LINE_WIDTH_RANGE,
	/// GL_SMOOTH_LINE_WIDTH_RANGE, and GL_SMOOTH_LINE_WIDTH_GRANULARITY.
	void glLineWidth(GLfloat width);
	/// Links a program object.
	/// 
	/// glLinkProgram links the program
	/// object specified by program. If any
	/// shader objects of type GL_VERTEX_SHADER are
	/// attached to program, they will be used to
	/// create an executable that will run on the programmable vertex
	/// processor. If any shader objects of type GL_GEOMETRY_SHADER
	/// are attached to program, they will be used to create
	/// an executable that will run on the programmable geometry processor.
	/// If any shader objects of type
	/// GL_FRAGMENT_SHADER are attached to
	/// program, they will be used to create an
	/// executable that will run on the programmable fragment
	/// processor.
	/// 
	/// The status of the link operation will be stored as part of
	/// the program object's state. This value will be set to
	/// GL_TRUE if the program object was linked
	/// without errors and is ready for use, and
	/// GL_FALSE otherwise. It can be queried by
	/// calling
	/// glGetProgram
	/// with arguments program and
	/// GL_LINK_STATUS.
	/// 
	/// As a result of a successful link operation, all active
	/// user-defined uniform variables belonging to
	/// program will be initialized to 0, and
	/// each of the program object's active uniform variables will be
	/// assigned a location that can be queried by calling
	/// glGetUniformLocation.
	/// Also, any active user-defined attribute variables that have not
	/// been bound to a generic vertex attribute index will be bound to
	/// one at this time.
	/// 
	/// Linking of a program object can fail for a number of
	/// reasons as specified in the OpenGL Shading Language
	/// Specification. The following lists some of the
	/// conditions that will cause a link error.
	/// 
	/// The number of active attribute variables supported
	/// by the implementation has been exceeded.
	/// 
	/// The storage limit for uniform variables has been
	/// exceeded.
	/// 
	/// The number of active uniform variables supported
	/// by the implementation has been exceeded.
	/// 
	/// The main function is missing
	/// for the vertex, geometry or fragment shader.
	/// 
	/// A varying variable actually used in the fragment
	/// shader is not declared in the same way (or is not
	/// declared at all) in the vertex shader, or geometry shader shader if present.
	/// 
	/// A reference to a function or variable name is
	/// unresolved.
	/// 
	/// A shared global is declared with two different
	/// types or two different initial values.
	/// 
	/// One or more of the attached shader objects has not
	/// been successfully compiled.
	/// 
	/// Binding a generic attribute matrix caused some
	/// rows of the matrix to fall outside the allowed maximum
	/// of GL_MAX_VERTEX_ATTRIBS.
	/// 
	/// Not enough contiguous vertex attribute slots could
	/// be found to bind attribute matrices.
	/// 
	/// The program object contains objects to form a fragment shader but
	/// does not contain objects to form a vertex shader.
	/// 
	/// The program object contains objects to form a geometry shader
	/// but does not contain objects to form a vertex shader.
	/// 
	/// The program object contains objects to form a geometry shader
	/// and the input primitive type, output primitive type, or maximum output
	/// vertex count is not specified in any compiled geometry shader
	/// object.
	/// 
	/// The program object contains objects to form a geometry shader
	/// and the input primitive type, output primitive type, or maximum output
	/// vertex count is specified differently in multiple geometry shader
	/// objects.
	/// 
	/// The number of active outputs in the fragment shader is greater
	/// than the value of GL_MAX_DRAW_BUFFERS.
	/// 
	/// The program has an active output assigned to a location greater
	/// than or equal to the value of GL_MAX_DUAL_SOURCE_DRAW_BUFFERS
	/// and has an active output assigned an index greater than or equal to one.
	/// 
	/// More than one varying out variable is bound to the same number and index.
	/// 
	/// The explicit binding assigments do not leave enough space for the linker
	/// to automatically assign a location for a varying out array, which requires
	/// multiple contiguous locations.
	/// 
	/// The count specified by glTransformFeedbackVaryings
	/// is non-zero, but the program object has no vertex or geometry shader.
	/// 
	/// Any variable name specified to glTransformFeedbackVaryings
	/// in the varyings array is not declared as an output in the vertex shader (or the geometry shader, if active).
	/// 
	/// Any two entries in the varyings array given
	/// glTransformFeedbackVaryings
	/// specify the same varying variable.
	/// 
	/// The total number of components to capture in any transform feedback varying variable
	/// is greater than the constant GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
	/// and the buffer mode is SEPARATE_ATTRIBS.
	/// 
	/// When a program object has been successfully linked, the
	/// program object can be made part of current state by calling
	/// glUseProgram.
	/// Whether or not the link operation was successful, the program
	/// object's information log will be overwritten. The information
	/// log can be retrieved by calling
	/// glGetProgramInfoLog.
	/// 
	/// glLinkProgram will also install the
	/// generated executables as part of the current rendering state if
	/// the link operation was successful and the specified program
	/// object is already currently in use as a result of a previous
	/// call to
	/// glUseProgram.
	/// If the program object currently in use is relinked
	/// unsuccessfully, its link status will be set to
	/// GL_FALSE , but the executables and
	/// associated state will remain part of the current state until a
	/// subsequent call to glUseProgram removes it
	/// from use. After it is removed from use, it cannot be made part
	/// of current state until it has been successfully relinked.
	/// 
	/// If program contains shader objects
	/// of type GL_VERTEX_SHADER, and optionally of type GL_GEOMETRY_SHADER,
	/// but does not contain shader objects of type
	/// GL_FRAGMENT_SHADER, the vertex shader executable will
	/// be installed on the programmable vertex processor, the geometry shader executable, if present,
	/// will be installed on the programmable geometry processor, but no executable will
	/// be installed on the fragment processor. The results of
	/// rasterizing primitives with such a program will be undefined.
	/// 
	/// The program object's information log is updated and the
	/// program is generated at the time of the link operation. After
	/// the link operation, applications are free to modify attached
	/// shader objects, compile attached shader objects, detach shader
	/// objects, delete shader objects, and attach additional shader
	/// objects. None of these operations affects the information log or
	/// the program that is part of the program object.
	__gshared void function(GLuint program) glLinkProgram;
	/// Specify a logical pixel operation for rendering.
	/// 
	/// glLogicOp specifies a logical operation that,
	/// when enabled,
	/// is applied between the incoming RGBA color
	/// and the RGBA color at the corresponding location in the
	/// frame buffer.
	/// To enable or disable the logical operation, call
	/// glEnable and glDisable
	/// using the symbolic constant GL_COLOR_LOGIC_OP. The initial value is
	/// disabled.
	/// 
	/// 
	/// 
	/// 
	/// opcode is a symbolic constant chosen from the list above.
	/// In the explanation of the logical operations,
	/// s represents the incoming color and
	/// d represents the color in the frame buffer.
	/// Standard C-language operators are used.
	/// As these bitwise operators suggest,
	/// the logical operation is applied independently to each bit pair of the
	/// source and destination colors.
	void glLogicOp(GLenum opcode);
	/// Map a buffer object's data store.
	/// 
	/// glMapBuffer maps to the client's address space the entire data store of the buffer object 
	/// currently bound to target. The data can then be directly read and/or written relative to 
	/// the returned pointer, depending on the specified access policy. If the GL is unable to
	/// map the buffer object's data store, glMapBuffer generates an error and returns 
	/// NULL. This may occur for system-specific reasons, such as low virtual memory availability.
	/// If no error occurs, the returned pointer will have an alignment of at least GL_MIN_MAP_BUFFER_ALIGNMENT
	/// basic machine units. The value of GL_MIN_MAP_BUFFER_ALIGNMENT can be retrieved by calling
	/// glGet with pname set to
	/// GL_MIN_MAP_BUFFER_ALIGNMENT and must be a power of two that is at least 64.
	/// 
	/// 
	/// 
	/// If a mapped data store is accessed in a way inconsistent with the specified access policy,
	/// no error is generated, but performance may be negatively impacted and system errors, including program 
	/// termination, may result. Unlike the usage parameter of glBufferData, 
	/// access is not a hint, and does in fact constrain the usage of the mapped data store on
	/// some GL implementations. In order to achieve the highest performance available, a buffer object's data store 
	/// should be used in ways consistent with both its specified usage and 
	/// access parameters.
	/// 
	/// 
	/// 
	/// A mapped data store must be unmapped with glUnmapBuffer before its buffer object is used.
	/// Otherwise an error will be generated by any GL command that attempts to dereference the buffer object's data store.
	/// When a data store is unmapped, the pointer to its data store becomes invalid. glUnmapBuffer
	/// returns GL_TRUE unless the data store contents have become corrupt during the time
	/// the data store was mapped. This can occur for system-specific reasons that affect the availability of graphics
	/// memory, such as screen mode changes. In such situations, GL_FALSE is returned and the
	/// data store contents are undefined. An application must detect this rare condition and reinitialize the data store.
	/// 
	/// 
	/// 
	/// A buffer object's mapped data store is automatically unmapped when the buffer object is deleted or its data store 
	/// is recreated with glBufferData.
	__gshared void * function(GLenum target, GLenum access) glMapBuffer;
	/// Ditto
	__gshared GLboolean function(GLenum target) glUnmapBuffer;
	/// Map a section of a buffer object's data store.
	/// 
	/// glMapBufferRange maps all or part of the data store of a buffer object into the client's address
	/// space. target specifies the target to which the buffer is bound and must be one of GL_ARRAY_BUFFER,
	/// GL_ATOMIC_COUNTER_BUFFER,
	/// GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER,
	/// GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER,
	/// GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER. offset and
	/// length indicate the range of data in the buffer object htat is to be mapped, in terms of basic machine units.
	/// access is a bitfield containing flags which describe the requested mapping. These flags are described below.
	/// 
	/// 
	/// 
	/// If no error occurs, a pointer to the beginning of the mapped range is returned once all pending operations on that buffer have
	/// completed, and may be used to modify and/or query the corresponding range of the buffer, according to the following flag bits set
	/// in access:
	/// GL_MAP_READ_BIT indicates that the returned pointer may be used to read
	/// buffer object data. No GL error is generated if the pointer is used to query
	/// a mapping which excludes this flag, but the result is undefined and system
	/// errors (possibly including program termination) may occur.
	/// GL_MAP_WRITE_BIT indicates that the returned pointer may be used to modify
	/// buffer object data. No GL error is generated if the pointer is used to modify
	/// a mapping which excludes this flag, but the result is undefined and system
	/// errors (possibly including program termination) may occur.
	/// 
	/// 
	/// GL_MAP_READ_BIT indicates that the returned pointer may be used to read
	/// buffer object data. No GL error is generated if the pointer is used to query
	/// a mapping which excludes this flag, but the result is undefined and system
	/// errors (possibly including program termination) may occur.
	/// 
	/// 
	/// GL_MAP_WRITE_BIT indicates that the returned pointer may be used to modify
	/// buffer object data. No GL error is generated if the pointer is used to modify
	/// a mapping which excludes this flag, but the result is undefined and system
	/// errors (possibly including program termination) may occur.
	/// 
	/// 
	/// 
	/// Furthermore, the following optional flag bits in access may be used to modify the mapping:
	/// GL_MAP_INVALIDATE_RANGE_BIT indicates that the previous contents of the
	/// specified range may be discarded. Data within this range are undefined with
	/// the exception of subsequently written data. No GL error is generated if sub-
	/// sequent GL operations access unwritten data, but the result is undefined and
	/// system errors (possibly including program termination) may occur. This flag
	/// may not be used in combination with GL_MAP_READ_BIT.
	/// GL_MAP_INVALIDATE_BUFFER_BIT indicates that the previous contents of the
	/// entire buffer may be discarded. Data within the entire buffer are undefined
	/// with the exception of subsequently written data. No GL error is generated if
	/// subsequent GL operations access unwritten data, but the result is undefined
	/// and system errors (possibly including program termination) may occur. This
	/// flag may not be used in combination with GL_MAP_READ_BIT.
	/// GL_MAP_FLUSH_EXPLICIT_BIT indicates that one or more discrete subranges
	/// of the mapping may be modified. When this flag is set, modifications to
	/// each subrange must be explicitly flushed by calling glFlushMappedBufferRange.
	/// No GL error is set if a subrange of the mapping is modified and
	/// not flushed, but data within the corresponding subrange of the buffer are undefined.
	/// This flag may only be used in conjunction with GL_MAP_WRITE_BIT.
	/// When this option is selected, flushing is strictly limited to regions that are
	/// explicitly indicated with calls to glFlushMappedBufferRange
	/// prior to unmap; if this option is not selected glUnmapBuffer
	/// will automatically flush the entire mapped range when called.
	/// GL_MAP_UNSYNCHRONIZED_BIT indicates that the GL should not attempt to
	/// synchronize pending operations on the buffer prior to returning from glMapBufferRange.
	/// No GL error is generated if pending operations which source or modify the buffer overlap the mapped region,
	/// but the result of such previous and any subsequent operations is undefined.
	/// 
	/// 
	/// GL_MAP_INVALIDATE_RANGE_BIT indicates that the previous contents of the
	/// specified range may be discarded. Data within this range are undefined with
	/// the exception of subsequently written data. No GL error is generated if sub-
	/// sequent GL operations access unwritten data, but the result is undefined and
	/// system errors (possibly including program termination) may occur. This flag
	/// may not be used in combination with GL_MAP_READ_BIT.
	/// 
	/// 
	/// GL_MAP_INVALIDATE_BUFFER_BIT indicates that the previous contents of the
	/// entire buffer may be discarded. Data within the entire buffer are undefined
	/// with the exception of subsequently written data. No GL error is generated if
	/// subsequent GL operations access unwritten data, but the result is undefined
	/// and system errors (possibly including program termination) may occur. This
	/// flag may not be used in combination with GL_MAP_READ_BIT.
	/// 
	/// 
	/// GL_MAP_FLUSH_EXPLICIT_BIT indicates that one or more discrete subranges
	/// of the mapping may be modified. When this flag is set, modifications to
	/// each subrange must be explicitly flushed by calling glFlushMappedBufferRange.
	/// No GL error is set if a subrange of the mapping is modified and
	/// not flushed, but data within the corresponding subrange of the buffer are undefined.
	/// This flag may only be used in conjunction with GL_MAP_WRITE_BIT.
	/// When this option is selected, flushing is strictly limited to regions that are
	/// explicitly indicated with calls to glFlushMappedBufferRange
	/// prior to unmap; if this option is not selected glUnmapBuffer
	/// will automatically flush the entire mapped range when called.
	/// 
	/// 
	/// GL_MAP_UNSYNCHRONIZED_BIT indicates that the GL should not attempt to
	/// synchronize pending operations on the buffer prior to returning from glMapBufferRange.
	/// No GL error is generated if pending operations which source or modify the buffer overlap the mapped region,
	/// but the result of such previous and any subsequent operations is undefined.
	/// 
	/// 
	/// 
	/// If an error occurs, glMapBufferRange returns a NULL pointer.
	/// If no error occurs, the returned pointer will reflect an alignment of at least GL_MIN_MAP_BUFFER_ALIGNMENT
	/// basic machine units. The value of GL_MIN_MAP_BUFFER_ALIGNMENT can be retrieved by calling
	/// glGet with pname set to
	/// GL_MIN_MAP_BUFFER_ALIGNMENT and must be a power of two that is at least 64. Subtracting offset
	/// from this returned pointed will always produce a multiple of GL_MIN_MAP_BUFFER_ALINMENT.
	__gshared void* function(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) glMapBufferRange;
	/// Defines a barrier ordering memory transactions.
	/// 
	/// glMemoryBarrier defines a barrier ordering the memory transactions issued prior to the
	/// command relative to those issued after the barrier. For the purposes of
	/// this ordering, memory transactions performed by shaders are considered to
	/// be issued by the rendering command that triggered the execution of the
	/// shader. barriers is a bitfield indicating the set of operations that
	/// are synchronized with shader stores; the bits used in barriers are as
	/// follows:
	/// 
	/// 
	/// GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT
	/// If set, vertex data sourced from
	/// buffer objects after the barrier will reflect data written by shaders
	/// prior to the barrier. The set of buffer objects affected by this bit
	/// is derived from the buffer object bindings used for
	/// generic vertex attributes derived from the GL_VERTEX_ATTRIB_ARRAY_BUFFER bindings.
	/// GL_ELEMENT_ARRAY_BARRIER_BIT
	/// If set, vertex array indices sourced from
	/// buffer objects after the barrier will reflect data written by shaders
	/// prior to the barrier. The buffer objects affected by this bit are
	/// derived from the GL_ELEMENT_ARRAY_BUFFER binding.
	/// GL_UNIFORM_BARRIER_BIT
	/// Shader uniforms sourced from buffer objects after the barrier will reflect data
	/// written by shaders prior to the barrier.
	/// GL_TEXTURE_FETCH_BARRIER_BIT
	/// Texture fetches from shaders, including
	/// fetches from buffer object memory via buffer textures, after the
	/// barrier will reflect data written by shaders prior to the barrier.
	/// GL_SHADER_IMAGE_ACCESS_BARRIER_BIT
	/// Memory accesses using shader image
	/// load, store, and atomic built-in functions issued after the barrier
	/// will reflect data written by shaders prior to the barrier.
	/// Additionally, image stores and atomics issued after the barrier will
	/// not execute until all memory accesses (e.g., loads, stores, texture
	/// fetches, vertex fetches) initiated prior to the barrier complete.
	/// GL_COMMAND_BARRIER_BIT
	/// Command data sourced from buffer objects by
	/// Draw*Indirect commands after the barrier will reflect data written by
	/// shaders prior to the barrier. The buffer objects affected by this bit
	/// are derived from the GL_DRAW_INDIRECT_BUFFER binding.
	/// GL_PIXEL_BUFFER_BARRIER_BIT
	/// Reads and writes of buffer objects via the
	/// GL_PIXEL_PACK_BUFFER and GL_PIXEL_UNPACK_BUFFER
	/// bindings (via glReadPixels,
	/// glTexSubImage, etc.) after the
	/// barrier will reflect data written by shaders prior to the barrier.
	/// Additionally, buffer object writes issued after the barrier will wait
	/// on the completion of all shader writes initiated prior to the barrier.
	/// GL_TEXTURE_UPDATE_BARRIER_BIT
	/// Writes to a texture via glTex(Sub)Image*,
	/// glCopyTex(Sub)Image*, glCompressedTex(Sub)Image*, and reads via
	/// glGetTexImage after the barrier will reflect data written by shaders
	/// prior to the barrier. Additionally, texture writes from these
	/// commands issued after the barrier will not execute until all shader
	/// writes initiated prior to the barrier complete.
	/// GL_BUFFER_UPDATE_BARRIER_BIT
	/// Reads or writes via glBufferSubData,
	/// glCopyBufferSubData,
	/// or glGetBufferSubData, or
	/// to buffer object memory mapped by glMapBuffer
	/// or glMapBufferRange after the barrier
	/// will reflect data written by shaders prior to the barrier.
	/// Additionally, writes via these commands issued after the barrier will
	/// wait on the completion of any shader writes to the same memory
	/// initiated prior to the barrier.
	/// GL_FRAMEBUFFER_BARRIER_BIT
	/// Reads and writes via framebuffer object
	/// attachments after the barrier will reflect data written by shaders
	/// prior to the barrier. Additionally, framebuffer writes issued after
	/// the barrier will wait on the completion of all shader writes issued
	/// prior to the barrier.
	/// GL_TRANSFORM_FEEDBACK_BARRIER_BIT
	/// Writes via transform feedback
	/// bindings after the barrier will reflect data written by shaders prior
	/// to the barrier. Additionally, transform feedback writes issued after
	/// the barrier will wait on the completion of all shader writes issued
	/// prior to the barrier.
	/// GL_ATOMIC_COUNTER_BARRIER_BIT
	/// Accesses to atomic counters after the
	/// barrier will reflect writes prior to the barrier.
	/// 
	/// 
	/// 
	/// If set, vertex data sourced from
	/// buffer objects after the barrier will reflect data written by shaders
	/// prior to the barrier. The set of buffer objects affected by this bit
	/// is derived from the buffer object bindings used for
	/// generic vertex attributes derived from the GL_VERTEX_ATTRIB_ARRAY_BUFFER bindings.
	/// 
	/// 
	/// 
	/// If set, vertex array indices sourced from
	/// buffer objects after the barrier will reflect data written by shaders
	/// prior to the barrier. The buffer objects affected by this bit are
	/// derived from the GL_ELEMENT_ARRAY_BUFFER binding.
	/// 
	/// 
	/// 
	/// Shader uniforms sourced from buffer objects after the barrier will reflect data
	/// written by shaders prior to the barrier.
	/// 
	/// 
	/// 
	/// Texture fetches from shaders, including
	/// fetches from buffer object memory via buffer textures, after the
	/// barrier will reflect data written by shaders prior to the barrier.
	/// 
	/// 
	/// 
	/// Memory accesses using shader image
	/// load, store, and atomic built-in functions issued after the barrier
	/// will reflect data written by shaders prior to the barrier.
	/// Additionally, image stores and atomics issued after the barrier will
	/// not execute until all memory accesses (e.g., loads, stores, texture
	/// fetches, vertex fetches) initiated prior to the barrier complete.
	/// 
	/// 
	/// 
	/// Command data sourced from buffer objects by
	/// Draw*Indirect commands after the barrier will reflect data written by
	/// shaders prior to the barrier. The buffer objects affected by this bit
	/// are derived from the GL_DRAW_INDIRECT_BUFFER binding.
	/// 
	/// 
	/// 
	/// Reads and writes of buffer objects via the
	/// GL_PIXEL_PACK_BUFFER and GL_PIXEL_UNPACK_BUFFER
	/// bindings (via glReadPixels,
	/// glTexSubImage, etc.) after the
	/// barrier will reflect data written by shaders prior to the barrier.
	/// Additionally, buffer object writes issued after the barrier will wait
	/// on the completion of all shader writes initiated prior to the barrier.
	/// 
	/// 
	/// 
	/// Writes to a texture via glTex(Sub)Image*,
	/// glCopyTex(Sub)Image*, glCompressedTex(Sub)Image*, and reads via
	/// glGetTexImage after the barrier will reflect data written by shaders
	/// prior to the barrier. Additionally, texture writes from these
	/// commands issued after the barrier will not execute until all shader
	/// writes initiated prior to the barrier complete.
	/// 
	/// 
	/// 
	/// Reads or writes via glBufferSubData,
	/// glCopyBufferSubData,
	/// or glGetBufferSubData, or
	/// to buffer object memory mapped by glMapBuffer
	/// or glMapBufferRange after the barrier
	/// will reflect data written by shaders prior to the barrier.
	/// Additionally, writes via these commands issued after the barrier will
	/// wait on the completion of any shader writes to the same memory
	/// initiated prior to the barrier.
	/// 
	/// 
	/// 
	/// Reads and writes via framebuffer object
	/// attachments after the barrier will reflect data written by shaders
	/// prior to the barrier. Additionally, framebuffer writes issued after
	/// the barrier will wait on the completion of all shader writes issued
	/// prior to the barrier.
	/// 
	/// 
	/// 
	/// Writes via transform feedback
	/// bindings after the barrier will reflect data written by shaders prior
	/// to the barrier. Additionally, transform feedback writes issued after
	/// the barrier will wait on the completion of all shader writes issued
	/// prior to the barrier.
	/// 
	/// 
	/// 
	/// Accesses to atomic counters after the
	/// barrier will reflect writes prior to the barrier.
	/// 
	/// 
	/// 
	/// If barriers is GL_ALL_BARRIER_BITS, shader memory accesses
	/// will be synchronized relative to all the operations described above.
	/// 
	/// 
	/// 
	/// Implementations may cache buffer object and texture image memory that
	/// could be written by shaders in multiple caches; for example, there may be
	/// separate caches for texture, vertex fetching, and one or more caches for
	/// shader memory accesses. Implementations are not required to keep these
	/// caches coherent with shader memory writes. Stores issued by one
	/// invocation may not be immediately observable by other pipeline stages or
	/// other shader invocations because the value stored may remain in a cache
	/// local to the processor executing the store, or because data overwritten by
	/// the store is still in a cache elsewhere in the system. When glMemoryBarrier
	/// is called, the GL flushes and/or invalidates any caches relevant to the
	/// operations specified by the barriers parameter to ensure consistent
	/// ordering of operations across the barrier.
	/// 
	/// 
	/// 
	/// To allow for independent shader invocations to communicate by reads and
	/// writes to a common memory address, image variables in the OpenGL Shading
	/// Language may be declared as "coherent". Buffer object or texture image
	/// memory accessed through such variables may be cached only if caches are
	/// automatically updated due to stores issued by any other shader invocation.
	/// If the same address is accessed using both coherent and non-coherent
	/// variables, the accesses using variables declared as coherent will observe
	/// the results stored using coherent variables in other invocations. Using
	/// variables declared as "coherent" guarantees only that the results of
	/// stores will be immediately visible to shader invocations using
	/// similarly-declared variables; calling glMemoryBarrier is required to ensure
	/// that the stores are visible to other operations.
	/// 
	/// 
	/// 
	/// The following guidelines may be helpful in choosing when to use coherent
	/// memory accesses and when to use barriers.
	/// 
	/// 
	/// Data that are read-only or constant may be accessed without using
	/// coherent variables or calling MemoryBarrier(). Updates to the
	/// read-only data via API calls such as BufferSubData will invalidate
	/// shader caches implicitly as required.Data that are shared between shader invocations at a fine granularity
	/// (e.g., written by one invocation, consumed by another invocation) should
	/// use coherent variables to read and write the shared data.Data written by one shader invocation and consumed by other shader
	/// invocations launched as a result of its execution ("dependent
	/// invocations") should use coherent variables in the producing shader
	/// invocation and call memoryBarrier() after the last write. The consuming
	/// shader invocation should also use coherent variables.Data written to image variables in one rendering pass and read by the
	/// shader in a later pass need not use coherent variables or
	/// memoryBarrier(). Calling MemoryBarrier() with the
	/// SHADER_IMAGE_ACCESS_BARRIER_BIT set in barriers between passes is
	/// necessary.Data written by the shader in one rendering pass and read by another
	/// mechanism (e.g., vertex or index buffer pulling) in a later pass need
	/// not use coherent variables or memoryBarrier(). Calling
	/// glMemoryBarrier with the appropriate bits set in barriers between
	/// passes is necessary.
	/// 
	/// Data that are read-only or constant may be accessed without using
	/// coherent variables or calling MemoryBarrier(). Updates to the
	/// read-only data via API calls such as BufferSubData will invalidate
	/// shader caches implicitly as required.
	/// 
	/// Data that are shared between shader invocations at a fine granularity
	/// (e.g., written by one invocation, consumed by another invocation) should
	/// use coherent variables to read and write the shared data.
	/// 
	/// Data written by one shader invocation and consumed by other shader
	/// invocations launched as a result of its execution ("dependent
	/// invocations") should use coherent variables in the producing shader
	/// invocation and call memoryBarrier() after the last write. The consuming
	/// shader invocation should also use coherent variables.
	/// 
	/// Data written to image variables in one rendering pass and read by the
	/// shader in a later pass need not use coherent variables or
	/// memoryBarrier(). Calling MemoryBarrier() with the
	/// SHADER_IMAGE_ACCESS_BARRIER_BIT set in barriers between passes is
	/// necessary.
	/// 
	/// Data written by the shader in one rendering pass and read by another
	/// mechanism (e.g., vertex or index buffer pulling) in a later pass need
	/// not use coherent variables or memoryBarrier(). Calling
	/// glMemoryBarrier with the appropriate bits set in barriers between
	/// passes is necessary.
	__gshared void function(GLbitfield barriers) glMemoryBarrier;
	/// Specifies minimum rate at which sample shaing takes place.
	/// 
	/// glMinSampleShading specifies the rate at which samples are shaded within
	/// a covered pixel. Sample-rate shading is enabled by calling glEnable
	/// with the parameter GL_SAMPLE_SHADING. If GL_MULTISAMPLE
	/// or GL_SAMPLE_SHADING is disabled, sample shading has no effect.
	/// Otherwise, an implementation must provide at least as many unique color values for
	/// each covered fragment as specified by value times samples where
	/// samples is the value of GL_SAMPLES for the current
	/// framebuffer. At least 1 sample for each covered fragment is generated.
	/// 
	/// 
	/// 
	/// A value of 1.0 indicates that each sample in the framebuffer should be
	/// indpendently shaded. A value of 0.0 effectively allows the GL to ignore
	/// sample rate shading. Any value between 0.0 and 1.0 allows the GL to shade only a subset
	/// of the total samples within each covered fragment. Which samples are shaded and the algorithm
	/// used to select that subset of the fragment's samples is implementation dependent.
	__gshared void function(GLclampf value) glMinSampleShading;
	/// Render multiple sets of primitives from array data.
	/// 
	/// glMultiDrawArrays specifies multiple sets of geometric primitives
	/// with very few subroutine calls. Instead of calling a GL procedure
	/// to pass each individual vertex, normal, texture coordinate, edge
	/// flag, or color, you can prespecify
	/// separate arrays of vertices, normals, and colors and use them to
	/// construct a sequence of primitives with a single
	/// call to glMultiDrawArrays.
	/// 
	/// 
	/// glMultiDrawArrays behaves identically to glDrawArrays except that primcount
	/// separate ranges of elements are specified instead.
	/// 
	/// 
	/// 
	/// When glMultiDrawArrays is called, it uses count sequential elements from each
	/// enabled array to construct a sequence of geometric primitives,
	/// beginning with element first. mode specifies what kind of
	/// primitives are constructed, and how the array elements
	/// construct those primitives.
	/// 
	/// 
	/// 
	/// Vertex attributes that are modified by glMultiDrawArrays have an
	/// unspecified value after glMultiDrawArrays returns. Attributes that aren't
	/// modified remain well defined.
	__gshared void function(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount) glMultiDrawArrays;
	/// Render multiple sets of primitives by specifying indices of array data elements.
	/// 
	/// glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine
	/// calls. Instead of calling a GL function to pass each individual vertex,
	/// normal, texture coordinate, edge flag, or color, you can prespecify
	/// separate arrays of vertices, normals, and so on, and use them to construct a
	/// sequence of primitives with a single call to glMultiDrawElements.
	/// 
	/// 
	/// glMultiDrawElements is identical in operation to glDrawElements except that
	/// primcount separate lists of elements are specified.
	/// 
	/// 
	/// 
	/// Vertex attributes that are modified by glMultiDrawElements have an
	/// unspecified value after glMultiDrawElements returns. Attributes that aren't
	/// modified maintain their previous values.
	__gshared void function(GLenum mode, const GLsizei * count, GLenum type, const GLvoid ** indices, GLsizei primcount) glMultiDrawElements;
	/// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index.
	/// 
	/// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex,
	/// except that primcount separate lists of elements are specifried instead.
	/// 
	/// 
	/// 
	/// It has the same effect as:
	/// for (int i = 0; i < primcount; i++)
	/// if (count[i] > 0)
	/// glDrawElementsBaseVertex(mode,
	/// count[i],
	/// type,
	/// indices[i],
	/// basevertex[i]);
	__gshared void function(GLenum mode, const GLsizei* count, GLenum type, const GLvoid** indices, GLsizei primcount, GLint* basevertex) glMultiDrawElementsBaseVertex;
	/// Specifies the parameters for patch primitives.
	/// 
	/// glPatchParameter specifies the parameters that will be used for patch primitives. pname
	/// specifies the parameter to modify and must be either GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL
	/// or GL_PATCH_DEFAULT_INNER_LEVEL. For glPatchParameteri, value specifies
	/// the new value for the parameter specified by pname. For glPatchParameterfv, values
	/// specifies the address of an array containing the new values for the parameter specified by pname.
	/// 
	/// 
	/// 
	/// When pname is GL_PATCH_VERTICES, value specifies the number
	/// of vertices that will be used to make up a single patch primitive. Patch primitives are consumed by the tessellation control
	/// shader (if present) and subsequently used for tessellation. When primitives are specified using
	/// glDrawArrays or a similar function, each patch will be made
	/// from parameter control points, each represented by a vertex taken from the enabeld vertex arrays.
	/// parameter must be greater than zero, and less than or equal to the value of GL_MAX_PATCH_VERTICES.
	/// 
	/// 
	/// 
	/// When pname is GL_PATCH_DEFAULT_OUTER_LEVEL or GL_PATCH_DEFAULT_INNER_LEVEL,
	/// values contains the address of an array contiaining the default outer or inner tessellation levels, respectively,
	/// to be used when no tessellation control shader is present.
	__gshared void function(GLenum pname, GLint value) glPatchParameteri;
	/// Ditto
	__gshared void function(GLenum pname, const GLfloat* values) glPatchParameterfv;
	/// Pause transform feedback operations.
	/// 
	/// glPauseTransformFeedback pauses transform feedback operations on the currently active transform feedback
	/// object. When transform feedback operations are paused, transform feedback is still considered active and changing most
	/// transform feedback state related to the object results in an error. However, a new transform feedback object may be bound
	/// while transform feedback is paused.
	__gshared void function() glPauseTransformFeedback;
	/// Set pixel storage modes.
	/// 
	/// glPixelStore sets pixel storage modes that affect the operation of subsequent
	/// glReadPixels as well as the unpacking of
	/// texture patterns (see glTexImage1D,
	/// glTexImage2D, glTexImage3D, glTexSubImage1D,
	/// glTexSubImage2D, glTexSubImage3D),
	/// glCompressedTexImage1D, glCompressedTexImage2D,
	/// glCompressedTexImage3D, glCompressedTexSubImage1D,
	/// glCompressedTexSubImage2D or glCompressedTexSubImage1D.
	/// 
	/// 
	/// pname is a symbolic constant indicating the parameter to be set, and
	/// param is the new value. Six of the twelve storage parameters affect
	/// how pixel data is returned to client memory.
	/// They are as follows:
	/// 
	/// 
	/// 
	/// If true,
	/// byte ordering for multibyte color components,
	/// depth components,
	/// or stencil indices
	/// is reversed.
	/// That is,
	/// if a four-byte component consists of bytes
	/// b0,
	/// b1,
	/// b2,
	/// b3,
	/// it is stored in memory as
	/// b3,
	/// b2,
	/// b1,
	/// b0
	/// if GL_PACK_SWAP_BYTES is true.
	/// GL_PACK_SWAP_BYTES has no effect on the memory order of components
	/// within a pixel,
	/// only on the order of bytes within components or indices.
	/// For example,
	/// the three components of a GL_RGB format pixel are always stored with
	/// red first,
	/// green second,
	/// and blue third,
	/// regardless of the value of GL_PACK_SWAP_BYTES.
	/// 
	/// 
	/// 
	/// If true,
	/// bits are ordered within a byte from least significant to most significant;
	/// otherwise,
	/// the first bit in each byte is the most significant one.
	/// 
	/// 
	/// 
	/// If greater than 0,
	/// GL_PACK_ROW_LENGTH defines the number of pixels in a row.
	/// If the first pixel of a row is placed at location 
	/// p
	/// in memory,
	/// then the location of the first pixel of the next row is obtained by skipping
	/// 
	/// 
	/// k=nlassnlas>=as<a
	/// 
	/// 
	/// components or indices,
	/// where 
	/// n
	/// is the number of components or indices in a pixel,
	/// l
	/// is the number of pixels in a row
	/// (GL_PACK_ROW_LENGTH if it is greater than 0,
	/// the 
	/// width
	/// argument to the pixel routine otherwise),
	/// a
	/// is the value of GL_PACK_ALIGNMENT, and
	/// s
	/// is the size, in bytes, of a single component
	/// (if 
	/// a<s,
	/// then it is as if 
	/// a=s).
	/// In the case of 1-bit values,
	/// the location of the next row is obtained by skipping
	/// 
	/// 
	/// k=8anl8a
	/// 
	/// 
	/// components or indices.
	/// 
	/// 
	/// 
	/// The word component in this description refers to the nonindex values
	/// red,
	/// green,
	/// blue,
	/// alpha,
	/// and depth.
	/// Storage format GL_RGB,
	/// for example,
	/// has three components per pixel:
	/// first red,
	/// then green,
	/// and finally blue.
	/// 
	/// 
	/// 
	/// If greater than 0,
	/// GL_PACK_IMAGE_HEIGHT defines the number of pixels in an image
	/// three-dimensional texture volume, where ``image'' is defined by all pixels
	/// sharing the same third dimension index.
	/// If the first pixel of a row is placed at location 
	/// p
	/// in memory,
	/// then the location of the first pixel of the next row is obtained by skipping
	/// 
	/// 
	/// k=nlhassnlhas>=as<a
	/// 
	/// 
	/// components or indices, where 
	/// n
	/// is the number of components or indices
	/// in a pixel, 
	/// l
	/// is the number of pixels in a row
	/// (GL_PACK_ROW_LENGTH if it is greater than 0, the
	/// width
	/// argument to glTexImage3D otherwise), 
	/// h
	/// is the number of
	/// rows in a pixel image (GL_PACK_IMAGE_HEIGHT if it is greater than
	/// 0, the 
	/// height
	/// argument to the glTexImage3D routine otherwise),
	/// a
	/// is the value of
	/// GL_PACK_ALIGNMENT, and 
	/// s
	/// is the size, in bytes, of a single
	/// component (if 
	/// a<s,
	/// then it is as if 
	/// a=s).
	/// 
	/// 
	/// 
	/// The word component in this description refers to the nonindex values
	/// red,
	/// green,
	/// blue,
	/// alpha,
	/// and depth.
	/// Storage format GL_RGB,
	/// for example,
	/// has three components per pixel:
	/// first red,
	/// then green,
	/// and finally blue.
	/// 
	/// 
	/// 
	/// These values are provided as a convenience to the programmer;
	/// they provide no functionality that cannot be duplicated simply by
	/// incrementing the pointer passed to glReadPixels.
	/// Setting GL_PACK_SKIP_PIXELS to 
	/// i
	/// is equivalent to incrementing
	/// the pointer by 
	/// in
	/// components or indices,
	/// where 
	/// n
	/// is the number of components or indices in each pixel.
	/// Setting GL_PACK_SKIP_ROWS to 
	/// j
	/// is equivalent to incrementing
	/// the pointer by 
	/// jm
	/// components or indices,
	/// where 
	/// m
	/// is the number of components or indices per row,
	/// as just computed in the GL_PACK_ROW_LENGTH section.
	/// Setting GL_PACK_SKIP_IMAGES to 
	/// k
	/// is equivalent to incrementing
	/// the pointer by 
	/// kp,
	/// where 
	/// p
	/// is the number of components or indices
	/// per image, as computed in the GL_PACK_IMAGE_HEIGHT section.
	/// 
	/// 
	/// 
	/// Specifies the alignment requirements for the start of each pixel row in memory.
	/// The allowable values are
	/// 1 (byte-alignment),
	/// 2 (rows aligned to even-numbered bytes),
	/// 4 (word-alignment), and
	/// 8 (rows start on double-word boundaries).
	/// 
	/// 
	/// 
	/// The other six of the twelve storage parameters affect how pixel data is
	/// read from client memory.
	/// These values are significant for
	/// glTexImage1D,
	/// glTexImage2D,
	/// glTexImage3D,
	/// glTexSubImage1D,
	/// glTexSubImage2D, and
	/// glTexSubImage3D
	/// 
	/// 
	/// They are as follows:
	/// 
	/// 
	/// 
	/// If true,
	/// byte ordering for multibyte color components,
	/// depth components,
	/// or stencil indices
	/// is reversed.
	/// That is,
	/// if a four-byte component consists of bytes
	/// b0,
	/// b1,
	/// b2,
	/// b3,
	/// it is taken from memory as
	/// b3,
	/// b2,
	/// b1,
	/// b0
	/// if GL_UNPACK_SWAP_BYTES is true.
	/// GL_UNPACK_SWAP_BYTES has no effect on the memory order of components
	/// within a pixel,
	/// only on the order of bytes within components or indices.
	/// For example,
	/// the three components of a GL_RGB format pixel are always stored with
	/// red first,
	/// green second,
	/// and blue third,
	/// regardless of the value of GL_UNPACK_SWAP_BYTES.
	/// 
	/// 
	/// 
	/// If true,
	/// bits are ordered within a byte from least significant to most significant;
	/// otherwise,
	/// the first bit in each byte is the most significant one.
	/// 
	/// 
	/// 
	/// If greater than 0,
	/// GL_UNPACK_ROW_LENGTH defines the number of pixels in a row.
	/// If the first pixel of a row is placed at location 
	/// p
	/// in memory,
	/// then the location of the first pixel of the next row is obtained by skipping
	/// 
	/// 
	/// k=nlassnlas>=as<a
	/// 
	/// 
	/// components or indices,
	/// where 
	/// n
	/// is the number of components or indices in a pixel,
	/// l
	/// is the number of pixels in a row
	/// (GL_UNPACK_ROW_LENGTH if it is greater than 0,
	/// the 
	/// width
	/// argument to the pixel routine otherwise),
	/// a
	/// is the value of GL_UNPACK_ALIGNMENT, and
	/// s
	/// is the size, in bytes, of a single component
	/// (if 
	/// a<s,
	/// then it is as if 
	/// a=s).
	/// In the case of 1-bit values,
	/// the location of the next row is obtained by skipping
	/// 
	/// 
	/// k=8anl8a
	/// 
	/// 
	/// components or indices.
	/// 
	/// 
	/// 
	/// The word component in this description refers to the nonindex values
	/// red,
	/// green,
	/// blue,
	/// alpha,
	/// and depth.
	/// Storage format GL_RGB,
	/// for example,
	/// has three components per pixel:
	/// first red,
	/// then green,
	/// and finally blue.
	/// 
	/// 
	/// 
	/// If greater than 0,
	/// GL_UNPACK_IMAGE_HEIGHT defines the number of pixels in an image of
	/// a three-dimensional texture volume. Where ``image'' is defined by all
	/// pixel sharing the same third dimension index.
	/// If the first pixel of a row is placed at location 
	/// p
	/// in memory,
	/// then the location of the first pixel of the next row is obtained by skipping
	/// 
	/// 
	/// k=nlhassnlhas>=as<a
	/// 
	/// 
	/// components or indices,
	/// where 
	/// n
	/// is the number of components or indices in a pixel,
	/// l
	/// is the number of pixels in a row
	/// (GL_UNPACK_ROW_LENGTH if it is greater than 0,
	/// the 
	/// width
	/// argument to glTexImage3D otherwise),
	/// h
	/// is the number of rows in an image (GL_UNPACK_IMAGE_HEIGHT if
	/// it is greater than 0, the 
	/// height
	/// argument to glTexImage3D otherwise),
	/// a
	/// is the value of GL_UNPACK_ALIGNMENT, and
	/// s
	/// is the size, in bytes, of a single component
	/// (if 
	/// a<s,
	/// then it is as if 
	/// a=s).
	/// 
	/// 
	/// 
	/// The word component in this description refers to the nonindex values
	/// red,
	/// green,
	/// blue,
	/// alpha,
	/// and depth.
	/// Storage format GL_RGB,
	/// for example,
	/// has three components per pixel:
	/// first red,
	/// then green,
	/// and finally blue.
	/// 
	/// 
	/// 
	/// These values are provided as a convenience to the programmer;
	/// they provide no functionality that cannot be duplicated by
	/// incrementing the pointer passed to
	/// glTexImage1D,
	/// glTexImage2D,
	/// glTexSubImage1D or
	/// glTexSubImage2D.
	/// Setting GL_UNPACK_SKIP_PIXELS to 
	/// i
	/// is equivalent to incrementing
	/// the pointer by 
	/// in
	/// components or indices,
	/// where 
	/// n
	/// is the number of components or indices in each pixel.
	/// Setting GL_UNPACK_SKIP_ROWS to 
	/// j
	/// is equivalent to incrementing
	/// the pointer by 
	/// jk
	/// components or indices,
	/// where 
	/// k
	/// is the number of components or indices per row,
	/// as just computed in the GL_UNPACK_ROW_LENGTH section.
	/// 
	/// 
	/// 
	/// Specifies the alignment requirements for the start of each pixel row in memory.
	/// The allowable values are
	/// 1 (byte-alignment),
	/// 2 (rows aligned to even-numbered bytes),
	/// 4 (word-alignment), and
	/// 8 (rows start on double-word boundaries).
	/// 
	/// 
	/// 
	/// The following table gives the type,
	/// initial value,
	/// and range of valid values for each storage parameter
	/// that can be set with glPixelStore.
	/// 
	/// 
	/// 
	/// 
	/// glPixelStoref can be used to set any pixel store parameter.
	/// If the parameter type is boolean,
	/// then if param is 0,
	/// the parameter is false;
	/// otherwise it is set to true.
	/// If pname is a integer type parameter,
	/// param is rounded to the nearest integer.
	/// 
	/// 
	/// 
	/// Likewise, glPixelStorei can also be used to set any of the
	/// pixel store parameters.
	/// Boolean parameters are set to false if param is 0 and true otherwise.
	void glPixelStoref(GLenum pname, GLfloat param);
	/// Ditto
	void glPixelStorei(GLenum pname, GLint param);
	/// Specify point parameters.
	/// 
	/// The following values are accepted for pname:
	/// 
	/// 
	/// 
	/// 
	/// params is a single floating-point value that specifies the threshold value
	/// to which point sizes are clamped if they exceed the specified value. The
	/// default value is 1.0.
	/// 
	/// 
	/// 
	/// 
	/// params is a single enum specifying the point sprite texture coordinate origin, either GL_LOWER_LEFT or GL_UPPER_LEFT. 
	/// The default value is GL_UPPER_LEFT.
	__gshared void function(GLenum pname, GLfloat param) glPointParameterf;
	/// Ditto
	__gshared void function(GLenum pname, GLint param) glPointParameteri;
	/// Ditto
	__gshared void function(GLenum pname, const GLfloat * params) glPointParameterfv;
	/// Ditto
	__gshared void function(GLenum pname, const GLint * params) glPointParameteriv;
	/// Specify the diameter of rasterized points.
	/// 
	/// glPointSize specifies the rasterized diameter of points. If point size mode
	/// is disabled (see glEnable with parameter
	/// GL_PROGRAM_POINT_SIZE), this value will be used to rasterize points. Otherwise,
	/// the value written to the shading language built-in variable gl_PointSize will be used.
	void glPointSize(GLfloat size);
	/// Select a polygon rasterization mode.
	/// 
	/// glPolygonMode controls the interpretation of polygons for rasterization.
	/// face describes which polygons mode applies to:
	/// both front and back-facing polygons (GL_FRONT_AND_BACK).
	/// The polygon mode affects only the final rasterization of polygons.
	/// In particular,
	/// a polygon's vertices are lit and
	/// the polygon is clipped and possibly culled before these modes are applied.
	/// 
	/// 
	/// 
	/// Three modes are defined and can be specified in mode:
	/// 
	/// 
	/// 
	/// Polygon vertices that are marked as the start of a boundary edge
	/// are drawn as points.
	/// Point attributes such as
	/// GL_POINT_SIZE and
	/// GL_POINT_SMOOTH control
	/// the rasterization of the points.
	/// Polygon rasterization attributes other than GL_POLYGON_MODE have no effect.
	/// 
	/// 
	/// 
	/// Boundary edges of the polygon are drawn as line segments.
	/// Line attributes such as
	/// GL_LINE_WIDTH and
	/// GL_LINE_SMOOTH control
	/// the rasterization of the lines.
	/// Polygon rasterization attributes other than GL_POLYGON_MODE have no effect.
	/// 
	/// 
	/// 
	/// The interior of the polygon is filled.
	/// Polygon attributes such as GL_POLYGON_SMOOTH control the rasterization of the polygon.
	void glPolygonMode(GLenum face, GLenum mode);
	/// Set the scale and units used to calculate depth values.
	/// 
	/// When GL_POLYGON_OFFSET_FILL, GL_POLYGON_OFFSET_LINE, or
	/// GL_POLYGON_OFFSET_POINT is enabled, each
	/// fragment's depth value will be offset after it is interpolated
	/// from the depth values of the appropriate vertices.
	/// The value of the offset is 
	/// factorDZ+runits,
	/// where 
	/// DZ
	/// is a measurement of the change in depth relative to the screen
	/// area of the polygon, and 
	/// r
	/// is the smallest value that is guaranteed to
	/// produce a resolvable offset for a given implementation.
	/// The offset is added before the depth test is performed and before
	/// the value is written into the depth buffer.
	/// 
	/// 
	/// glPolygonOffset is useful for rendering hidden-line images, for applying decals
	/// to surfaces, and for rendering solids with highlighted edges.
	void glPolygonOffset(GLfloat factor, GLfloat units);
	/// Specify the primitive restart index.
	/// 
	/// glPrimitiveRestartIndex specifies a vertex array element that is treated specially when
	/// primitive restarting is enabled. This is known as the primitive restart index.
	/// 
	/// 
	/// 
	/// When one of the Draw* commands transfers a set of generic attribute array elements to
	/// the GL, if the index within the vertex arrays corresponding to that set is equal to the primitive restart
	/// index, then the GL does not process those elements as a vertex. Instead, it is as if the drawing command
	/// ended with the immediately preceding transfer, and another drawing command is immediately started with
	/// the same parameters, but only transferring the immediately following element through the end of the
	/// originally specified elements.
	/// 
	/// 
	/// 
	/// When either glDrawElementsBaseVertex,
	/// glDrawElementsInstancedBaseVertex or
	/// glMultiDrawElementsBaseVertex is used, the primitive restart
	/// comparison occurs before the basevertex offset is added to the array index.
	__gshared void function(GLuint index) glPrimitiveRestartIndex;
	/// Load a program object with a program binary.
	/// 
	/// glProgramBinary loads a program object with a program binary previously
	/// returned from glGetProgramBinary.
	/// binaryFormat and binary must be those returned
	/// by a previous call to glGetProgramBinary,
	/// and length must be the length returned by
	/// glGetProgramBinary, or by
	/// glGetProgram when called with
	/// pname set to GL_PROGRAM_BINARY_LENGTH.
	/// If these conditions are not met, loading the program binary will fail and program's
	/// GL_LINK_STATUS will be set to GL_FALSE.
	/// 
	/// 
	/// 
	/// A program object's program binary is replaced by calls to
	/// glLinkProgram or
	/// glProgramBinary. When linking success or failure is concerned, glProgramBinary
	/// can be considered to perform an implicit linking operation.
	/// glLinkProgram and glProgramBinary
	/// both set the program object's GL_LINK_STATUS to GL_TRUE
	/// or GL_FALSE.
	/// 
	/// 
	/// 
	/// A successful call to glProgramBinary will reset all uniform variables to their
	/// initial values. The initial value is either the value of the variable's initializer as specified in the
	/// original shader source, or zero if no initializer was present. Additionally, all vertex shader input
	/// and fragment shader output assignments that were in effect when the program was linked before saving are
	/// restored with glProgramBinary is called.
	__gshared void function(GLuint program, GLenum binaryFormat, const void* binary, GLsizei length) glProgramBinary;
	/// Specify a parameter for a program object.
	/// 
	/// glProgramParameter specifies a new value for the parameter nameed by
	/// pname for the program object program.
	/// 
	/// 
	/// 
	/// If pname is GL_PROGRAM_BINARY_RETRIEVABLE_HINT,
	/// value should be GL_FALSE or GL_TRUE
	/// to indicate to the implementation the intention of the application to retrieve the program's
	/// binary representation with glGetProgramBinary.
	/// The implementation may use this information to store information that may be useful for a future
	/// query of the program's binary. It is recommended to set GL_PROGRAM_BINARY_RETRIEVABLE_HINT
	/// for the program to GL_TRUE before calling
	/// glLinkProgram, and
	/// using the program at run-time if the binary is to be retrieved later.
	/// 
	/// 
	/// 
	/// If pname is GL_PROGRAM_SEPARABLE, value
	/// must be GL_TRUE or GL_FALSE and indicates whether
	/// program can be bound to individual pipeline stages via
	/// glUseProgramStages. A program's
	/// GL_PROGRAM_SEPARABLE parameter must be set to GL_TRUEbeforeglLinkProgram
	/// is called in order for it to be usable with a program pipeline object. The initial state of
	/// GL_PROGRAM_SEPARABLE is GL_FALSE.
	__gshared void function(GLuint program, GLenum pname, GLint value) glProgramParameteri;
	/// Specify the value of a uniform variable for a specified program object.
	/// 
	/// glProgramUniform modifies the value of a
	/// uniform variable or a uniform variable array. The location of
	/// the uniform variable to be modified is specified by
	/// location, which should be a value
	/// returned by
	/// glGetUniformLocation.
	/// glProgramUniform operates on the program object
	/// specified by program.
	/// 
	/// The commands glProgramUniform{1|2|3|4}{f|i|ui}
	/// are used to change the value of the uniform variable specified
	/// by location using the values passed as
	/// arguments. The number specified in the command should match the
	/// number of components in the data type of the specified uniform
	/// variable (e.g., 1 for float, int, unsigned int, bool;
	/// 2 for vec2, ivec2, uvec2, bvec2, etc.). The suffix
	/// f indicates that floating-point values are
	/// being passed; the suffix i indicates that
	/// integer values are being passed; the suffix ui indicates that
	/// unsigned integer values are being passed, and this type should also match
	/// the data type of the specified uniform variable. The
	/// i variants of this function should be used
	/// to provide values for uniform variables defined as int, ivec2,
	/// ivec3, ivec4, or arrays of these. The
	/// ui variants of this function should be used
	/// to provide values for uniform variables defined as unsigned int, uvec2,
	/// uvec3, uvec4, or arrays of these. The f
	/// variants should be used to provide values for uniform variables
	/// of type float, vec2, vec3, vec4, or arrays of these. Either the
	/// i, ui or f variants
	/// may be used to provide values for uniform variables of type
	/// bool, bvec2, bvec3, bvec4, or arrays of these. The uniform
	/// variable will be set to false if the input value is 0 or 0.0f,
	/// and it will be set to true otherwise.
	/// 
	/// All active uniform variables defined in a program object
	/// are initialized to 0 when the program object is linked
	/// successfully. They retain the values assigned to them by a call
	/// to glProgramUniform until the next successful
	/// link operation occurs on the program object, when they are once
	/// again initialized to 0.
	/// 
	/// The commands glProgramUniform{1|2|3|4}{f|i|ui}v
	/// can be used to modify a single uniform variable or a uniform
	/// variable array. These commands pass a count and a pointer to the
	/// values to be loaded into a uniform variable or a uniform
	/// variable array. A count of 1 should be used if modifying the
	/// value of a single uniform variable, and a count of 1 or greater
	/// can be used to modify an entire array or part of an array. When
	/// loading n elements starting at an arbitrary
	/// position m in a uniform variable array,
	/// elements m + n - 1 in
	/// the array will be replaced with the new values. If
	/// m + n - 1 is
	/// larger than the size of the uniform variable array, values for
	/// all array elements beyond the end of the array will be ignored.
	/// The number specified in the name of the command indicates the
	/// number of components for each element in
	/// value, and it should match the number of
	/// components in the data type of the specified uniform variable
	/// (e.g., 1 for float, int, bool;
	/// 2 for vec2, ivec2, bvec2, etc.). The data
	/// type specified in the name of the command must match the data
	/// type for the specified uniform variable as described previously
	/// for glProgramUniform{1|2|3|4}{f|i|ui}.
	/// 
	/// For uniform variable arrays, each element of the array is
	/// considered to be of the type indicated in the name of the
	/// command (e.g., glProgramUniform3f or
	/// glProgramUniform3fv can be used to load a uniform
	/// variable array of type vec3). The number of elements of the
	/// uniform variable array to be modified is specified by
	/// count
	/// 
	/// The commands
	/// glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv 
	/// are used to modify a matrix or an array of matrices. The numbers in the
	/// command name are interpreted as the dimensionality of the matrix.
	/// The number 2 indicates a 2 x 2 matrix
	/// (i.e., 4 values), the number 3 indicates a
	/// 3 x 3 matrix (i.e., 9 values), and the number
	/// 4 indicates a 4 x 4 matrix (i.e., 16
	/// values). Non-square matrix dimensionality is explicit, with the first
	/// number representing the number of columns and the second number
	/// representing the number of rows. For example, 
	/// 2x4 indicates a 2 x 4 matrix with 2 columns
	/// and 4 rows (i.e., 8 values).
	/// If transpose is
	/// GL_FALSE, each matrix is assumed to be
	/// supplied in column major order. If
	/// transpose is
	/// GL_TRUE, each matrix is assumed to be
	/// supplied in row major order. The count
	/// argument indicates the number of matrices to be passed. A count
	/// of 1 should be used if modifying the value of a single matrix,
	/// and a count greater than 1 can be used to modify an array of
	/// matrices.
	__gshared void function(GLuint program, GLint location, GLfloat v0) glProgramUniform1f;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLfloat v0, GLfloat v1) glProgramUniform2f;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) glProgramUniform3f;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) glProgramUniform4f;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLint v0) glProgramUniform1i;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLint v0, GLint v1) glProgramUniform2i;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) glProgramUniform3i;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) glProgramUniform4i;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLuint v0) glProgramUniform1ui;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLint v0, GLuint v1) glProgramUniform2ui;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLint v0, GLint v1, GLuint v2) glProgramUniform3ui;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3) glProgramUniform4ui;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, const GLfloat* value) glProgramUniform1fv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, const GLfloat* value) glProgramUniform2fv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, const GLfloat* value) glProgramUniform3fv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, const GLfloat* value) glProgramUniform4fv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, const GLint* value) glProgramUniform1iv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, const GLint* value) glProgramUniform2iv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, const GLint* value) glProgramUniform3iv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, const GLint* value) glProgramUniform4iv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, const GLuint* value) glProgramUniform1uiv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, const GLuint* value) glProgramUniform2uiv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, const GLuint* value) glProgramUniform3uiv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, const GLuint* value) glProgramUniform4uiv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glProgramUniformMatrix2fv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glProgramUniformMatrix3fv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glProgramUniformMatrix4fv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glProgramUniformMatrix2x3fv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glProgramUniformMatrix3x2fv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glProgramUniformMatrix2x4fv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glProgramUniformMatrix4x2fv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glProgramUniformMatrix3x4fv;
	/// Ditto
	__gshared void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glProgramUniformMatrix4x3fv;
	/// Specifiy the vertex to be used as the source of data for flat shaded varyings.
	/// 
	/// Flatshading a vertex shader varying output means to assign all vetices of the primitive the same value
	/// for that output. The vertex from which these values is derived is known as the provoking vertex and
	/// glProvokingVertex specifies which vertex is to be used as the source of data for flat shaded varyings.
	/// 
	/// 
	/// provokeMode must be either GL_FIRST_VERTEX_CONVENTION or
	/// GL_LAST_VERTEX_CONVENTION, and controls the selection of the vertex whose values are assigned to flatshaded
	/// varying outputs. The interpretation of these values for the supported primitive types is:
	/// 
	/// Primitive Type of Polygon i
	/// First Vertex Convention
	/// 
	/// Last Vertex Convention
	/// 
	/// point
	/// ii
	/// independent line
	/// 
	/// 2i - 1
	/// 
	/// 2i
	/// line loop
	/// ii + 1, if i < n
	/// 1, if i = n
	/// line strip
	/// ii + 1
	/// 
	/// independent triangle
	/// 
	/// 3i - 2
	/// 
	/// 3i
	/// triangle strip
	/// ii + 2
	/// 
	/// triangle fan
	/// i + 1
	/// i + 2
	/// 
	/// line adjacency
	/// 
	/// 4i - 2
	/// 
	/// 4i - 1
	/// 
	/// line strip adjacency
	/// i + 1
	/// i + 2
	/// 
	/// triangle adjacency
	/// 
	/// 6i - 5
	/// 
	/// 6i - 1
	/// 
	/// triangle strip adjacency
	/// 
	/// 2i - 1
	/// 
	/// 2i + 3
	/// 
	/// 
	/// i + 1, if i < n
	/// 
	/// 
	/// 1, if i = n
	/// 
	/// 
	/// If a vertex or geometry shader is active, user-defined varying outputs may be flatshaded by using the
	/// flat qualifier when declaring the output.
	__gshared void function(GLenum provokeMode) glProvokingVertex;
	/// Record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
	/// 
	/// glQueryCounter causes the GL to record the current time into the query object named id.
	/// target must be GL_TIMESTAMP. The time is recorded after all previous commands on the
	/// GL client and server state and the framebuffer have been fully realized. When the time is recorded, the query result for that object
	/// is marked available. glQueryCounter timer queries can be used within a glBeginQuery /
	/// glEndQuery block where the target is GL_TIME_ELAPSED and it does
	/// not affect the result of that query object.
	__gshared void function(GLuint id, GLenum target) glQueryCounter;
	/// Select a color buffer source for pixels.
	/// 
	/// glReadBuffer specifies a color buffer as the source for subsequent
	/// glReadPixels, glCopyTexImage1D, glCopyTexImage2D,
	/// glCopyTexSubImage1D, glCopyTexSubImage2D, and
	/// glCopyTexSubImage3D commands.
	/// mode accepts one of twelve or more predefined values.
	/// In a fully configured system,
	/// GL_FRONT,
	/// GL_LEFT, and
	/// GL_FRONT_LEFT all name the front left buffer,
	/// GL_FRONT_RIGHT and
	/// GL_RIGHT name the front right buffer, and
	/// GL_BACK_LEFT and
	/// GL_BACK name the back left buffer.
	/// Further more, the constants GL_COLOR_ATTACHMENTi may be used to indicate the
	/// ith color attachment where i ranges from zero to the
	/// value of GL_MAX_COLOR_ATTACHMENTS minus one.
	/// 
	/// 
	/// 
	/// Nonstereo double-buffered configurations have only a front left and a
	/// back left buffer.
	/// Single-buffered configurations have a front left and a front right
	/// buffer if stereo, and only a front left buffer if nonstereo.
	/// It is an error to specify a nonexistent buffer to glReadBuffer.
	/// 
	/// 
	/// mode is initially GL_FRONT in single-buffered configurations
	/// and GL_BACK in double-buffered configurations.
	void glReadBuffer(GLenum mode);
	/// Read a block of pixels from the frame buffer.
	/// 
	/// glReadPixels returns pixel data from the frame buffer,
	/// starting with the pixel whose lower left corner
	/// is at location (x, y),
	/// into client memory starting at location data.
	/// Several parameters control the processing of the pixel data before
	/// it is placed into client memory.
	/// These parameters are set with glPixelStore.
	/// This reference page describes the effects on glReadPixels of most,
	/// but not all of the parameters specified by these three commands.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_PACK_BUFFER target 
	/// (see glBindBuffer) while a block of pixels is
	/// requested, data is treated as a byte offset into the buffer object's data store
	/// rather than a pointer to client memory.
	/// 
	/// 
	/// glReadPixels returns values from each pixel with lower left corner at
	/// x+iy+j
	/// for 
	/// 0<=i<width
	/// and
	/// 0<=j<height.
	/// This pixel is said to be the 
	/// ith
	/// pixel in the 
	/// jth
	/// row.
	/// Pixels are returned in row order from the lowest to the highest row,
	/// left to right in each row.
	/// 
	/// 
	/// format specifies the format for the returned pixel values;
	/// accepted values are:
	/// 
	/// 
	/// 
	/// Stencil values are read from the stencil buffer.
	/// Each index is converted to fixed point,
	/// shifted left or right depending on the value and sign of GL_INDEX_SHIFT,
	/// and added to GL_INDEX_OFFSET.
	/// If GL_MAP_STENCIL is GL_TRUE,
	/// indices are replaced by their mappings in the table GL_PIXEL_MAP_S_TO_S.
	/// 
	/// 
	/// 
	/// Depth values are read from the depth buffer.
	/// Each component is converted to floating point such that the minimum depth
	/// value maps to 0 and the maximum value maps to 1.
	/// Each component is then multiplied by GL_DEPTH_SCALE,
	/// added to GL_DEPTH_BIAS,
	/// and finally clamped to the range 
	/// 01.
	/// 
	/// 
	/// 
	/// Values are taken from both the depth and stencil buffers. The type parameter
	/// must be GL_UNSIGNED_INT_24_8 or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
	/// 
	/// 
	/// 
	/// Finally, the indices or components
	/// are converted to the proper format,
	/// as specified by type.
	/// If format is GL_STENCIL_INDEX
	/// and type is not GL_FLOAT,
	/// each index is masked with the mask value given in the following table.
	/// If type is GL_FLOAT, then each integer index is converted to
	/// single-precision floating-point format.
	/// 
	/// 
	/// 
	/// If format is
	/// GL_RED,
	/// GL_GREEN,
	/// GL_BLUE,
	/// GL_RGB,
	/// GL_BGR,
	/// GL_RGBA, or
	/// GL_BGRA and type is not GL_FLOAT,
	/// each component is multiplied by the multiplier shown in the following table.
	/// If type is GL_FLOAT, then each component is passed as is
	/// (or converted to the client's single-precision floating-point format if
	/// it is different from the one used by the GL).
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Return values are placed in memory as follows.
	/// If format is
	/// GL_STENCIL_INDEX,
	/// GL_DEPTH_COMPONENT,
	/// GL_RED,
	/// GL_GREEN, or
	/// GL_BLUE,
	/// a single value is returned and the data for the 
	/// ith
	/// pixel in the 
	/// jth
	/// row
	/// is placed in location 
	/// jwidth+i.
	/// GL_RGB and GL_BGR return three values,
	/// GL_RGBA and GL_BGRA return four values for each pixel,
	/// with all values corresponding to a single pixel occupying contiguous space
	/// in data.
	/// Storage parameters set by glPixelStore,
	/// such as GL_PACK_LSB_FIRST and GL_PACK_SWAP_BYTES,
	/// affect the way that data is written into memory.
	/// See glPixelStore for a description.
	void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * data);
	/// Release resources consumed by the implementation's shader compiler.
	/// 
	/// glReleaseShaderCompiler provides a hint to the implementation that it
	/// may free internal resources associated with its shader compiler. glCompileShader
	/// may subsequently be called and the implementation may at that time reallocate resources
	/// previously freed by the call to glReleaseShaderCompiler.
	__gshared void function() glReleaseShaderCompiler;
	/// Establish data storage, format and dimensions of a renderbuffer object's image.
	/// 
	/// glRenderbufferStorage is equivalent to calling
	/// glRenderbufferStorageMultisample with the
	/// samples set to zero.
	/// 
	/// 
	/// 
	/// The target of the operation, specified by target must be GL_RENDERBUFFER.
	/// internalformat specifies the internal format to be used for the renderbuffer object's storage and
	/// must be a color-renderable, depth-renderable, or stencil-renderable format.
	/// width and height are the dimensions, in pixels, of the renderbuffer.
	/// Both width and height must be less than or equal to the value of
	/// GL_MAX_RENDERBUFFER_SIZE.
	/// 
	/// 
	/// 
	/// Upon success, glRenderbufferStorage deletes any existing data store for the renderbuffer
	/// image and the contents of the data store after calling glRenderbufferStorage are undefined.
	__gshared void function(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) glRenderbufferStorage;
	/// Establish data storage, format, dimensions and sample count of a renderbuffer object's image.
	/// 
	/// glRenderbufferStorageMultisample establishes the data storage, format, dimensions and number of
	/// samples of a renderbuffer object's image.
	/// 
	/// 
	/// 
	/// The target of the operation, specified by target must be GL_RENDERBUFFER.
	/// internalformat specifies the internal format to be used for the renderbuffer object's storage and
	/// must be a color-renderable, depth-renderable, or stencil-renderable format.
	/// width and height are the dimensions, in pixels, of the renderbuffer.
	/// Both width and height must be less than or equal to the value of
	/// GL_MAX_RENDERBUFFER_SIZE. samples specifies the number of samples to be used
	/// for the renderbuffer object's image, and must be less than or equal to the value of GL_MAX_SAMPLES.
	/// If internalformat is a signed or unsigned integer format then samples must be
	/// less than or equal to the value of GL_MAX_INTEGER_SAMPLES.
	/// 
	/// 
	/// 
	/// Upon success, glRenderbufferStorageMultisample deletes any existing data store for the renderbuffer
	/// image and the contents of the data store after calling glRenderbufferStorageMultisample are undefined.
	__gshared void function(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) glRenderbufferStorageMultisample;
	/// Resume transform feedback operations.
	/// 
	/// glResumeTransformFeedback resumes transform feedback operations on the currently active transform feedback
	/// object. When transform feedback operations are paused, transform feedback is still considered active and changing most
	/// transform feedback state related to the object results in an error. However, a new transform feedback object may be bound
	/// while transform feedback is paused.
	__gshared void function() glResumeTransformFeedback;
	/// Specify multisample coverage parameters.
	/// 
	/// Multisampling samples a pixel multiple times at various
	/// implementation-dependent subpixel locations to generate antialiasing
	/// effects. Multisampling transparently antialiases points, lines, polygons,
	/// and images if it is enabled.
	/// 
	/// 
	/// value is used in constructing a temporary mask used in determining which
	/// samples will be used in resolving the final fragment color. This mask is
	/// bitwise-anded with the coverage mask generated from the multisampling
	/// computation. If the invert flag is set, the temporary mask is inverted
	/// (all bits flipped) and then the bitwise-and is computed.
	/// 
	/// 
	/// 
	/// If an implementation does not have any multisample buffers available, or
	/// multisampling is disabled, rasterization occurs with only a single sample
	/// computing a pixel's final RGB color.
	/// 
	/// 
	/// 
	/// Provided an implementation supports multisample buffers, and multisampling
	/// is enabled, then a pixel's final color is generated by combining several
	/// samples per pixel. Each sample contains color, depth, and stencil
	/// information, allowing those operations to be performed on each sample.
	__gshared void function(GLclampf value, GLboolean invert) glSampleCoverage;
	/// Set the value of a sub-word of the sample mask.
	/// 
	/// glSampleMaski sets one 32-bit sub-word of the multi-word sample mask, GL_SAMPLE_MASK_VALUE.
	/// 
	/// 
	/// maskIndex specifies which 32-bit sub-word of the sample mask to update, and mask specifies
	/// the new value to use for that sub-word. maskIndex must be less than the value of
	/// GL_MAX_SAMPLE_MASK_WORDS. Bit B of mask word M corresponds to sample
	/// 32 x M + B.
	__gshared void function(GLuint maskNumber, GLbitfield mask) glSampleMaski;
	/// Set sampler parameters.
	/// 
	/// glSamplerParameter assigns the value or values in params to the sampler parameter
	/// specified as pname.
	/// sampler specifies the sampler object to be modified, and must be the name of a sampler object previously
	/// returned from a call to glGenSamplers.
	/// The following symbols are accepted in pname:
	/// 
	/// 
	/// 
	/// The texture minifying function is used whenever the pixel being textured
	/// maps to an area greater than one texture element.
	/// There are six defined minifying functions.
	/// Two of them use the nearest one or nearest four texture elements
	/// to compute the texture value.
	/// The other four use mipmaps.
	/// 
	/// 
	/// 
	/// A mipmap is an ordered set of arrays representing the same image
	/// at progressively lower resolutions.
	/// If the texture has dimensions 
	/// 2n2m,
	/// there are
	/// maxnm+1
	/// mipmaps.
	/// The first mipmap is the original texture,
	/// with dimensions 
	/// 2n2m.
	/// Each subsequent mipmap has dimensions 
	/// 2k-12l-1,
	/// where 
	/// 2k2l
	/// are the dimensions of the previous mipmap,
	/// until either 
	/// k=0
	/// or 
	/// l=0.
	/// At that point,
	/// subsequent mipmaps have dimension 
	/// 12l-1
	/// or 
	/// 2k-11
	/// until the final mipmap,
	/// which has dimension 
	/// 11.
	/// To define the mipmaps, call glTexImage1D, glTexImage2D,
	/// glTexImage3D,
	/// glCopyTexImage1D, or glCopyTexImage2D
	/// with the level argument indicating the order of the mipmaps.
	/// Level 0 is the original texture;
	/// level 
	/// maxnm
	/// is the final 
	/// 11
	/// mipmap.
	/// 
	/// 
	/// params supplies a function for minifying the texture as one of the
	/// following:
	/// GL_NEAREST
	/// Returns the value of the texture element that is nearest
	/// (in Manhattan distance)
	/// to the center of the pixel being textured.
	/// GL_LINEAR
	/// Returns the weighted average of the four texture elements
	/// that are closest to the center of the pixel being textured.
	/// These can include border texture elements,
	/// depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T,
	/// and on the exact mapping.
	/// GL_NEAREST_MIPMAP_NEAREST
	/// Chooses the mipmap that most closely matches the size of the pixel
	/// being textured and uses the GL_NEAREST criterion
	/// (the texture element nearest to the center of the pixel)
	/// to produce a texture value.
	/// GL_LINEAR_MIPMAP_NEAREST
	/// Chooses the mipmap that most closely matches the size of the pixel
	/// being textured and uses the GL_LINEAR criterion
	/// (a weighted average of the four texture elements that are closest
	/// to the center of the pixel)
	/// to produce a texture value.
	/// GL_NEAREST_MIPMAP_LINEAR
	/// Chooses the two mipmaps that most closely match the size of the pixel
	/// being textured and uses the GL_NEAREST criterion
	/// (the texture element nearest to the center of the pixel)
	/// to produce a texture value from each mipmap.
	/// The final texture value is a weighted average of those two values.
	/// GL_LINEAR_MIPMAP_LINEAR
	/// Chooses the two mipmaps that most closely match the size of the pixel
	/// being textured and uses the GL_LINEAR criterion
	/// (a weighted average of the four texture elements that are closest
	/// to the center of the pixel)
	/// to produce a texture value from each mipmap.
	/// The final texture value is a weighted average of those two values.
	/// 
	/// 
	/// 
	/// Returns the value of the texture element that is nearest
	/// (in Manhattan distance)
	/// to the center of the pixel being textured.
	/// 
	/// 
	/// 
	/// Returns the weighted average of the four texture elements
	/// that are closest to the center of the pixel being textured.
	/// These can include border texture elements,
	/// depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T,
	/// and on the exact mapping.
	/// 
	/// 
	/// 
	/// Chooses the mipmap that most closely matches the size of the pixel
	/// being textured and uses the GL_NEAREST criterion
	/// (the texture element nearest to the center of the pixel)
	/// to produce a texture value.
	/// 
	/// 
	/// 
	/// Chooses the mipmap that most closely matches the size of the pixel
	/// being textured and uses the GL_LINEAR criterion
	/// (a weighted average of the four texture elements that are closest
	/// to the center of the pixel)
	/// to produce a texture value.
	/// 
	/// 
	/// 
	/// Chooses the two mipmaps that most closely match the size of the pixel
	/// being textured and uses the GL_NEAREST criterion
	/// (the texture element nearest to the center of the pixel)
	/// to produce a texture value from each mipmap.
	/// The final texture value is a weighted average of those two values.
	/// 
	/// 
	/// 
	/// Chooses the two mipmaps that most closely match the size of the pixel
	/// being textured and uses the GL_LINEAR criterion
	/// (a weighted average of the four texture elements that are closest
	/// to the center of the pixel)
	/// to produce a texture value from each mipmap.
	/// The final texture value is a weighted average of those two values.
	/// 
	/// 
	/// 
	/// As more texture elements are sampled in the minification process,
	/// fewer aliasing artifacts will be apparent.
	/// While the GL_NEAREST and GL_LINEAR minification functions can be
	/// faster than the other four,
	/// they sample only one or four texture elements to determine the texture value
	/// of the pixel being rendered and can produce moire patterns
	/// or ragged transitions.
	/// The initial value of GL_TEXTURE_MIN_FILTER is
	/// GL_NEAREST_MIPMAP_LINEAR.
	/// 
	/// 
	/// 
	/// The texture magnification function is used when the pixel being textured
	/// maps to an area less than or equal to one texture element.
	/// It sets the texture magnification function to either GL_NEAREST
	/// or GL_LINEAR (see below). GL_NEAREST is generally faster
	/// than GL_LINEAR,
	/// but it can produce textured images with sharper edges
	/// because the transition between texture elements is not as smooth.
	/// The initial value of GL_TEXTURE_MAG_FILTER is GL_LINEAR.
	/// GL_NEAREST
	/// Returns the value of the texture element that is nearest
	/// (in Manhattan distance)
	/// to the center of the pixel being textured.
	/// GL_LINEAR
	/// Returns the weighted average of the four texture elements
	/// that are closest to the center of the pixel being textured.
	/// These can include border texture elements,
	/// depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T,
	/// and on the exact mapping.
	/// 
	/// 
	/// 
	/// Returns the value of the texture element that is nearest
	/// (in Manhattan distance)
	/// to the center of the pixel being textured.
	/// 
	/// 
	/// 
	/// Returns the weighted average of the four texture elements
	/// that are closest to the center of the pixel being textured.
	/// These can include border texture elements,
	/// depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T,
	/// and on the exact mapping.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the minimum level-of-detail parameter. This floating-point value
	/// limits the selection of highest resolution mipmap (lowest mipmap
	/// level). The initial value is -1000.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the maximum level-of-detail parameter. This floating-point value
	/// limits the selection of the lowest resolution mipmap (highest mipmap
	/// level). The initial value is 1000.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the wrap parameter for texture coordinate 
	/// s
	/// to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or
	/// GL_REPEAT. GL_CLAMP_TO_BORDER causes the 
	/// s
	/// coordinate to be clamped to the range
	/// -12N1+12N,
	/// where 
	/// N
	/// is the size of the texture in the direction of
	/// clamping.GL_CLAMP_TO_EDGE causes 
	/// s
	/// coordinates to be clamped to the
	/// range 
	/// 12N1-12N,
	/// where 
	/// N
	/// is the size
	/// of the texture in the direction of clamping. GL_REPEAT causes the
	/// integer part of the 
	/// s
	/// coordinate to be ignored; the GL uses only the
	/// fractional part, thereby creating a repeating pattern.
	/// GL_MIRRORED_REPEAT causes the 
	/// s
	/// coordinate to be set to the
	/// fractional part of the texture coordinate if the integer part of 
	/// s
	/// is
	/// even; if the integer part of 
	/// s
	/// is odd, then the 
	/// s
	/// texture coordinate is
	/// set to 
	/// 1-fracs,
	/// where 
	/// fracs
	/// represents the fractional part of
	/// s.
	/// Initially, GL_TEXTURE_WRAP_S is set to GL_REPEAT.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the wrap parameter for texture coordinate 
	/// t
	/// to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or
	/// GL_REPEAT. See the discussion under GL_TEXTURE_WRAP_S.
	/// Initially, GL_TEXTURE_WRAP_T is set to GL_REPEAT.
	/// 
	/// 
	/// 
	/// Sets the wrap parameter for texture coordinate 
	/// r
	/// to either GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or
	/// GL_REPEAT. See the discussion under GL_TEXTURE_WRAP_S.
	/// Initially, GL_TEXTURE_WRAP_R is set to GL_REPEAT.
	/// 
	/// 
	/// 
	/// The data in params specifies four values that define the border values that
	/// should be used for border texels. If a texel is sampled from the border of the texture, the
	/// values of GL_TEXTURE_BORDER_COLOR are interpreted as an RGBA color to match the
	/// texture's internal format and substituted for the non-existent texel data. If the texture contains depth
	/// components, the first component of GL_TEXTURE_BORDER_COLOR is interpreted as a depth value.
	/// The initial value is
	/// 0.0, 0.0, 0.0, 0.0.
	/// 
	/// 
	/// 
	/// Specifies the texture comparison mode for currently bound textures.
	/// That is, a texture whose internal format is GL_DEPTH_COMPONENT_*; see
	/// glTexImage2D
	/// Permissible values are:
	/// GL_COMPARE_REF_TO_TEXTURE
	/// Specifies that the interpolated and clamped 
	/// r
	/// texture coordinate should
	/// be compared to the value in the currently bound texture. See the
	/// discussion of GL_TEXTURE_COMPARE_FUNC for details of how the comparison
	/// is evaluated. The result of the comparison is assigned to the red channel.
	/// GL_NONE
	/// Specifies that the red channel should be assigned the
	/// appropriate value from the currently bound texture.
	/// 
	/// 
	/// 
	/// Specifies that the interpolated and clamped 
	/// r
	/// texture coordinate should
	/// be compared to the value in the currently bound texture. See the
	/// discussion of GL_TEXTURE_COMPARE_FUNC for details of how the comparison
	/// is evaluated. The result of the comparison is assigned to the red channel.
	/// 
	/// 
	/// 
	/// Specifies that the red channel should be assigned the
	/// appropriate value from the currently bound texture.
	/// 
	/// 
	/// 
	/// Specifies the comparison operator used when GL_TEXTURE_COMPARE_MODE is
	/// set to GL_COMPARE_REF_TO_TEXTURE. Permissible values are:
	/// 
	/// Texture Comparison Function
	/// 
	/// Computed result 
	/// GL_LEQUALresult=1.00.0r<=Dtr>DtGL_GEQUALresult=1.00.0r>=Dtr<DtGL_LESSresult=1.00.0r<Dtr>=DtGL_GREATERresult=1.00.0r>Dtr<=DtGL_EQUALresult=1.00.0r=DtrDtGL_NOTEQUALresult=1.00.0rDtr=DtGL_ALWAYSresult=1.0GL_NEVERresult=0.0
	/// where r
	/// is the current interpolated texture coordinate, and 
	/// Dt
	/// is the texture value sampled from the currently bound texture.
	/// result
	/// is assigned to
	/// Rt.
	__gshared void function(GLuint sampler, GLenum pname, GLfloat param) glSamplerParameterf;
	/// Ditto
	__gshared void function(GLuint sampler, GLenum pname, GLint param) glSamplerParameteri;
	/// Ditto
	__gshared void function(GLuint sampler, GLenum pname, const GLfloat * params) glSamplerParameterfv;
	/// Ditto
	__gshared void function(GLuint sampler, GLenum pname, const GLint * params) glSamplerParameteriv;
	/// Define the scissor box.
	/// 
	/// glScissor defines a rectangle, called the scissor box,
	/// in window coordinates.
	/// The first two arguments,
	/// x and y,
	/// specify the lower left corner of the box.
	/// width and height specify the width and height of the box.
	/// 
	/// 
	/// 
	/// To enable and disable the scissor test, call
	/// glEnable and glDisable with argument
	/// GL_SCISSOR_TEST. The test is initially disabled.
	/// While the test is enabled, only pixels that lie within the scissor box
	/// can be modified by drawing commands.
	/// Window coordinates have integer values at the shared corners of
	/// frame buffer pixels.
	/// glScissor(0,0,1,1) allows modification of only the lower left
	/// pixel in the window, and glScissor(0,0,0,0) doesn't allow
	/// modification of any pixels in the window.
	/// 
	/// 
	/// 
	/// When the scissor test is disabled,
	/// it is as though the scissor box includes the entire window.
	void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
	/// Define the scissor box for multiple viewports.
	/// 
	/// glScissorArrayv defines rectangles, called scissor boxes,
	/// in window coordinates for each viewport.
	/// first specifies the index of the first scissor box to modify and
	/// count specifies the number of scissor boxes to modify. first
	/// must be less than the value of GL_MAX_VIEWPORTS, and first +
	/// count must be less than or equal to the value of GL_MAX_VIEWPORTS.
	/// v specifies the address of an array containing integers specifying the
	/// lower left corner of the scissor boxes, and the width and height of the scissor boxes, in that order.
	/// 
	/// 
	/// 
	/// To enable and disable the scissor test, call
	/// glEnable and glDisable with argument
	/// GL_SCISSOR_TEST. The test is initially disabled for all viewports.
	/// While the test is enabled, only pixels that lie within the scissor box
	/// can be modified by drawing commands.
	/// Window coordinates have integer values at the shared corners of
	/// frame buffer pixels.
	/// glScissor(0,0,1,1) allows modification of only the lower left
	/// pixel in the window, and glScissor(0,0,0,0) doesn't allow
	/// modification of any pixels in the window.
	/// 
	/// 
	/// 
	/// When the scissor test is disabled,
	/// it is as though the scissor box includes the entire window.
	__gshared void function(GLuint first, GLsizei count, const GLint* v) glScissorArrayv;
	/// Define the scissor box for a specific viewport.
	/// 
	/// glScissorIndexed defines the scissor box for a specified viewport.
	/// index specifies the index of scissor box to modify.
	/// index must be less than the value of GL_MAX_VIEWPORTS.
	/// For glScissorIndexed, left, bottom,
	/// width and height specify the left, bottom, width
	/// and height of the scissor box, in pixels, respectively.
	/// For glScissorIndexedv, v specifies the address of an
	/// array containing integers specifying the lower left corner of the scissor box, and the width and
	/// height of the scissor box, in that order.
	/// 
	/// 
	/// 
	/// To enable and disable the scissor test, call
	/// glEnable and glDisable with argument
	/// GL_SCISSOR_TEST. The test is initially disabled for all viewports.
	/// While the test is enabled, only pixels that lie within the scissor box
	/// can be modified by drawing commands.
	/// Window coordinates have integer values at the shared corners of
	/// frame buffer pixels.
	/// glScissor(0,0,1,1) allows modification of only the lower left
	/// pixel in the window, and glScissor(0,0,0,0) doesn't allow
	/// modification of any pixels in the window.
	/// 
	/// 
	/// 
	/// When the scissor test is disabled,
	/// it is as though the scissor box includes the entire window.
	__gshared void function(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) glScissorIndexed;
	/// Ditto
	__gshared void function(GLuint index, const GLint* v) glScissorIndexedv;
	/// Load pre-compiled shader binaries.
	/// 
	/// glShaderBinary loads pre-compiled shader binary code into the count
	/// shader objects whose handles are given in shaders. binary
	/// points to length bytes of binary shader code stored in client memory.
	/// binaryFormat specifies the format of the pre-compiled code.
	/// 
	/// 
	/// 
	/// The binary image contained in binary will be decoded according to the extension
	/// specification defining the specified binaryFormat token. OpenGL
	/// does not define any specific binary formats, but it does provide a mechanism to obtain token
	/// vaues for such formats provided by such extensions.
	/// 
	/// 
	/// 
	/// Depending on the types of the shader objects in shaders, glShaderBinary
	/// will individually load binary vertex or fragment shaders, or load an executable binary that contains an optimized
	/// pair of vertex and fragment shaders stored in the same binary.
	__gshared void function(GLsizei count, const GLuint* shaders, GLenum binaryFormat, const void* binary, GLsizei length) glShaderBinary;
	/// Replaces the source code in a shader object.
	/// 
	/// glShaderSource sets the source code
	/// in shader to the source code in the array
	/// of strings specified by string. Any
	/// source code previously stored in the shader object is completely
	/// replaced. The number of strings in the array is specified by
	/// count. If length
	/// is NULL, each string is assumed to be null
	/// terminated. If length is a value other
	/// than NULL, it points to an array containing
	/// a string length for each of the corresponding elements of
	/// string. Each element in the
	/// length array may contain the length of
	/// the corresponding string (the null character is not counted as
	/// part of the string length) or a value less than 0 to indicate
	/// that the string is null terminated. The source code strings are
	/// not scanned or parsed at this time; they are simply copied into
	/// the specified shader object.
	__gshared void function(GLuint shader, GLsizei count, const GLchar** string, const GLint* length) glShaderSource;
	/// Set front and back function and reference value for stencil testing.
	/// 
	/// Stenciling,
	/// like depth-buffering,
	/// enables and disables drawing on a per-pixel basis.
	/// Stencil planes are first drawn into using GL drawing primitives, then
	/// geometry and images are rendered using the stencil planes to mask out
	/// portions of the screen.
	/// Stenciling is typically used in multipass rendering algorithms
	/// to achieve special effects,
	/// such as decals,
	/// outlining,
	/// and constructive solid geometry rendering.
	/// 
	/// 
	/// 
	/// The stencil test conditionally eliminates a pixel based on the outcome
	/// of a comparison between the reference value
	/// and the value in the stencil buffer.
	/// To enable and disable the test, call glEnable and glDisable
	/// with argument GL_STENCIL_TEST.
	/// To specify actions based on the outcome of the stencil test, call
	/// glStencilOp or 
	/// glStencilOpSeparate.
	/// 
	/// 
	/// 
	/// There can be two separate sets of func, ref, and 
	/// mask parameters; one affects back-facing polygons, and the other
	/// affects front-facing polygons as well as other non-polygon primitives. 
	/// glStencilFunc sets both front
	/// and back stencil state to the same values. Use glStencilFuncSeparate
	/// to set front and back stencil state to different values.
	/// 
	/// 
	/// func is a symbolic constant that determines the stencil comparison function.
	/// It accepts one of eight values,
	/// shown in the following list.
	/// ref is an integer reference value that is used in the stencil comparison.
	/// It is clamped to the range 
	/// 02n-1,
	/// where 
	/// n
	/// is the number of bitplanes in the stencil buffer.
	/// mask is bitwise ANDed with both the reference value
	/// and the stored stencil value,
	/// with the ANDed values participating in the comparison.
	/// 
	/// 
	/// 
	/// If stencil represents the value stored in the corresponding
	/// stencil buffer location,
	/// the following list shows the effect of each comparison function
	/// that can be specified by func.
	/// Only if the comparison succeeds is the pixel passed through
	/// to the next stage in the rasterization process
	/// (see glStencilOp).
	/// All tests treat stencil values as unsigned integers in the range
	/// 02n-1,
	/// where 
	/// n
	/// is the number of bitplanes in the stencil buffer.
	/// 
	/// 
	/// 
	/// The following values are accepted by func:
	/// 
	/// 
	/// 
	/// Always fails.
	/// 
	/// 
	/// 
	/// Passes if ( ref & mask ) < ( stencil & mask ).
	/// 
	/// 
	/// 
	/// Passes if ( ref & mask ) <= ( stencil & mask ).
	/// 
	/// 
	/// 
	/// Passes if ( ref & mask ) > ( stencil & mask ).
	/// 
	/// 
	/// 
	/// Passes if ( ref & mask ) >= ( stencil & mask ).
	/// 
	/// 
	/// 
	/// Passes if ( ref & mask ) = ( stencil & mask ).
	/// 
	/// 
	/// 
	/// Passes if ( ref & mask ) != ( stencil & mask ).
	/// 
	/// 
	/// 
	/// Always passes.
	void glStencilFunc(GLenum func, GLint _ref, GLuint mask);
	/// Set front and/or back function and reference value for stencil testing.
	/// 
	/// Stenciling,
	/// like depth-buffering,
	/// enables and disables drawing on a per-pixel basis.
	/// You draw into the stencil planes using GL drawing primitives,
	/// then render geometry and images,
	/// using the stencil planes to mask out portions of the screen.
	/// Stenciling is typically used in multipass rendering algorithms
	/// to achieve special effects,
	/// such as decals,
	/// outlining,
	/// and constructive solid geometry rendering.
	/// 
	/// 
	/// 
	/// The stencil test conditionally eliminates a pixel based on the outcome
	/// of a comparison between the reference value
	/// and the value in the stencil buffer.
	/// To enable and disable the test, call glEnable and glDisable
	/// with argument GL_STENCIL_TEST.
	/// To specify actions based on the outcome of the stencil test, call
	/// glStencilOp or 
	/// glStencilOpSeparate.
	/// 
	/// 
	/// 
	/// There can be two separate sets of func, ref, and 
	/// mask parameters; one affects back-facing polygons, and the other
	/// affects front-facing polygons as well as other non-polygon primitives. 
	/// glStencilFunc sets both front
	/// and back stencil state to the same values, as if 
	/// glStencilFuncSeparate were called
	/// with face set to GL_FRONT_AND_BACK.
	/// 
	/// 
	/// func is a symbolic constant that determines the stencil comparison function.
	/// It accepts one of eight values,
	/// shown in the following list.
	/// ref is an integer reference value that is used in the stencil comparison.
	/// It is clamped to the range 
	/// 02n-1,
	/// where 
	/// n
	/// is the number of bitplanes in the stencil buffer.
	/// mask is bitwise ANDed with both the reference value
	/// and the stored stencil value,
	/// with the ANDed values participating in the comparison.
	/// 
	/// 
	/// 
	/// If stencil represents the value stored in the corresponding
	/// stencil buffer location,
	/// the following list shows the effect of each comparison function
	/// that can be specified by func.
	/// Only if the comparison succeeds is the pixel passed through
	/// to the next stage in the rasterization process
	/// (see glStencilOp).
	/// All tests treat stencil values as unsigned integers in the range
	/// 02n-1,
	/// where 
	/// n
	/// is the number of bitplanes in the stencil buffer.
	/// 
	/// 
	/// 
	/// The following values are accepted by func:
	/// 
	/// 
	/// 
	/// Always fails.
	/// 
	/// 
	/// 
	/// Passes if ( ref & mask ) < ( stencil & mask ).
	/// 
	/// 
	/// 
	/// Passes if ( ref & mask ) <= ( stencil & mask ).
	/// 
	/// 
	/// 
	/// Passes if ( ref & mask ) > ( stencil & mask ).
	/// 
	/// 
	/// 
	/// Passes if ( ref & mask ) >= ( stencil & mask ).
	/// 
	/// 
	/// 
	/// Passes if ( ref & mask ) = ( stencil & mask ).
	/// 
	/// 
	/// 
	/// Passes if ( ref & mask ) != ( stencil & mask ).
	/// 
	/// 
	/// 
	/// Always passes.
	__gshared void function(GLenum face, GLenum func, GLint _ref, GLuint mask) glStencilFuncSeparate;
	/// Control the front and back writing of individual bits in the stencil planes.
	/// 
	/// glStencilMask controls the writing of individual bits in the stencil planes.
	/// The least significant 
	/// n
	/// bits of mask,
	/// where 
	/// n
	/// is the number of bits in the stencil buffer,
	/// specify a mask.
	/// Where a 1 appears in the mask,
	/// it's possible to write to the corresponding bit in the stencil buffer.
	/// Where a 0 appears,
	/// the corresponding bit is write-protected.
	/// Initially, all bits are enabled for writing.
	/// 
	/// 
	/// 
	/// There can be two separate mask writemasks; one affects back-facing polygons, and the other
	/// affects front-facing polygons as well as other non-polygon primitives. 
	/// glStencilMask sets both front
	/// and back stencil writemasks to the same values. Use glStencilMaskSeparate
	/// to set front and back stencil writemasks to different values.
	void glStencilMask(GLuint mask);
	/// Control the front and/or back writing of individual bits in the stencil planes.
	/// 
	/// glStencilMaskSeparate controls the writing of individual bits in the stencil planes.
	/// The least significant 
	/// n
	/// bits of mask,
	/// where 
	/// n
	/// is the number of bits in the stencil buffer,
	/// specify a mask.
	/// Where a 1 appears in the mask,
	/// it's possible to write to the corresponding bit in the stencil buffer.
	/// Where a 0 appears,
	/// the corresponding bit is write-protected.
	/// Initially, all bits are enabled for writing.
	/// 
	/// 
	/// 
	/// There can be two separate mask writemasks; one affects back-facing polygons, and the other
	/// affects front-facing polygons as well as other non-polygon primitives. 
	/// glStencilMask sets both front
	/// and back stencil writemasks to the same values, as if
	/// glStencilMaskSeparate were called
	/// with face set to GL_FRONT_AND_BACK.
	__gshared void function(GLenum face, GLuint mask) glStencilMaskSeparate;
	/// Set front and back stencil test actions.
	/// 
	/// Stenciling,
	/// like depth-buffering,
	/// enables and disables drawing on a per-pixel basis.
	/// You draw into the stencil planes using GL drawing primitives,
	/// then render geometry and images,
	/// using the stencil planes to mask out portions of the screen.
	/// Stenciling is typically used in multipass rendering algorithms
	/// to achieve special effects,
	/// such as decals,
	/// outlining,
	/// and constructive solid geometry rendering.
	/// 
	/// 
	/// 
	/// The stencil test conditionally eliminates a pixel based on the outcome
	/// of a comparison between the value in the stencil buffer and a
	/// reference value. To enable and disable the test, call glEnable
	/// and glDisable with argument
	/// GL_STENCIL_TEST; to control it, call 
	/// glStencilFunc or 
	/// glStencilFuncSeparate.
	/// 
	/// 
	/// 
	/// There can be two separate sets of sfail, dpfail, and 
	/// dppass parameters; one affects back-facing polygons, and the other
	/// affects front-facing polygons as well as other non-polygon primitives. 
	/// glStencilOp sets both front
	/// and back stencil state to the same values. Use glStencilOpSeparate
	/// to set front and back stencil state to different values.
	/// 
	/// 
	/// glStencilOp takes three arguments that indicate what happens
	/// to the stored stencil value while stenciling is enabled.
	/// If the stencil test fails,
	/// no change is made to the pixel's color or depth buffers,
	/// and sfail specifies what happens to the stencil buffer contents.
	/// The following eight actions are possible.
	/// 
	/// 
	/// 
	/// Keeps the current value.
	/// 
	/// 
	/// 
	/// Sets the stencil buffer value to 0.
	/// 
	/// 
	/// 
	/// Sets the stencil buffer value to ref,
	/// as specified by glStencilFunc.
	/// 
	/// 
	/// 
	/// Increments the current stencil buffer value.
	/// Clamps to the maximum representable unsigned value.
	/// 
	/// 
	/// 
	/// Increments the current stencil buffer value.
	/// Wraps stencil buffer value to zero when incrementing the maximum
	/// representable unsigned value.
	/// 
	/// 
	/// 
	/// Decrements the current stencil buffer value.
	/// Clamps to 0.
	/// 
	/// 
	/// 
	/// Decrements the current stencil buffer value.
	/// Wraps stencil buffer value to the maximum representable unsigned value when
	/// decrementing a stencil buffer value of zero.
	/// 
	/// 
	/// 
	/// Bitwise inverts the current stencil buffer value.
	/// 
	/// 
	/// 
	/// Stencil buffer values are treated as unsigned integers.
	/// When incremented and decremented,
	/// values are clamped to 0 and 
	/// 2n-1,
	/// where 
	/// n
	/// is the value returned by querying GL_STENCIL_BITS.
	/// 
	/// 
	/// 
	/// The other two arguments to glStencilOp specify stencil buffer actions
	/// that depend on whether subsequent depth buffer tests succeed (dppass)
	/// or fail (dpfail) (see
	/// glDepthFunc).
	/// The actions are specified using the same eight symbolic constants as sfail.
	/// Note that dpfail is ignored when there is no depth buffer,
	/// or when the depth buffer is not enabled.
	/// In these cases, sfail and dppass specify stencil action when the
	/// stencil test fails and passes,
	/// respectively.
	void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);
	/// Set front and/or back stencil test actions.
	/// 
	/// Stenciling,
	/// like depth-buffering,
	/// enables and disables drawing on a per-pixel basis.
	/// You draw into the stencil planes using GL drawing primitives,
	/// then render geometry and images,
	/// using the stencil planes to mask out portions of the screen.
	/// Stenciling is typically used in multipass rendering algorithms
	/// to achieve special effects,
	/// such as decals,
	/// outlining,
	/// and constructive solid geometry rendering.
	/// 
	/// 
	/// 
	/// The stencil test conditionally eliminates a pixel based on the outcome
	/// of a comparison between the value in the stencil buffer and a
	/// reference value. To enable and disable the test, call glEnable
	/// and glDisable with argument
	/// GL_STENCIL_TEST; to control it, call 
	/// glStencilFunc or 
	/// glStencilFuncSeparate.
	/// 
	/// 
	/// 
	/// There can be two separate sets of sfail, dpfail, and 
	/// dppass parameters; one affects back-facing polygons, and the other
	/// affects front-facing polygons as well as other non-polygon primitives. 
	/// glStencilOp sets both front
	/// and back stencil state to the same values, as if 
	/// glStencilOpSeparate were called
	/// with face set to GL_FRONT_AND_BACK.
	/// 
	/// 
	/// glStencilOpSeparate takes three arguments that indicate what happens
	/// to the stored stencil value while stenciling is enabled.
	/// If the stencil test fails,
	/// no change is made to the pixel's color or depth buffers,
	/// and sfail specifies what happens to the stencil buffer contents.
	/// The following eight actions are possible.
	/// 
	/// 
	/// 
	/// Keeps the current value.
	/// 
	/// 
	/// 
	/// Sets the stencil buffer value to 0.
	/// 
	/// 
	/// 
	/// Sets the stencil buffer value to ref,
	/// as specified by glStencilFunc.
	/// 
	/// 
	/// 
	/// Increments the current stencil buffer value.
	/// Clamps to the maximum representable unsigned value.
	/// 
	/// 
	/// 
	/// Increments the current stencil buffer value.
	/// Wraps stencil buffer value to zero when incrementing the maximum
	/// representable unsigned value.
	/// 
	/// 
	/// 
	/// Decrements the current stencil buffer value.
	/// Clamps to 0.
	/// 
	/// 
	/// 
	/// Decrements the current stencil buffer value.
	/// Wraps stencil buffer value to the maximum representable unsigned value when
	/// decrementing a stencil buffer value of zero.
	/// 
	/// 
	/// 
	/// Bitwise inverts the current stencil buffer value.
	/// 
	/// 
	/// 
	/// Stencil buffer values are treated as unsigned integers.
	/// When incremented and decremented,
	/// values are clamped to 0 and 
	/// 2n-1,
	/// where 
	/// n
	/// is the value returned by querying GL_STENCIL_BITS.
	/// 
	/// 
	/// 
	/// The other two arguments to glStencilOpSeparate specify stencil buffer actions
	/// that depend on whether subsequent depth buffer tests succeed (dppass)
	/// or fail (dpfail) (see
	/// glDepthFunc).
	/// The actions are specified using the same eight symbolic constants as sfail.
	/// Note that dpfail is ignored when there is no depth buffer,
	/// or when the depth buffer is not enabled.
	/// In these cases, sfail and dppass specify stencil action when the
	/// stencil test fails and passes,
	/// respectively.
	__gshared void function(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) glStencilOpSeparate;
	/// Attach the storage for a buffer object to the active buffer texture.
	/// 
	/// glTexBuffer attaches the storage for the buffer object named buffer to the active
	/// buffer texture, and specifies the internal format for the texel array found in the attached buffer object. If buffer
	/// is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If buffer
	/// is non-zero, it must be the name of an existing buffer object. target must be GL_TEXTURE_BUFFER.
	/// internalformat specifies the storage format, and must be one of the following sized internal formats:
	/// 
	/// 
	/// 
	/// When a buffer object is attached to a buffer texture, the buffer object's data store
	/// is taken as the texture's texel array. The number of texels in the buffer texture's
	/// texel array is given by
	/// 
	/// 
	/// 
	/// where buffer_size is the size of the buffer object, in basic machine units and
	/// components and base type are the element count and base data type for elements, as specified in the table above.
	/// The number of texels in the texel array is then clamped to the implementation-dependent limit GL_MAX_TEXTURE_BUFFER_SIZE.
	/// When a buffer texture is accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or
	/// greater than or equal to the clamped number of texels in the texel array.
	__gshared void function(GLenum target, GLenum internalFormat) glTexBuffer;
	/// Specify a one-dimensional texture image.
	/// 
	/// Texturing maps a portion of a specified texture image
	/// onto each graphical primitive for which texturing is enabled.
	/// To enable and disable one-dimensional texturing, call glEnable
	/// and glDisable with argument GL_TEXTURE_1D.
	/// 
	/// 
	/// 
	/// Texture images are defined with glTexImage1D.
	/// The arguments describe the parameters of the texture image,
	/// such as width,
	/// width of the border,
	/// level-of-detail number
	/// (see glTexParameter),
	/// and the internal resolution and format used to store the image.
	/// The last three arguments describe how the image is represented in
	/// memory.
	/// 
	/// 
	/// 
	/// If target is GL_PROXY_TEXTURE_1D, no data is read from data, but
	/// all of the texture image state is recalculated, checked for
	/// consistency, and checked against the implementation's capabilities.
	/// If the implementation cannot handle a texture of the
	/// requested texture size, it sets all of the image state to 0,
	/// but does not generate an error (see glGetError). To query for an
	/// entire mipmap array, use an image array level greater than or equal to
	/// 1.
	/// 
	/// 
	/// 
	/// If target is GL_TEXTURE_1D,
	/// data is read from data as a sequence of signed or unsigned bytes,
	/// shorts,
	/// or longs,
	/// or single-precision floating-point values,
	/// depending on type.
	/// These values are grouped into sets of one,
	/// two,
	/// three,
	/// or four values,
	/// depending on format,
	/// to form elements.
	/// Each data byte is treated as eight 1-bit elements,
	/// with bit ordering determined by GL_UNPACK_LSB_FIRST
	/// (see glPixelStore).
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// specified, data is treated as a byte offset into the buffer object's data store.
	/// 
	/// 
	/// 
	/// The first element corresponds to the left end of the texture array.
	/// Subsequent elements progress left-to-right through the remaining texels
	/// in the texture array.
	/// The final element corresponds to the right end of the texture array.
	/// 
	/// 
	/// format determines the composition of each element in data.
	/// It can assume one of these symbolic values:
	/// 
	/// 
	/// 
	/// Each element is a single red component.
	/// The GL converts it to floating point and assembles it into an RGBA element
	/// by attaching 0 for green and blue, and 1 for alpha.
	/// Each component is then multiplied by the signed scale factor GL_c_SCALE,
	/// added to the signed bias GL_c_BIAS,
	/// and clamped to the range [0,1].
	/// 
	/// 
	/// 
	/// Each element is a single red/green double
	/// The GL converts it to floating point and assembles it into an RGBA element
	/// by attaching 0 for blue, and 1 for alpha.
	/// Each component is then multiplied by the signed scale factor GL_c_SCALE,
	/// added to the signed bias GL_c_BIAS,
	/// and clamped to the range [0,1].
	/// 
	/// 
	/// 
	/// Each element is an RGB triple.
	/// The GL converts it to floating point and assembles it into an RGBA element
	/// by attaching 1 for alpha.
	/// Each component is then multiplied by the signed scale factor GL_c_SCALE,
	/// added to the signed bias GL_c_BIAS,
	/// and clamped to the range [0,1].
	/// 
	/// 
	/// 
	/// Each element contains all four components.
	/// Each component is multiplied by the signed scale factor GL_c_SCALE,
	/// added to the signed bias GL_c_BIAS,
	/// and clamped to the range [0,1].
	/// 
	/// 
	/// 
	/// Each element is a single depth value.
	/// The GL converts it to floating point, multiplies by the signed scale factor
	/// GL_DEPTH_SCALE, adds the signed bias GL_DEPTH_BIAS,
	/// and clamps to the range [0,1].
	/// 
	/// 
	/// 
	/// If an application wants to store the texture at a certain
	/// resolution or in a certain format, it can request the resolution
	/// and format with internalFormat. The GL will choose an internal
	/// representation that closely approximates that requested by internalFormat, but
	/// it may not match exactly.
	/// (The representations specified by GL_RED, GL_RG,
	/// GL_RGB and GL_RGBA must match exactly.)
	/// 
	/// 
	/// internalFormat may be one of the base internal formats shown in
	/// Table 1, below
	/// 
	/// 
	/// 
	/// 
	/// internalFormat may also be one of the sized internal formats
	/// shown in Table 2, below
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Finally, internalFormat may also be one of the generic or compressed
	/// compressed texture formats shown in Table 3 below
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If the internalFormat parameter is one of the generic compressed formats,
	/// GL_COMPRESSED_RED, GL_COMPRESSED_RG,
	/// GL_COMPRESSED_RGB, or
	/// GL_COMPRESSED_RGBA, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.
	/// 
	/// 
	/// 
	/// If the internalFormat parameter is 
	/// GL_SRGB,
	/// GL_SRGB8,
	/// GL_SRGB_ALPHAor
	/// GL_SRGB8_ALPHA8, the texture is treated as if the red, green, or blue components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component 
	/// cs
	/// to a linear component 
	/// cl
	/// is:
	/// 
	/// 
	/// cl={cs12.92ifcs0.04045(cs+0.0551.055)2.4ifcs>0.04045
	/// 
	/// 
	/// Assume 
	/// cs
	/// is the sRGB component in the range [0,1].
	/// 
	/// 
	/// 
	/// Use the GL_PROXY_TEXTURE_1D target to try out a resolution and
	/// format. The implementation will
	/// update and recompute its best match for the requested storage resolution
	/// and format. To then query this state, call glGetTexLevelParameter.
	/// If the texture cannot be accommodated, texture state is set to 0.
	/// 
	/// 
	/// 
	/// A one-component texture image uses only the red component of the RGBA
	/// color from data.
	/// A two-component image uses the R and A values.
	/// A three-component image uses the R, G, and B values.
	/// A four-component image uses all of the RGBA components.
	/// 
	/// 
	/// 
	/// Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result. See glTexParameter for details on texture comparison.
	void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * data);
	/// Specify a two-dimensional texture image.
	/// 
	/// Texturing allows elements of an image array to be read by shaders.
	/// 
	/// 
	/// 
	/// To define texture images, call glTexImage2D.
	/// The arguments describe the parameters of the texture image,
	/// such as height, width, width of the border, level-of-detail number
	/// (see glTexParameter),
	/// and number of color components provided.
	/// The last three arguments describe how the image is represented in memory.
	/// 
	/// 
	/// 
	/// If target is GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY,
	/// GL_PROXY_TEXTURE_CUBE_MAP, or GL_PROXY_TEXTURE_RECTANGLE,
	/// no data is read from data, but
	/// all of the texture image state is recalculated, checked for
	/// consistency, and checked
	/// against the implementation's capabilities. If the implementation cannot
	/// handle a texture of the requested texture size, it sets
	/// all of the image state to 0,
	/// but does not generate an error (see glGetError). To query for an
	/// entire mipmap array, use an image array level greater than or equal to 1.
	/// 
	/// 
	/// 
	/// If target is GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE
	/// or one of the GL_TEXTURE_CUBE_MAP
	/// targets, data is read from data as a sequence of signed or unsigned
	/// bytes, shorts, or longs, or single-precision floating-point values,
	/// depending on type. These values are grouped into sets of one, two,
	/// three, or four values, depending on format, to form elements.
	/// Each data byte is treated as eight 1-bit elements,
	/// with bit ordering determined by GL_UNPACK_LSB_FIRST
	/// (see glPixelStore).
	/// 
	/// 
	/// 
	/// If target is GL_TEXTURE_1D_ARRAY, data is interpreted
	/// as an array of one-dimensional images.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// specified, data is treated as a byte offset into the buffer object's data store.
	/// 
	/// 
	/// 
	/// The first element corresponds to the lower left corner of the texture image.
	/// Subsequent elements progress left-to-right through the remaining texels
	/// in the lowest row of the texture image, and then in successively higher
	/// rows of the texture image.
	/// The final element corresponds to the upper right corner of the texture
	/// image.
	/// 
	/// 
	/// format determines the composition of each element in data.
	/// It can assume one of these symbolic values:
	/// 
	/// 
	/// 
	/// Each element is a single red component.
	/// The GL converts it to floating point and assembles it into an RGBA element
	/// by attaching 0 for green and blue, and 1 for alpha.
	/// Each component is then multiplied by the signed scale factor GL_c_SCALE,
	/// added to the signed bias GL_c_BIAS,
	/// and clamped to the range [0,1].
	/// 
	/// 
	/// 
	/// Each element is a red/green double.
	/// The GL converts it to floating point and assembles it into an RGBA element
	/// by attaching 0 for blue, and 1 for alpha.
	/// Each component is then multiplied by the signed scale factor GL_c_SCALE,
	/// added to the signed bias GL_c_BIAS,
	/// and clamped to the range [0,1].
	/// 
	/// 
	/// 
	/// Each element is an RGB triple.
	/// The GL converts it to floating point and assembles it into an RGBA element
	/// by attaching 1 for alpha.
	/// Each component is then multiplied by the signed scale factor GL_c_SCALE,
	/// added to the signed bias GL_c_BIAS,
	/// and clamped to the range [0,1].
	/// 
	/// 
	/// 
	/// Each element contains all four components.
	/// Each component is multiplied by the signed scale factor GL_c_SCALE,
	/// added to the signed bias GL_c_BIAS,
	/// and clamped to the range [0,1].
	/// 
	/// 
	/// 
	/// Each element is a single depth value.
	/// The GL converts it to floating point, multiplies by the signed scale factor
	/// GL_DEPTH_SCALE, adds the signed bias GL_DEPTH_BIAS,
	/// and clamps to the range [0,1].
	/// 
	/// 
	/// 
	/// Each element is a pair of depth and stencil values. The depth component of
	/// the pair is interpreted as in GL_DEPTH_COMPONENT. The stencil
	/// component is interpreted based on specified the depth + stencil internal format.
	/// 
	/// 
	/// 
	/// If an application wants to store the texture at a certain
	/// resolution or in a certain format, it can request the resolution
	/// and format with internalFormat. The GL will choose an internal
	/// representation that closely approximates that requested by internalFormat, but
	/// it may not match exactly.
	/// (The representations specified by GL_RED,
	/// GL_RG, GL_RGB,
	/// and GL_RGBA must match exactly.)
	/// 
	/// 
	/// internalFormat may be one of the base internal formats shown in
	/// Table 1, below
	/// 
	/// 
	/// 
	/// 
	/// internalFormat may also be one of the sized internal formats
	/// shown in Table 2, below
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Finally, internalFormat may also be one of the generic or compressed
	/// compressed texture formats shown in Table 3 below
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If the internalFormat parameter is one of the generic compressed formats,
	/// GL_COMPRESSED_RED, GL_COMPRESSED_RG,
	/// GL_COMPRESSED_RGB, or
	/// GL_COMPRESSED_RGBA, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.
	/// 
	/// 
	/// 
	/// If the internalFormat parameter is 
	/// GL_SRGB,
	/// GL_SRGB8,
	/// GL_SRGB_ALPHA, or
	/// GL_SRGB8_ALPHA8, the texture is treated as if the red, green, or blue components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component 
	/// cs
	/// to a linear component 
	/// cl
	/// is:
	/// 
	/// 
	/// cl={cs12.92ifcs0.04045(cs+0.0551.055)2.4ifcs>0.04045
	/// 
	/// 
	/// Assume 
	/// cs
	/// is the sRGB component in the range [0,1].
	/// 
	/// 
	/// 
	/// Use the GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY,
	/// GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP target to try out a resolution and
	/// format. The implementation will
	/// update and recompute its best match for the requested storage resolution
	/// and format. To then query this state, call glGetTexLevelParameter.
	/// If the texture cannot be accommodated, texture state is set to 0.
	/// 
	/// 
	/// 
	/// A one-component texture image uses only the red component of the RGBA
	/// color extracted from data.
	/// A two-component image uses the R and G values.
	/// A three-component image uses the R, G, and B values.
	/// A four-component image uses all of the RGBA components.
	/// 
	/// 
	/// 
	/// Image-based shadowing can be enabled by comparing texture r coordinates to
	/// depth texture values to generate a boolean result.
	/// See glTexParameter for details on texture comparison.
	void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * data);
	/// Establish the data storage, format, dimensions, and number of samples of a multisample texture's image.
	/// 
	/// glTexImage2DMultisample establishes the data storage, format, dimensions and number of samples of a multisample texture's image.
	/// 
	/// 
	/// target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE.
	/// width and height are the dimensions in texels of the texture, and must be in the range zero
	/// to GL_MAX_TEXTURE_SIZE - 1. samples specifies the number of samples in the image and must be
	/// in the range zero to GL_MAX_SAMPLES - 1.
	/// 
	/// 
	/// internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.
	/// 
	/// 
	/// 
	/// If fixedsamplelocations is GL_TRUE, the image will use identical sample locations and the same
	/// number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
	/// 
	/// 
	/// 
	/// When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer
	/// corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the
	/// multisample texture targets.
	__gshared void function(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) glTexImage2DMultisample;
	/// Specify a three-dimensional texture image.
	/// 
	/// Texturing maps a portion of a specified texture image
	/// onto each graphical primitive for which texturing is enabled.
	/// To enable and disable three-dimensional texturing, call glEnable
	/// and glDisable with argument GL_TEXTURE_3D.
	/// 
	/// 
	/// 
	/// To define texture images, call glTexImage3D.
	/// The arguments describe the parameters of the texture image,
	/// such as height,
	/// width, depth,
	/// width of the border,
	/// level-of-detail number
	/// (see glTexParameter),
	/// and number of color components provided.
	/// The last three arguments describe how the image is represented in memory.
	/// 
	/// 
	/// 
	/// If target is GL_PROXY_TEXTURE_3D, no data is read from data, but
	/// all of the texture image state is recalculated, checked for
	/// consistency, and checked
	/// against the implementation's capabilities. If the implementation cannot
	/// handle a texture of the requested texture size, it sets
	/// all of the image state to 0,
	/// but does not generate an error (see glGetError). To query for an
	/// entire mipmap array, use an image array level greater than or equal to
	/// 1.
	/// 
	/// 
	/// 
	/// If target is GL_TEXTURE_3D,
	/// data is read from data as a sequence of signed or unsigned bytes,
	/// shorts,
	/// or longs,
	/// or single-precision floating-point values,
	/// depending on type.
	/// These values are grouped into sets of one,
	/// two,
	/// three,
	/// or four values,
	/// depending on format,
	/// to form elements.
	/// Each data byte is treated as eight 1-bit elements,
	/// with bit ordering determined by GL_UNPACK_LSB_FIRST
	/// (see glPixelStore).
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// specified, data is treated as a byte offset into the buffer object's data store.
	/// 
	/// 
	/// 
	/// The first element corresponds to the lower left corner of the texture
	/// image.
	/// Subsequent elements progress left-to-right through the remaining texels
	/// in the lowest row of the texture image, and then in successively higher
	/// rows of the texture image.
	/// The final element corresponds to the upper right corner of the texture
	/// image.
	/// 
	/// 
	/// format determines the composition of each element in data.
	/// It can assume one of these symbolic values:
	/// 
	/// 
	/// 
	/// Each element is a single red component.
	/// The GL converts it to floating point and assembles it into an RGBA element
	/// by attaching 0 for green and blue, and 1 for alpha.
	/// Each component is then multiplied by the signed scale factor GL_c_SCALE,
	/// added to the signed bias GL_c_BIAS,
	/// and clamped to the range [0,1].
	/// 
	/// 
	/// 
	/// Each element is a red and green pair.
	/// The GL converts each to floating point and assembles it into an RGBA element
	/// by attaching 0 for blue, and 1 for alpha.
	/// Each component is then multiplied by the signed scale factor GL_c_SCALE,
	/// added to the signed bias GL_c_BIAS,
	/// and clamped to the range [0,1].
	/// 
	/// 
	/// 
	/// Each element is an RGB triple.
	/// The GL converts it to floating point and assembles it into an RGBA element
	/// by attaching 1 for alpha.
	/// Each component is then multiplied by the signed scale factor GL_c_SCALE,
	/// added to the signed bias GL_c_BIAS,
	/// and clamped to the range [0,1].
	/// 
	/// 
	/// 
	/// Each element contains all four components.
	/// Each component is multiplied by the signed scale factor GL_c_SCALE,
	/// added to the signed bias GL_c_BIAS,
	/// and clamped to the range [0,1].
	/// 
	/// 
	/// 
	/// If an application wants to store the texture at a certain
	/// resolution or in a certain format, it can request the resolution
	/// and format with internalFormat. The GL will choose an internal
	/// representation that closely approximates that requested by internalFormat, but
	/// it may not match exactly.
	/// (The representations specified by GL_RED, GL_RG, GL_RGB,
	/// and GL_RGBA must match exactly.)
	/// 
	/// 
	/// internalFormat may be one of the base internal formats shown in
	/// Table 1, below
	/// 
	/// 
	/// 
	/// 
	/// internalFormat may also be one of the sized internal formats
	/// shown in Table 2, below
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Finally, internalFormat may also be one of the generic or compressed
	/// compressed texture formats shown in Table 3 below
	/// 
	/// 
	/// 
	/// 
	/// 
	/// If the internalFormat parameter is one of the generic compressed formats,
	/// GL_COMPRESSED_RED, GL_COMPRESSED_RG,
	/// GL_COMPRESSED_RGB, or
	/// GL_COMPRESSED_RGBA, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.
	/// 
	/// 
	/// 
	/// If the internalFormat parameter is 
	/// GL_SRGB,
	/// GL_SRGB8,
	/// GL_SRGB_ALPHA, or
	/// GL_SRGB8_ALPHA8, the texture is treated as if the red, green, blue, or luminance components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component 
	/// cs
	/// to a linear component 
	/// cl
	/// is:
	/// 
	/// 
	/// cl={cs12.92ifcs0.04045(cs+0.0551.055)2.4ifcs>0.04045
	/// 
	/// 
	/// Assume 
	/// cs
	/// is the sRGB component in the range [0,1].
	/// 
	/// 
	/// 
	/// Use the GL_PROXY_TEXTURE_3D target to try out a resolution and
	/// format. The implementation will
	/// update and recompute its best match for the requested storage resolution
	/// and format. To then query this state, call glGetTexLevelParameter.
	/// If the texture cannot be accommodated, texture state is set to 0.
	/// 
	/// 
	/// 
	/// A one-component texture image uses only the red component of the RGBA
	/// color extracted from data.
	/// A two-component image uses the R and A values.
	/// A three-component image uses the R, G, and B values.
	/// A four-component image uses all of the RGBA components.
	__gshared void function(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * data) glTexImage3D;
	/// Establish the data storage, format, dimensions, and number of samples of a multisample texture's image.
	/// 
	/// glTexImage3DMultisample establishes the data storage, format, dimensions and number of samples of a multisample texture's image.
	/// 
	/// 
	/// target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
	/// width and heightare the dimensions in texels of the texture, and must
	/// be in the range zero to GL_MAX_TEXTURE_SIZE - 1. depth is the number of array slices in the array texture's image.
	/// samples specifies the number of samples in the image and must be in the range zero to GL_MAX_SAMPLES - 1.
	/// 
	/// 
	/// internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.
	/// 
	/// 
	/// 
	/// If fixedsamplelocations is GL_TRUE, the image will use identical sample locations and the same
	/// number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
	/// 
	/// 
	/// 
	/// When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer
	/// corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the
	/// multisample texture targets.
	__gshared void function(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) glTexImage3DMultisample;
	/// Set texture parameters.
	/// 
	/// glTexParameter assigns the value or values in params to the texture parameter
	/// specified as pname.
	/// target defines the target texture,
	/// either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY,
	/// GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_3D.
	/// The following symbols are accepted in pname:
	/// 
	/// 
	/// 
	/// Specifies the index of the lowest defined mipmap level. This is an
	/// integer value. The initial value is 0.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// The data in params specifies four values that define the border values that
	/// should be used for border texels. If a texel is sampled from the border of the texture, the
	/// values of GL_TEXTURE_BORDER_COLOR are interpreted as an RGBA color to match the
	/// texture's internal format and substituted for the non-existent texel data. If the texture contains depth
	/// components, the first component of GL_TEXTURE_BORDER_COLOR is interpreted as a depth value.
	/// The initial value is
	/// 
	/// 0.0, 0.0, 0.0, 0.0
	/// .
	/// 
	/// 
	/// 
	/// If the values for GL_TEXTURE_BORDER_COLOR are specified with glTexParameterIiv
	/// or glTexParameterIuiv, the values are stored unmodified with an internal data type of
	/// integer. If specified with glTexParameteriv, they are converted to floating point with the following
	/// equation:
	/// f=2c+12b-1.
	/// If specified with glTexParameterfv, they are stored unmodified as floating-point values.
	/// 
	/// 
	/// 
	/// Specifies the comparison operator used when GL_TEXTURE_COMPARE_MODE is
	/// set to GL_COMPARE_REF_TO_TEXTURE. Permissible values are:
	/// 
	/// Texture Comparison Function
	/// 
	/// Computed result 
	/// GL_LEQUALresult=1.00.0r<=Dtr>DtGL_GEQUALresult=1.00.0r>=Dtr<DtGL_LESSresult=1.00.0r<Dtr>=DtGL_GREATERresult=1.00.0r>Dtr<=DtGL_EQUALresult=1.00.0r=DtrDtGL_NOTEQUALresult=1.00.0rDtr=DtGL_ALWAYSresult=1.0GL_NEVERresult=0.0
	/// where r
	/// is the current interpolated texture coordinate, and 
	/// Dt
	/// is the depth texture value sampled from the currently bound depth texture.
	/// result
	/// is assigned to the the red channel.
	/// 
	/// 
	/// 
	/// Specifies the texture comparison mode for currently bound depth textures.
	/// That is, a texture whose internal format is GL_DEPTH_COMPONENT_*; see
	/// glTexImage2D
	/// Permissible values are:
	/// GL_COMPARE_REF_TO_TEXTURE
	/// Specifies that the interpolated and clamped 
	/// r
	/// texture coordinate should
	/// be compared to the value in the currently bound depth texture. See the
	/// discussion of GL_TEXTURE_COMPARE_FUNC for details of how the comparison
	/// is evaluated. The result of the comparison is assigned to the red channel.
	/// GL_NONE
	/// Specifies that the red channel should be assigned the
	/// appropriate value from the currently bound depth texture.
	/// 
	/// 
	/// 
	/// Specifies that the interpolated and clamped 
	/// r
	/// texture coordinate should
	/// be compared to the value in the currently bound depth texture. See the
	/// discussion of GL_TEXTURE_COMPARE_FUNC for details of how the comparison
	/// is evaluated. The result of the comparison is assigned to the red channel.
	/// 
	/// 
	/// 
	/// Specifies that the red channel should be assigned the
	/// appropriate value from the currently bound depth texture.
	/// 
	/// 
	/// params specifies a fixed bias value that is to be added to the level-of-detail
	/// parameter for the texture before texture sampling. The specified value is added to the shader-supplied
	/// bias value (if any) and subsequently clamped into the implementation-defined range
	/// 
	/// -
	/// biasmaxbiasmax,
	/// where
	/// biasmax
	/// is the value of the implementation defined constant GL_MAX_TEXTURE_LOD_BIAS. The initial value is 0.0.
	/// 
	/// 
	/// 
	/// The texture minifying function is used whenever the level-of-detail function
	/// used when sampling from the texture determines that the texture should be minified.
	/// There are six defined minifying functions.
	/// Two of them use either the nearest texture elements or a weighted average of multiple texture elements
	/// to compute the texture value.
	/// The other four use mipmaps.
	/// 
	/// 
	/// 
	/// A mipmap is an ordered set of arrays representing the same image
	/// at progressively lower resolutions.
	/// If the texture has dimensions 
	/// 2n2m,
	/// there are
	/// maxnm+1
	/// mipmaps.
	/// The first mipmap is the original texture,
	/// with dimensions 
	/// 2n2m.
	/// Each subsequent mipmap has dimensions 
	/// 2k-12l-1,
	/// where 
	/// 2k2l
	/// are the dimensions of the previous mipmap,
	/// until either 
	/// k=0
	/// or 
	/// l=0.
	/// At that point,
	/// subsequent mipmaps have dimension 
	/// 12l-1
	/// or 
	/// 2k-11
	/// until the final mipmap,
	/// which has dimension 
	/// 11.
	/// To define the mipmaps, call glTexImage1D, glTexImage2D,
	/// glTexImage3D,
	/// glCopyTexImage1D, or glCopyTexImage2D
	/// with the level argument indicating the order of the mipmaps.
	/// Level 0 is the original texture;
	/// level 
	/// maxnm
	/// is the final 
	/// 11
	/// mipmap.
	/// 
	/// 
	/// params supplies a function for minifying the texture as one of the
	/// following:
	/// GL_NEAREST
	/// Returns the value of the texture element that is nearest
	/// (in Manhattan distance)
	/// to the specified texture coordinates.
	/// GL_LINEAR
	/// Returns the weighted average of the four texture elements
	/// that are closest to the specified texture coordinates.
	/// These can include items wrapped or repeated from other parts of a texture,
	/// depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T,
	/// and on the exact mapping.
	/// GL_NEAREST_MIPMAP_NEAREST
	/// Chooses the mipmap that most closely matches the size of the pixel
	/// being textured and uses the GL_NEAREST criterion
	/// (the texture element closest to the specified texture coordinates)
	/// to produce a texture value.
	/// GL_LINEAR_MIPMAP_NEAREST
	/// Chooses the mipmap that most closely matches the size of the pixel
	/// being textured and uses the GL_LINEAR criterion
	/// (a weighted average of the four texture elements that are closest to the specified texture coordinates)
	/// to produce a texture value.
	/// GL_NEAREST_MIPMAP_LINEAR
	/// Chooses the two mipmaps that most closely match the size of the pixel
	/// being textured and uses the GL_NEAREST criterion
	/// (the texture element closest to the specified texture coordinates )
	/// to produce a texture value from each mipmap.
	/// The final texture value is a weighted average of those two values.
	/// GL_LINEAR_MIPMAP_LINEAR
	/// Chooses the two mipmaps that most closely match the size of the pixel
	/// being textured and uses the GL_LINEAR criterion
	/// (a weighted average of the texture elements that are closest to the specified texture coordinates)
	/// to produce a texture value from each mipmap.
	/// The final texture value is a weighted average of those two values.
	/// 
	/// 
	/// 
	/// Returns the value of the texture element that is nearest
	/// (in Manhattan distance)
	/// to the specified texture coordinates.
	/// 
	/// 
	/// 
	/// Returns the weighted average of the four texture elements
	/// that are closest to the specified texture coordinates.
	/// These can include items wrapped or repeated from other parts of a texture,
	/// depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T,
	/// and on the exact mapping.
	/// 
	/// 
	/// 
	/// Chooses the mipmap that most closely matches the size of the pixel
	/// being textured and uses the GL_NEAREST criterion
	/// (the texture element closest to the specified texture coordinates)
	/// to produce a texture value.
	/// 
	/// 
	/// 
	/// Chooses the mipmap that most closely matches the size of the pixel
	/// being textured and uses the GL_LINEAR criterion
	/// (a weighted average of the four texture elements that are closest to the specified texture coordinates)
	/// to produce a texture value.
	/// 
	/// 
	/// 
	/// Chooses the two mipmaps that most closely match the size of the pixel
	/// being textured and uses the GL_NEAREST criterion
	/// (the texture element closest to the specified texture coordinates )
	/// to produce a texture value from each mipmap.
	/// The final texture value is a weighted average of those two values.
	/// 
	/// 
	/// 
	/// Chooses the two mipmaps that most closely match the size of the pixel
	/// being textured and uses the GL_LINEAR criterion
	/// (a weighted average of the texture elements that are closest to the specified texture coordinates)
	/// to produce a texture value from each mipmap.
	/// The final texture value is a weighted average of those two values.
	/// 
	/// 
	/// 
	/// As more texture elements are sampled in the minification process,
	/// fewer aliasing artifacts will be apparent.
	/// While the GL_NEAREST and GL_LINEAR minification functions can be
	/// faster than the other four,
	/// they sample only one or multiple texture elements to determine the texture value
	/// of the pixel being rendered and can produce moire patterns
	/// or ragged transitions.
	/// The initial value of GL_TEXTURE_MIN_FILTER is
	/// GL_NEAREST_MIPMAP_LINEAR.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// The texture magnification function is used whenever the level-of-detail function
	/// used when sampling from the texture determines that the texture should be magified.
	/// It sets the texture magnification function to either GL_NEAREST
	/// or GL_LINEAR (see below). GL_NEAREST is generally faster
	/// than GL_LINEAR,
	/// but it can produce textured images with sharper edges
	/// because the transition between texture elements is not as smooth.
	/// The initial value of GL_TEXTURE_MAG_FILTER is GL_LINEAR.
	/// GL_NEAREST
	/// Returns the value of the texture element that is nearest
	/// (in Manhattan distance)
	/// to the specified texture coordinates.
	/// GL_LINEAR
	/// Returns the weighted average of the texture elements
	/// that are closest to the specified texture coordinates.
	/// These can include items wrapped or repeated from other parts of a texture,
	/// depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T,
	/// and on the exact mapping.
	/// 
	/// 
	/// 
	/// Returns the value of the texture element that is nearest
	/// (in Manhattan distance)
	/// to the specified texture coordinates.
	/// 
	/// 
	/// 
	/// Returns the weighted average of the texture elements
	/// that are closest to the specified texture coordinates.
	/// These can include items wrapped or repeated from other parts of a texture,
	/// depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T,
	/// and on the exact mapping.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the minimum level-of-detail parameter. This floating-point value
	/// limits the selection of highest resolution mipmap (lowest mipmap
	/// level). The initial value is -1000.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the maximum level-of-detail parameter. This floating-point value
	/// limits the selection of the lowest resolution mipmap (highest mipmap
	/// level). The initial value is 1000.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the index of the highest defined mipmap level. This is an integer
	/// value. The initial value is 1000.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the swizzle that will be applied to the r
	/// component of a texel before it is returned to the shader. Valid values for param are GL_RED,
	/// GL_GREEN, GL_BLUE, GL_ALPHA, GL_ZERO and
	/// GL_ONE.
	/// If GL_TEXTURE_SWIZZLE_R is GL_RED, the value for
	/// r will be taken from the first
	/// channel of the fetched texel.
	/// If GL_TEXTURE_SWIZZLE_R is GL_GREEN, the value for
	/// r will be taken from the second
	/// channel of the fetched texel.
	/// If GL_TEXTURE_SWIZZLE_R is GL_BLUE, the value for
	/// r will be taken from the third
	/// channel of the fetched texel.
	/// If GL_TEXTURE_SWIZZLE_R is GL_ALPHA, the value for
	/// r will be taken from the fourth
	/// channel of the fetched texel.
	/// If GL_TEXTURE_SWIZZLE_R is GL_ZERO, the value for
	/// r will be subtituted with
	/// 0.0.
	/// If GL_TEXTURE_SWIZZLE_R is GL_ONE, the value for
	/// r will be subtituted with
	/// 1.0.
	/// The initial value is GL_RED.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the swizzle that will be applied to the g
	/// component of a texel before it is returned to the shader. Valid values for param and their effects are similar to
	/// those of GL_TEXTURE_SWIZZLE_R.
	/// The initial value is GL_GREEN.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the swizzle that will be applied to the b
	/// component of a texel before it is returned to the shader. Valid values for param and their effects are similar to
	/// those of GL_TEXTURE_SWIZZLE_R.
	/// The initial value is GL_BLUE.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the swizzle that will be applied to the a
	/// component of a texel before it is returned to the shader. Valid values for param and their effects are similar to
	/// those of GL_TEXTURE_SWIZZLE_R.
	/// The initial value is GL_ALPHA.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the swizzles that will be applied to the
	/// r,
	/// g,
	/// b, and
	/// a
	/// components of a texel before they are returned to the shader. Valid values for params and their effects are similar to
	/// those of GL_TEXTURE_SWIZZLE_R, except that all channels are specified simultaneously.
	/// Setting the value of GL_TEXTURE_SWIZZLE_RGBA is equivalent (assuming no errors are generated) to
	/// setting the parameters of each of GL_TEXTURE_SWIZZLE_R,
	/// GL_TEXTURE_SWIZZLE_G,
	/// GL_TEXTURE_SWIZZLE_B, and
	/// GL_TEXTURE_SWIZZLE_A successively.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the wrap parameter for texture coordinate 
	/// s
	/// to either GL_CLAMP_TO_EDGE, GL_CLAMP_TO_BORDER,
	/// GL_MIRRORED_REPEAT, or
	/// GL_REPEAT. GL_CLAMP_TO_EDGE causes 
	/// s
	/// coordinates to be clamped to the
	/// range 
	/// 12N1-12N,
	/// where 
	/// N
	/// is the size
	/// of the texture in the direction of clamping.
	/// GL_CLAMP_TO_BORDER evaluates s coordinates in a similar manner to GL_CLAMP_TO_EDGE.
	/// However, in cases where clamping would have occurred in GL_CLAMP_TO_EDGE mode, the fetched texel data
	/// is substituted with the values specified by GL_TEXTURE_BORDER_COLOR.
	/// GL_REPEAT causes the
	/// integer part of the 
	/// s
	/// coordinate to be ignored; the GL uses only the
	/// fractional part, thereby creating a repeating pattern.
	/// GL_MIRRORED_REPEAT causes the 
	/// s
	/// coordinate to be set to the
	/// fractional part of the texture coordinate if the integer part of 
	/// s
	/// is
	/// even; if the integer part of 
	/// s
	/// is odd, then the 
	/// s
	/// texture coordinate is
	/// set to 
	/// 1-fracs,
	/// where 
	/// fracs
	/// represents the fractional part of
	/// s.
	/// Initially, GL_TEXTURE_WRAP_S is set to GL_REPEAT.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the wrap parameter for texture coordinate 
	/// t
	/// to either GL_CLAMP_TO_EDGE, GL_CLAMP_TO_BORDER,
	/// GL_MIRRORED_REPEAT, or
	/// GL_REPEAT. See the discussion under GL_TEXTURE_WRAP_S.
	/// Initially, GL_TEXTURE_WRAP_T is set to GL_REPEAT.
	/// 
	/// 
	/// 
	/// 
	/// 
	/// Sets the wrap parameter for texture coordinate 
	/// r
	/// to either GL_CLAMP_TO_EDGE, GL_CLAMP_TO_BORDER,
	/// GL_MIRRORED_REPEAT, or
	/// GL_REPEAT. See the discussion under GL_TEXTURE_WRAP_S.
	/// Initially, GL_TEXTURE_WRAP_R is set to GL_REPEAT.
	void glTexParameterf(GLenum target, GLenum pname, GLfloat param);
	/// Ditto
	void glTexParameteri(GLenum target, GLenum pname, GLint param);
	/// Ditto
	void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params);
	/// Ditto
	void glTexParameteriv(GLenum target, GLenum pname, const GLint * params);
	/// Ditto
	__gshared void function(GLenum target, GLenum pname, const GLint * params) glTexParameterIiv;
	/// Ditto
	__gshared void function(GLenum target, GLenum pname, const GLuint * params) glTexParameterIuiv;
	/// Simultaneously specify storage for all levels of a one-dimensional texture.
	/// 
	/// glTexStorage1D specifies the storage requirements for all levels
	/// of a one-dimensional texture simultaneously. Once a texture is specified with this
	/// command, the format and dimensions of all levels become immutable unless it is a proxy
	/// texture. The contents of the image may still be modified, however, its storage requirements
	/// may not change. Such a texture is referred to as an immutable-format
	/// texture.
	/// 
	/// 
	/// 
	/// Calling glTexStorage1D is equivalent, assuming no errors are generated,
	/// to executing the following pseudo-code:
	/// 
	/// 
	/// 
	/// Since no texture data is actually provided, the values used in the pseudo-code
	/// for format and type are
	/// irrelevant and may be considered to be any values that are legal for the
	/// chosen internalformat enumerant. internalformat
	/// must be one of the sized internal formats given in Table 1 below, one of the sized depth-component
	/// formats GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT24, or
	/// GL_DEPTH_COMPONENT16, or one of the combined depth-stencil formats,
	/// GL_DEPTH32F_STENCIL8, or GL_DEPTH24_STENCIL8. Upon success,
	/// the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes
	/// GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT
	/// may be discovered by calling glGetTexParameter
	/// with pname set to GL_TEXTURE_IMMUTABLE_FORMAT.
	/// No further changes to the dimensions or format of the texture object may be
	/// made. Using any command that might alter the dimensions or format of the
	/// texture object (such as glTexImage1D or
	/// another call to glTexStorage1D) will result in the
	/// generation of a GL_INVALID_OPERATION error, even if it
	/// would not, in fact, alter the dimensions or format of the object.
	__gshared void function(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) glTexStorage1D;
	/// Simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture.
	/// 
	/// glTexStorage2D specifies the storage requirements for all levels
	/// of a two-dimensional texture or one-dimensional texture array simultaneously. Once a texture is specified with this
	/// command, the format and dimensions of all levels become immutable unless it is a proxy
	/// texture. The contents of the image may still be modified, however, its storage requirements
	/// may not change. Such a texture is referred to as an immutable-format
	/// texture.
	/// 
	/// 
	/// 
	/// The behavior of glTexStorage2D depends on the target parameter.
	/// When target is GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D,
	/// GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_CUBE_MAP,
	/// calling glTexStorage2D is equivalent, assuming no errors are generated,
	/// to executing the following pseudo-code:
	/// 
	/// 
	/// 
	/// When target is GL_TEXTURE_CUBE_MAP, glTexStorage2D
	/// is equivalent to:
	/// 
	/// 
	/// 
	/// When target is GL_TEXTURE_1D or GL_TEXTURE_1D_ARRAY,
	/// glTexStorage2D is equivalent to:
	/// 
	/// 
	/// 
	/// Since no texture data is actually provided, the values used in the pseudo-code
	/// for format and type are
	/// irrelevant and may be considered to be any values that are legal for the
	/// chosen internalformat enumerant. internalformat
	/// must be one of the sized internal formats given in Table 1 below, one of the sized depth-component
	/// formats GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT24, or
	/// GL_DEPTH_COMPONENT16, or one of the combined depth-stencil formats,
	/// GL_DEPTH32F_STENCIL8, or GL_DEPTH24_STENCIL8. Upon success,
	/// the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes
	/// GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT
	/// may be discovered by calling glGetTexParameter
	/// with pname set to GL_TEXTURE_IMMUTABLE_FORMAT.
	/// No further changes to the dimensions or format of the texture object may be
	/// made. Using any command that might alter the dimensions or format of the
	/// texture object (such as glTexImage2D or
	/// another call to glTexStorage2D) will result in the
	/// generation of a GL_INVALID_OPERATION error, even if it
	/// would not, in fact, alter the dimensions or format of the object.
	__gshared void function(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) glTexStorage2D;
	/// Simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture.
	/// 
	/// glTexStorage3D specifies the storage requirements for all levels
	/// of a three-dimensional, two-dimensional array or cube-map array texture simultaneously. Once a texture is specified with this
	/// command, the format and dimensions of all levels become immutable unless it is a proxy
	/// texture. The contents of the image may still be modified, however, its storage requirements
	/// may not change. Such a texture is referred to as an immutable-format
	/// texture.
	/// 
	/// 
	/// 
	/// The behavior of glTexStorage3D depends on the target parameter.
	/// When target is GL_TEXTURE_3D, or GL_PROXY_TEXTURE_3D,
	/// calling glTexStorage3D is equivalent, assuming no errors are generated,
	/// to executing the following pseudo-code:
	/// 
	/// 
	/// 
	/// When target is GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY,
	/// GL_TEXTURE_CUBE_MAP_ARRAY, or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY, glTexStorage3D
	/// is equivalent to:
	/// 
	/// 
	/// 
	/// Since no texture data is actually provided, the values used in the pseudo-code
	/// for format and type are
	/// irrelevant and may be considered to be any values that are legal for the
	/// chosen internalformat enumerant. internalformat
	/// must be one of the sized internal formats given in Table 1 below, one of the sized depth-component
	/// formats GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT24, or
	/// GL_DEPTH_COMPONENT16, or one of the combined depth-stencil formats,
	/// GL_DEPTH32F_STENCIL8, or GL_DEPTH24_STENCIL8. Upon success,
	/// the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes
	/// GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT
	/// may be discovered by calling glGetTexParameter
	/// with pname set to GL_TEXTURE_IMMUTABLE_FORMAT.
	/// No further changes to the dimensions or format of the texture object may be
	/// made. Using any command that might alter the dimensions or format of the
	/// texture object (such as glTexImage3D or
	/// another call to glTexStorage3D) will result in the
	/// generation of a GL_INVALID_OPERATION error, even if it
	/// would not, in fact, alter the dimensions or format of the object.
	__gshared void function(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) glTexStorage3D;
	/// Specify a one-dimensional texture subimage.
	/// 
	/// Texturing maps a portion of a specified texture image
	/// onto each graphical primitive for which texturing is enabled.
	/// To enable or disable one-dimensional texturing, call glEnable
	/// and glDisable with argument GL_TEXTURE_1D.
	/// 
	/// 
	/// glTexSubImage1D redefines a contiguous subregion of an existing one-dimensional
	/// texture image.
	/// The texels referenced by data replace the portion of the
	/// existing texture array with x indices xoffset and
	/// xoffset+width-1,
	/// inclusive.
	/// This region may not include any texels outside the range of the
	/// texture array as it was originally specified.
	/// It is not an error to specify a subtexture with width of 0, but
	/// such a specification has no effect.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// specified, data is treated as a byte offset into the buffer object's data store.
	void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * data);
	/// Specify a two-dimensional texture subimage.
	/// 
	/// Texturing maps a portion of a specified texture image
	/// onto each graphical primitive for which texturing is enabled.
	/// To enable and disable two-dimensional texturing, call glEnable
	/// and glDisable with argument GL_TEXTURE_2D.
	/// 
	/// 
	/// glTexSubImage2D redefines a contiguous subregion of an existing two-dimensional
	/// texture image.
	/// The texels referenced by data replace the portion of the
	/// existing texture array with x indices xoffset and 
	/// xoffset+width-1,
	/// inclusive,
	/// and y indices yoffset and 
	/// yoffset+height-1,
	/// inclusive.
	/// This region may not include any texels outside the range of the
	/// texture array as it was originally specified.
	/// It is not an error to specify a subtexture with zero width or height, but
	/// such a specification has no effect.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// specified, data is treated as a byte offset into the buffer object's data store.
	void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * data);
	/// Specify a three-dimensional texture subimage.
	/// 
	/// Texturing maps a portion of a specified texture image
	/// onto each graphical primitive for which texturing is enabled.
	/// To enable and disable three-dimensional texturing, call glEnable
	/// and glDisable with argument GL_TEXTURE_3D.
	/// 
	/// 
	/// glTexSubImage3D redefines a contiguous subregion of an existing three-dimensional
	/// texture image.
	/// The texels referenced by data replace the portion of the
	/// existing texture array with x indices xoffset and
	/// xoffset+width-1,
	/// inclusive,
	/// y indices yoffset and 
	/// yoffset+height-1,
	/// inclusive,
	/// and z indices zoffset and 
	/// zoffset+depth-1,
	/// inclusive.
	/// This region may not include any texels outside the range of the
	/// texture array as it was originally specified.
	/// It is not an error to specify a subtexture with zero width, height, or
	/// depth but such a specification has no effect.
	/// 
	/// 
	/// 
	/// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target 
	/// (see glBindBuffer) while a texture image is
	/// specified, data is treated as a byte offset into the buffer object's data store.
	__gshared void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * data) glTexSubImage3D;
	/// Specify values to record in transform feedback buffers.
	/// 
	/// The names of the vertex or geometry shader outputs to be recorded in transform feedback mode
	/// are specified using glTransformFeedbackVaryings. When a geometry shader
	/// is active, transform feedback records the values of selected geometry shader output variables
	/// from the emitted vertices. Otherwise, the values of the selected vertex shader outputs are
	/// recorded.
	/// 
	/// 
	/// 
	/// The state set by glTranformFeedbackVaryings is stored and takes effect
	/// next time glLinkProgram is called
	/// on program. When glLinkProgram
	/// is called, program is linked so that the values of the specified varying variables
	/// for the vertices of each primitive generated by the GL are written to a single buffer
	/// object if bufferMode is GL_INTERLEAVED_ATTRIBS or multiple
	/// buffer objects if bufferMode is GL_SEPARATE_ATTRIBS.
	/// 
	/// 
	/// 
	/// In addition to the errors generated by glTransformFeedbackVaryings, the
	/// program program will fail to link if:
	/// 
	/// The count specified by glTransformFeedbackVaryings is non-zero, but the
	/// program object has no vertex or geometry shader.
	/// 
	/// Any variable name specified in the varyings array is not declared as an output
	/// in the vertex shader (or the geometry shader, if active).
	/// 
	/// Any two entries in the varyings array specify the same varying variable.
	/// 
	/// The total number of components to capture in any varying variable in varyings
	/// is greater than the constant GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
	/// and the buffer mode is GL_SEPARATE_ATTRIBS.
	/// 
	/// The total number of components to capture is greater than the constant
	/// GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS and the buffer
	/// mode is GL_INTERLEAVED_ATTRIBS.
	/// 
	/// 
	/// 
	/// The count specified by glTransformFeedbackVaryings is non-zero, but the
	/// program object has no vertex or geometry shader.
	/// 
	/// 
	/// 
	/// Any variable name specified in the varyings array is not declared as an output
	/// in the vertex shader (or the geometry shader, if active).
	/// 
	/// 
	/// 
	/// Any two entries in the varyings array specify the same varying variable.
	/// 
	/// 
	/// 
	/// The total number of components to capture in any varying variable in varyings
	/// is greater than the constant GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
	/// and the buffer mode is GL_SEPARATE_ATTRIBS.
	/// 
	/// 
	/// 
	/// The total number of components to capture is greater than the constant
	/// GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS and the buffer
	/// mode is GL_INTERLEAVED_ATTRIBS.
	__gshared void function(const char** varyings) glTransformFeedbackVaryings;
	/// Specify the value of a uniform variable for the current program object.
	/// 
	/// glUniform modifies the value of a
	/// uniform variable or a uniform variable array. The location of
	/// the uniform variable to be modified is specified by
	/// location, which should be a value
	/// returned by
	/// glGetUniformLocation.
	/// glUniform operates on the program object
	/// that was made part of current state by calling
	/// glUseProgram.
	/// 
	/// The commands glUniform{1|2|3|4}{f|i|ui}
	/// are used to change the value of the uniform variable specified
	/// by location using the values passed as
	/// arguments. The number specified in the command should match the
	/// number of components in the data type of the specified uniform
	/// variable (e.g., 1 for float, int, unsigned int, bool;
	/// 2 for vec2, ivec2, uvec2, bvec2, etc.). The suffix
	/// f indicates that floating-point values are
	/// being passed; the suffix i indicates that
	/// integer values are being passed; the suffix ui indicates that
	/// unsigned integer values are being passed, and this type should also match
	/// the data type of the specified uniform variable. The
	/// i variants of this function should be used
	/// to provide values for uniform variables defined as int, ivec2,
	/// ivec3, ivec4, or arrays of these. The
	/// ui variants of this function should be used
	/// to provide values for uniform variables defined as unsigned int, uvec2,
	/// uvec3, uvec4, or arrays of these. The f
	/// variants should be used to provide values for uniform variables
	/// of type float, vec2, vec3, vec4, or arrays of these. Either the
	/// i, ui or f variants
	/// may be used to provide values for uniform variables of type
	/// bool, bvec2, bvec3, bvec4, or arrays of these. The uniform
	/// variable will be set to false if the input value is 0 or 0.0f,
	/// and it will be set to true otherwise.
	/// 
	/// All active uniform variables defined in a program object
	/// are initialized to 0 when the program object is linked
	/// successfully. They retain the values assigned to them by a call
	/// to glUniform until the next successful
	/// link operation occurs on the program object, when they are once
	/// again initialized to 0.
	/// 
	/// The commands glUniform{1|2|3|4}{f|i|ui}v
	/// can be used to modify a single uniform variable or a uniform
	/// variable array. These commands pass a count and a pointer to the
	/// values to be loaded into a uniform variable or a uniform
	/// variable array. A count of 1 should be used if modifying the
	/// value of a single uniform variable, and a count of 1 or greater
	/// can be used to modify an entire array or part of an array. When
	/// loading n elements starting at an arbitrary
	/// position m in a uniform variable array,
	/// elements m + n - 1 in
	/// the array will be replaced with the new values. If
	/// m + n - 1 is
	/// larger than the size of the uniform variable array, values for
	/// all array elements beyond the end of the array will be ignored.
	/// The number specified in the name of the command indicates the
	/// number of components for each element in
	/// value, and it should match the number of
	/// components in the data type of the specified uniform variable
	/// (e.g., 1 for float, int, bool;
	/// 2 for vec2, ivec2, bvec2, etc.). The data
	/// type specified in the name of the command must match the data
	/// type for the specified uniform variable as described previously
	/// for glUniform{1|2|3|4}{f|i|ui}.
	/// 
	/// For uniform variable arrays, each element of the array is
	/// considered to be of the type indicated in the name of the
	/// command (e.g., glUniform3f or
	/// glUniform3fv can be used to load a uniform
	/// variable array of type vec3). The number of elements of the
	/// uniform variable array to be modified is specified by
	/// count
	/// 
	/// The commands
	/// glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv 
	/// are used to modify a matrix or an array of matrices. The numbers in the
	/// command name are interpreted as the dimensionality of the matrix.
	/// The number 2 indicates a 2 x 2 matrix
	/// (i.e., 4 values), the number 3 indicates a
	/// 3 x 3 matrix (i.e., 9 values), and the number
	/// 4 indicates a 4 x 4 matrix (i.e., 16
	/// values). Non-square matrix dimensionality is explicit, with the first
	/// number representing the number of columns and the second number
	/// representing the number of rows. For example, 
	/// 2x4 indicates a 2 x 4 matrix with 2 columns
	/// and 4 rows (i.e., 8 values).
	/// If transpose is
	/// GL_FALSE, each matrix is assumed to be
	/// supplied in column major order. If
	/// transpose is
	/// GL_TRUE, each matrix is assumed to be
	/// supplied in row major order. The count
	/// argument indicates the number of matrices to be passed. A count
	/// of 1 should be used if modifying the value of a single matrix,
	/// and a count greater than 1 can be used to modify an array of
	/// matrices.
	__gshared void function(GLint location, GLfloat v0) glUniform1f;
	/// Ditto
	__gshared void function(GLint location, GLfloat v0, GLfloat v1) glUniform2f;
	/// Ditto
	__gshared void function(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) glUniform3f;
	/// Ditto
	__gshared void function(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) glUniform4f;
	/// Ditto
	__gshared void function(GLint location, GLint v0) glUniform1i;
	/// Ditto
	__gshared void function(GLint location, GLint v0, GLint v1) glUniform2i;
	/// Ditto
	__gshared void function(GLint location, GLint v0, GLint v1, GLint v2) glUniform3i;
	/// Ditto
	__gshared void function(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) glUniform4i;
	/// Ditto
	__gshared void function(GLint location, GLuint v0) glUniform1ui;
	/// Ditto
	__gshared void function(GLint location, GLint v0, GLuint v1) glUniform2ui;
	/// Ditto
	__gshared void function(GLint location, GLint v0, GLint v1, GLuint v2) glUniform3ui;
	/// Ditto
	__gshared void function(GLint location, GLint v0, GLint v1, GLint v2, GLuint v3) glUniform4ui;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, const GLfloat* value) glUniform1fv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, const GLfloat* value) glUniform2fv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, const GLfloat* value) glUniform3fv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, const GLfloat* value) glUniform4fv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, const GLint* value) glUniform1iv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, const GLint* value) glUniform2iv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, const GLint* value) glUniform3iv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, const GLint* value) glUniform4iv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, const GLuint* value) glUniform1uiv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, const GLuint* value) glUniform2uiv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, const GLuint* value) glUniform3uiv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, const GLuint* value) glUniform4uiv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glUniformMatrix2fv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glUniformMatrix3fv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glUniformMatrix4fv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glUniformMatrix2x3fv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glUniformMatrix3x2fv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glUniformMatrix2x4fv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glUniformMatrix4x2fv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glUniformMatrix3x4fv;
	/// Ditto
	__gshared void function(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) glUniformMatrix4x3fv;
	/// Assign a binding point to an active uniform block.
	/// 
	/// Binding points for active uniform blocks are assigned using glUniformBlockBinding. Each of a program's active uniform
	/// blocks has a corresponding uniform buffer binding point. program is the name of a program object for which the command
	/// glLinkProgram has been issued in the past.
	/// 
	/// 
	/// 
	/// If successful, glUniformBlockBinding specifies that program will use the data store of the
	/// buffer object bound to the binding point uniformBlockBinding to extract the values of the uniforms in the
	/// uniform block identified by uniformBlockIndex.
	/// 
	/// 
	/// 
	/// When a program object is linked or re-linked, the uniform buffer object binding point assigned to each of its active uniform blocks is reset to zero.
	__gshared void function(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) glUniformBlockBinding;
	/// Load active subroutine uniforms.
	/// 
	/// glUniformSubroutines loads all active subroutine uniforms for shader stage
	/// shadertype of the current program with subroutine indices from indices,
	/// storing indices[i] into the uniform at location i.
	/// count must be equal to the value of GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS
	/// for the program currently in use at shader stage shadertype. Furthermore, all values in
	/// indices must be less than the value of GL_ACTIVE_SUBROUTINES
	/// for the shader stage.
	__gshared void function(GLenum shadertype, GLsizei count, const GLuint* indices) glUniformSubroutinesuiv;
	/// Installs a program object as part of current rendering state.
	/// 
	/// glUseProgram installs the program
	/// object specified by program as part of
	/// current rendering state. One or more executables are created in
	/// a program object by successfully attaching shader objects to it
	/// with
	/// glAttachShader,
	/// successfully compiling the shader objects with
	/// glCompileShader,
	/// and successfully linking the program object with
	/// glLinkProgram.
	/// 
	/// 
	/// A program object will contain an executable that will run
	/// on the vertex processor if it contains one or more shader
	/// objects of type GL_VERTEX_SHADER that have
	/// been successfully compiled and linked. A program object will contain an
	/// executable that will run on the geometry processor if it contains one or
	/// more shader objects of type GL_GEOMETRY_SHADER that
	/// have been successfully compiled and linked.
	/// Similarly, a program object will contain an executable that will run on the
	/// fragment processor if it contains one or more shader objects of type
	/// GL_FRAGMENT_SHADER that have been
	/// successfully compiled and linked.
	/// 
	/// While a program object is in use, applications are free to
	/// modify attached shader objects, compile attached shader objects,
	/// attach additional shader objects, and detach or delete shader
	/// objects. None of these operations will affect the executables
	/// that are part of the current state. However, relinking the
	/// program object that is currently in use will install the program
	/// object as part of the current rendering state if the link
	/// operation was successful (see
	/// glLinkProgram
	/// ). If the program object currently in use is relinked
	/// unsuccessfully, its link status will be set to
	/// GL_FALSE, but the executables and
	/// associated state will remain part of the current state until a
	/// subsequent call to glUseProgram removes it
	/// from use. After it is removed from use, it cannot be made part
	/// of current state until it has been successfully relinked.
	/// 
	/// If program is zero, then the current rendering
	/// state refers to an invalid program object and the
	/// results of shader execution are undefined. However, this is not an error.
	/// 
	/// If program does not
	/// contain shader objects of type GL_FRAGMENT_SHADER, an
	/// executable will be installed on the vertex, and possibly geometry processors,
	/// but the results of fragment shader execution will be undefined.
	__gshared void function(GLuint program) glUseProgram;
	/// Bind stages of a program object to a program pipeline.
	/// 
	/// glUseProgramStages binds executables from a program object
	/// associated with a specified set of shader stages to the program pipeline object given
	/// by pipeline.
	/// pipeline specifies the program pipeline object to which to bind
	/// the executables. stages contains a logical combination of bits
	/// indicating the shader stages to use within program with the program
	/// pipeline object pipeline. stages must be
	/// a logical combination of GL_VERTEX_SHADER_BIT,
	/// GL_TESS_CONTROL_SHADER_BIT, GL_TESS_EVALUATION_SHADER_BIT,
	/// GL_GEOMETRY_SHADER_BIT, and GL_FRAGMENT_SHADER_BIT.
	/// Additionally, the special value GL_ALL_SHADER_BITS may be specified to
	/// indicate that all executables contained in program should be
	/// installed in pipeline.
	/// 
	/// 
	/// 
	/// If program refers to a program object with a valid shader attached for
	/// an indicated shader stage, glUseProgramStages installs the executable
	/// code for that stage in the indicated program pipeline object pipeline.
	/// If program is zero, or refers to a program object with no valid shader
	/// executable for a given stage, it is as if the pipeline object has no programmable stage configured
	/// for the indicated shader stages. If stages contains bits other than those
	/// listed above, and is not equal to GL_ALL_SHADER_BITS, an error is generated.
	__gshared void function(GLuint pipeline, GLbitfield stages, GLuint program) glUseProgramStages;
	/// Validates a program object.
	/// 
	/// glValidateProgram checks to see
	/// whether the executables contained in
	/// program can execute given the current
	/// OpenGL state. The information generated by the validation
	/// process will be stored in program's
	/// information log. The validation information may consist of an
	/// empty string, or it may be a string containing information about
	/// how the current program object interacts with the rest of
	/// current OpenGL state. This provides a way for OpenGL
	/// implementers to convey more information about why the current
	/// program is inefficient, suboptimal, failing to execute, and so
	/// on.
	/// 
	/// The status of the validation operation will be stored as
	/// part of the program object's state. This value will be set to
	/// GL_TRUE if the validation succeeded, and
	/// GL_FALSE otherwise. It can be queried by
	/// calling
	/// glGetProgram
	/// with arguments program and
	/// GL_VALIDATE_STATUS. If validation is
	/// successful, program is guaranteed to
	/// execute given the current state. Otherwise,
	/// program is guaranteed to not execute.
	/// 
	/// This function is typically useful only during application
	/// development. The informational string stored in the information
	/// log is completely implementation dependent; therefore, an
	/// application should not expect different OpenGL implementations
	/// to produce identical information strings.
	__gshared void function(GLuint program) glValidateProgram;
	/// Validate a program pipeline object against current GL state.
	/// 
	/// glValidateProgramPipeline instructs the implementation to validate the
	/// shader executables contained in pipeline against the current GL state.
	/// The implementation may use this as an opportunity to perform any internal shader modifications
	/// that may be required to ensure correct operation of the installed shaders given the
	/// current GL state.
	/// 
	/// 
	/// 
	/// After a program pipeline has been validated, its validation status is set to GL_TRUE.
	/// The validation status of a program pipeline object may be queried by calling
	/// glGetProgramPipeline with
	/// parameter GL_VALIDATE_STATUS.
	/// 
	/// 
	/// 
	/// If pipeline is a name previously returned from a call to
	/// glGenProgramPipelines but
	/// that has not yet been bound by a call to glBindProgramPipeline,
	/// a new program pipeline object is created with name pipeline and
	/// the default state vector.
	__gshared void function(GLuint pipeline) glValidateProgramPipeline;
	/// Specifies the value of a generic vertex attribute.
	/// 
	/// The glVertexAttrib family of entry points
	/// allows an application to pass generic vertex attributes in
	/// numbered locations.
	/// 
	/// Generic attributes are defined as four-component values
	/// that are organized into an array. The first entry of this array
	/// is numbered 0, and the size of the array is specified by the
	/// implementation-dependent constant
	/// GL_MAX_VERTEX_ATTRIBS. Individual elements
	/// of this array can be modified with a
	/// glVertexAttrib call that specifies the
	/// index of the element to be modified and a value for that
	/// element.
	/// 
	/// These commands can be used to specify one, two, three, or
	/// all four components of the generic vertex attribute specified by
	/// index. A 1 in the
	/// name of the command indicates that only one value is passed, and
	/// it will be used to modify the first component of the generic
	/// vertex attribute. The second and third components will be set to
	/// 0, and the fourth component will be set to 1. Similarly, a
	/// 2 in the name of the command indicates that
	/// values are provided for the first two components, the third
	/// component will be set to 0, and the fourth component will be set
	/// to 1. A 3 in the name of the command
	/// indicates that values are provided for the first three
	/// components and the fourth component will be set to 1, whereas a
	/// 4 in the name indicates that values are
	/// provided for all four components.
	/// 
	/// The letters s,
	/// f, i,
	/// d, ub,
	/// us, and ui indicate
	/// whether the arguments are of type short, float, int, double,
	/// unsigned byte, unsigned short, or unsigned int. When
	/// v is appended to the name, the commands can
	/// take a pointer to an array of such values.
	/// 
	/// Additional capitalized letters can indicate further alterations
	/// to the default behavior of the glVertexAttrib function:
	/// 
	/// 
	/// The commands containing N indicate that 
	/// the arguments will be passed as fixed-point values that are 
	/// scaled to a normalized range according to the component 
	/// conversion rules defined by the OpenGL specification. Signed
	/// values are understood to represent fixed-point values in the
	/// range [-1,1], and unsigned values are understood to represent
	/// fixed-point values in the range [0,1].
	/// 
	/// 
	/// 
	/// The commands containing I indicate that 
	/// the arguments are extended to full signed or unsigned integers.
	/// 
	/// 
	/// 
	/// The commands containing P indicate that 
	/// the arguments are stored as packed components within a larger
	/// natural type.
	/// 
	/// 
	/// 
	/// The commands containing L indicate that
	/// the arguments are full 64-bit quantities and should be passed directly
	/// to shader inputs declared as 64-bit double precision types.
	/// 
	/// 
	/// OpenGL Shading Language attribute variables are allowed to
	/// be of type mat2, mat3, or mat4. Attributes of these types may be
	/// loaded using the glVertexAttrib entry
	/// points. Matrices must be loaded into successive generic
	/// attribute slots in column major order, with one column of the
	/// matrix in each generic attribute slot.
	/// 
	/// A user-defined attribute variable declared in a vertex
	/// shader can be bound to a generic attribute index by calling
	/// glBindAttribLocation.
	/// This allows an application to use more descriptive variable
	/// names in a vertex shader. A subsequent change to the specified
	/// generic vertex attribute will be immediately reflected as a
	/// change to the corresponding attribute variable in the vertex
	/// shader.
	/// 
	/// The binding between a generic vertex attribute index and a
	/// user-defined attribute variable in a vertex shader is part of
	/// the state of a program object, but the current value of the
	/// generic vertex attribute is not. The value of each generic
	/// vertex attribute is part of current state, just like standard
	/// vertex attributes, and it is maintained even if a different
	/// program object is used.
	/// 
	/// An application may freely modify generic vertex attributes
	/// that are not bound to a named vertex shader attribute variable.
	/// These values are simply maintained as part of current state and
	/// will not be accessed by the vertex shader. If a generic vertex
	/// attribute bound to an attribute variable in a vertex shader is
	/// not updated while the vertex shader is executing, the vertex
	/// shader will repeatedly use the current value for the generic
	/// vertex attribute.
	__gshared void function(GLuint index, GLfloat v0) glVertexAttrib1f;
	/// Ditto
	__gshared void function(GLuint index, GLshort v0) glVertexAttrib1s;
	/// Ditto
	__gshared void function(GLuint index, GLdouble v0) glVertexAttrib1d;
	/// Ditto
	__gshared void function(GLuint index, GLint v0) glVertexAttribI1i;
	/// Ditto
	__gshared void function(GLuint index, GLuint v0) glVertexAttribI1ui;
	/// Ditto
	__gshared void function(GLuint index, GLfloat v0, GLfloat v1) glVertexAttrib2f;
	/// Ditto
	__gshared void function(GLuint index, GLshort v0, GLshort v1) glVertexAttrib2s;
	/// Ditto
	__gshared void function(GLuint index, GLdouble v0, GLdouble v1) glVertexAttrib2d;
	/// Ditto
	__gshared void function(GLuint index, GLint v0, GLint v1) glVertexAttribI2i;
	/// Ditto
	__gshared void function(GLuint index, GLuint v0, GLuint v1) glVertexAttribI2ui;
	/// Ditto
	__gshared void function(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2) glVertexAttrib3f;
	/// Ditto
	__gshared void function(GLuint index, GLshort v0, GLshort v1, GLshort v2) glVertexAttrib3s;
	/// Ditto
	__gshared void function(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2) glVertexAttrib3d;
	/// Ditto
	__gshared void function(GLuint index, GLint v0, GLint v1, GLint v2) glVertexAttribI3i;
	/// Ditto
	__gshared void function(GLuint index, GLuint v0, GLuint v1, GLuint v2) glVertexAttribI3ui;
	/// Ditto
	__gshared void function(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) glVertexAttrib4f;
	/// Ditto
	__gshared void function(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3) glVertexAttrib4s;
	/// Ditto
	__gshared void function(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) glVertexAttrib4d;
	/// Ditto
	__gshared void function(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3) glVertexAttrib4Nub;
	/// Ditto
	__gshared void function(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3) glVertexAttribI4i;
	/// Ditto
	__gshared void function(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3) glVertexAttribI4ui;
	/// Ditto
	__gshared void function(GLuint index, GLdouble v0) glVertexAttribL1d;
	/// Ditto
	__gshared void function(GLuint index, GLdouble v0, GLdouble v1) glVertexAttribL2d;
	/// Ditto
	__gshared void function(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2) glVertexAttribL3d;
	/// Ditto
	__gshared void function(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) glVertexAttribL4d;
	/// Ditto
	__gshared void function(GLuint index, const GLfloat* v) glVertexAttrib1fv;
	/// Ditto
	__gshared void function(GLuint index, const GLshort* v) glVertexAttrib1sv;
	/// Ditto
	__gshared void function(GLuint index, const GLdouble* v) glVertexAttrib1dv;
	/// Ditto
	__gshared void function(GLuint index, const GLint* v) glVertexAttribI1iv;
	/// Ditto
	__gshared void function(GLuint index, const GLuint* v) glVertexAttribI1uiv;
	/// Ditto
	__gshared void function(GLuint index, const GLfloat* v) glVertexAttrib2fv;
	/// Ditto
	__gshared void function(GLuint index, const GLshort* v) glVertexAttrib2sv;
	/// Ditto
	__gshared void function(GLuint index, const GLdouble* v) glVertexAttrib2dv;
	/// Ditto
	__gshared void function(GLuint index, const GLint* v) glVertexAttribI2iv;
	/// Ditto
	__gshared void function(GLuint index, const GLuint* v) glVertexAttribI2uiv;
	/// Ditto
	__gshared void function(GLuint index, const GLfloat* v) glVertexAttrib3fv;
	/// Ditto
	__gshared void function(GLuint index, const GLshort* v) glVertexAttrib3sv;
	/// Ditto
	__gshared void function(GLuint index, const GLdouble* v) glVertexAttrib3dv;
	/// Ditto
	__gshared void function(GLuint index, const GLint* v) glVertexAttribI3iv;
	/// Ditto
	__gshared void function(GLuint index, const GLuint* v) glVertexAttribI3uiv;
	/// Ditto
	__gshared void function(GLuint index, const GLfloat* v) glVertexAttrib4fv;
	/// Ditto
	__gshared void function(GLuint index, const GLshort* v) glVertexAttrib4sv;
	/// Ditto
	__gshared void function(GLuint index, const GLdouble* v) glVertexAttrib4dv;
	/// Ditto
	__gshared void function(GLuint index, const GLint* v) glVertexAttrib4iv;
	/// Ditto
	__gshared void function(GLuint index, const GLbyte* v) glVertexAttrib4bv;
	/// Ditto
	__gshared void function(GLuint index, const GLubyte* v) glVertexAttrib4ubv;
	/// Ditto
	__gshared void function(GLuint index, const GLushort* v) glVertexAttrib4usv;
	/// Ditto
	__gshared void function(GLuint index, const GLuint* v) glVertexAttrib4uiv;
	/// Ditto
	__gshared void function(GLuint index, const GLbyte* v) glVertexAttrib4Nbv;
	/// Ditto
	__gshared void function(GLuint index, const GLshort* v) glVertexAttrib4Nsv;
	/// Ditto
	__gshared void function(GLuint index, const GLint* v) glVertexAttrib4Niv;
	/// Ditto
	__gshared void function(GLuint index, const GLubyte* v) glVertexAttrib4Nubv;
	/// Ditto
	__gshared void function(GLuint index, const GLushort* v) glVertexAttrib4Nusv;
	/// Ditto
	__gshared void function(GLuint index, const GLuint* v) glVertexAttrib4Nuiv;
	/// Ditto
	__gshared void function(GLuint index, const GLbyte* v) glVertexAttribI4bv;
	/// Ditto
	__gshared void function(GLuint index, const GLubyte* v) glVertexAttribI4ubv;
	/// Ditto
	__gshared void function(GLuint index, const GLshort* v) glVertexAttribI4sv;
	/// Ditto
	__gshared void function(GLuint index, const GLushort* v) glVertexAttribI4usv;
	/// Ditto
	__gshared void function(GLuint index, const GLint* v) glVertexAttribI4iv;
	/// Ditto
	__gshared void function(GLuint index, const GLuint* v) glVertexAttribI4uiv;
	/// Ditto
	__gshared void function(GLuint index, const GLdouble* v) glVertexAttribL1dv;
	/// Ditto
	__gshared void function(GLuint index, const GLdouble* v) glVertexAttribL2dv;
	/// Ditto
	__gshared void function(GLuint index, const GLdouble* v) glVertexAttribL3dv;
	/// Ditto
	__gshared void function(GLuint index, const GLdouble* v) glVertexAttribL4dv;
	/// Ditto
	__gshared void function(GLuint index, GLenum type, GLboolean normalized, GLuint value) glVertexAttribP1ui;
	/// Ditto
	__gshared void function(GLuint index, GLenum type, GLboolean normalized, GLuint value) glVertexAttribP2ui;
	/// Ditto
	__gshared void function(GLuint index, GLenum type, GLboolean normalized, GLuint value) glVertexAttribP3ui;
	/// Ditto
	__gshared void function(GLuint index, GLenum type, GLboolean normalized, GLuint value) glVertexAttribP4ui;
	/// Modify the rate at which generic vertex attributes advance during instanced rendering.
	/// 
	/// glVertexAttribDivisor modifies the rate at which generic vertex attributes advance when rendering
	/// multiple instances of primitives in a single draw call. If divisor is zero, the attribute at slot
	/// index advances once per vertex. If divisor is non-zero, the attribute advances
	/// once per divisor instances of the set(s) of vertices being rendered. An attribute
	/// is referred to as instanced if its GL_VERTEX_ATTRIB_ARRAY_DIVISOR value is non-zero.
	/// 
	/// 
	/// index must be less than the value of GL_MAX_VERTEX_ATTRIBUTES.
	__gshared void function(GLuint index, GLuint divisor) glVertexAttribDivisor;
	/// Define an array of generic vertex attribute data.
	/// 
	/// glVertexAttribPointer, glVertexAttribIPointer and glVertexAttribLPointer
	/// specify the
	/// location and data format of the array of generic vertex attributes at index index
	/// to use when rendering. size specifies the number of components per attribute and
	/// must be 1, 2, 3, 4, or GL_BGRA. type specifies the data type
	/// of each component, and stride specifies the byte stride from one attribute to the next,
	/// allowing vertices and attributes to be packed into a single array or stored in separate arrays.
	/// 
	/// 
	/// 
	/// For glVertexAttribPointer, if normalized is set to GL_TRUE,
	/// it indicates that values stored in an integer format are to be mapped to the range [-1,1] (for signed values) or [0,1] (for
	/// unsigned values) when they are accessed and converted to floating point. Otherwise, values will
	/// be converted to floats directly without normalization.
	/// 
	/// 
	/// 
	/// For glVertexAttribIPointer, only the integer types GL_BYTE,
	/// GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT,
	/// GL_INT, GL_UNSIGNED_INT are accepted. Values are always left as integer values.
	/// 
	/// 
	/// glVertexAttribLPointer specifies state for a generic vertex attribute array associated
	/// with a shader attribute variable declared with 64-bit double precision components. type
	/// must be GL_DOUBLE. index, size, and
	/// stride behave as described for glVertexAttribPointer and
	/// glVertexAttribIPointer.
	/// 
	/// 
	/// 
	/// If pointer is not NULL, a non-zero named buffer object must be bound to the
	/// GL_ARRAY_BUFFER target (see glBindBuffer),
	/// otherwise an error is generated. pointer is treated as a byte offset into the buffer object's data store.
	/// The buffer object binding (GL_ARRAY_BUFFER_BINDING) is saved as generic vertex attribute array
	/// state (GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING) for index index.
	/// 
	/// 
	/// 
	/// When a generic vertex attribute array is specified,
	/// size, type,
	/// normalized,
	/// stride, and
	/// pointer are saved as vertex array
	/// state, in addition to the current vertex array buffer object binding.
	/// 
	/// 
	/// 
	/// To enable and disable a generic vertex attribute array, call
	/// glEnableVertexAttribArray and
	/// glDisableVertexAttribArray with index.
	/// If enabled, the generic vertex attribute array is used when glDrawArrays,
	/// glMultiDrawArrays, glDrawElements,
	/// glMultiDrawElements, or glDrawRangeElements
	/// is called.
	__gshared void function(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer) glVertexAttribPointer;
	/// Ditto
	__gshared void function(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) glVertexAttribIPointer;
	/// Ditto
	__gshared void function(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) glVertexAttribLPointer;
	/// Set the viewport.
	/// 
	/// glViewport specifies the affine transformation of 
	/// x
	/// and 
	/// y
	/// from
	/// normalized device coordinates to window coordinates.
	/// Let 
	/// xndynd
	/// be normalized device coordinates.
	/// Then the window coordinates 
	/// xwyw
	/// are computed as follows:
	/// 
	/// 
	/// xw=xnd+1width2+x
	/// 
	/// yw=ynd+1height2+y
	/// 
	/// 
	/// Viewport width and height are silently clamped
	/// to a range that depends on the implementation.
	/// To query this range, call glGet with argument
	/// GL_MAX_VIEWPORT_DIMS.
	void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
	/// Set multiple viewports.
	/// 
	/// glViewportArrayv specifies the parameters for multiple viewports
	/// simulataneously. first specifies the index of the first viewport
	/// to modify and count specifies the number of viewports to modify.
	/// first must be less than the value of GL_MAX_VIEWPORTS,
	/// and first + count must be less than or equal to
	/// the value of GL_MAX_VIEWPORTS. Viewports whose indices lie outside
	/// the range [first, first + count$(RPAREN)
	/// are not modified. v contains the address of an array of floating
	/// point values specifying the
	/// left (x),
	/// bottom (y),
	/// width (w),
	/// and height (h)
	/// of each viewport, in that order. x
	/// and y give
	/// the location of the viewport's lower left corner, and
	/// w
	/// and h
	/// give the width and height of the viewport, respectively.
	/// The viewport specifies the affine transformation of 
	/// x
	/// and 
	/// y
	/// from
	/// normalized device coordinates to window coordinates.
	/// Let 
	/// xndynd
	/// be normalized device coordinates.
	/// Then the window coordinates 
	/// xwyw
	/// are computed as follows:
	/// 
	/// 
	/// xw=xnd+1width2+x
	/// 
	/// yw=ynd+1height2+y
	/// 
	/// 
	/// The location of the viewport's bottom left corner, given by
	/// (x, y)
	/// is clamped to be within the implementaiton-dependent viewport bounds range.
	/// The viewport bounds range [min, max]
	/// can be determined by calling glGet with argument
	/// GL_VIEWPORT_BOUNDS_RANGE.
	/// Viewport width and height are silently clamped
	/// to a range that depends on the implementation.
	/// To query this range, call glGet with argument
	/// GL_MAX_VIEWPORT_DIMS.
	/// 
	/// 
	/// 
	/// The precision with which the GL interprets the floating point viewport bounds is implementation-dependent
	/// and may be determined by querying the impementation-defined constant GL_VIEWPORT_SUBPIXEL_BITS.
	__gshared void function(GLuint first, GLsizei count, const GLfloat* v) glViewportArrayv;
	/// Set a specified viewport.
	/// 
	/// glViewportIndexedf and glViewportIndexedfv
	/// specify the parameters for a single viewport.
	/// index specifies the index of the viewport
	/// to modify.
	/// index must be less than the value of GL_MAX_VIEWPORTS.
	/// For glViewportIndexedf, x, y,
	/// w, and h specify the left, bottom, width and height
	/// of the viewport in pixels, respectively.
	/// For glViewportIndexedfv, v contains the address of an array of floating
	/// point values specifying the
	/// left (x),
	/// bottom (y),
	/// width (w),
	/// and height (h)
	/// of each viewport, in that order. x
	/// and y give
	/// the location of the viewport's lower left corner, and
	/// w
	/// and h
	/// give the width and height of the viewport, respectively.
	/// The viewport specifies the affine transformation of 
	/// x
	/// and 
	/// y
	/// from
	/// normalized device coordinates to window coordinates.
	/// Let 
	/// xndynd
	/// be normalized device coordinates.
	/// Then the window coordinates 
	/// xwyw
	/// are computed as follows:
	/// 
	/// 
	/// xw=xnd+1width2+x
	/// 
	/// yw=ynd+1height2+y
	/// 
	/// 
	/// The location of the viewport's bottom left corner, given by
	/// (x, y)
	/// is clamped to be within the implementaiton-dependent viewport bounds range.
	/// The viewport bounds range [min, max]
	/// can be determined by calling glGet with argument
	/// GL_VIEWPORT_BOUNDS_RANGE.
	/// Viewport width and height are silently clamped
	/// to a range that depends on the implementation.
	/// To query this range, call glGet with argument
	/// GL_MAX_VIEWPORT_DIMS.
	/// 
	/// 
	/// 
	/// The precision with which the GL interprets the floating point viewport bounds is implementation-dependent
	/// and may be determined by querying the impementation-defined constant GL_VIEWPORT_SUBPIXEL_BITS.
	/// 
	/// 
	/// 
	/// Calling glViewportIndexedfv is equivalent to calling glViewportArray
	/// with first set to index, count set to
	/// 1 and v passsed directly. glViewportIndexedf is equivalent
	/// to:
	__gshared void function(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) glViewportIndexedf;
	/// Ditto
	__gshared void function(GLuint index, const GLfloat* v) glViewportIndexedfv;
	/// Instruct the GL server to block until the specified sync object becomes signaled.
	/// 
	/// glWaitSync causes the GL server to block and wait until sync becomes signaled. sync
	/// is the name of an existing sync object upon which to wait. flags and timeout are currently not used and
	/// must be set to zero and the special value GL_TIMEOUT_IGNORED, respectivelyflags and
	/// timeout are placeholders for anticipated future extensions of sync object capabilities. They must have these reserved values in
	/// order that existing code calling glWaitSync operate properly in the presence of such extensions.. glWaitSync will always wait no longer than an implementation-dependent timeout. The
	/// duration of this timeout in nanoseconds may be queried by calling glGet with the
	/// parameter GL_MAX_SERVER_WAIT_TIMEOUT. There is currently no way to determine whether glWaitSync unblocked
	/// because the timeout expired or because the sync object being waited on was signaled.
	/// 
	/// 
	/// flags and
	/// timeout are placeholders for anticipated future extensions of sync object capabilities. They must have these reserved values in
	/// order that existing code calling glWaitSync operate properly in the presence of such extensions.
	/// 
	/// 
	/// If an error occurs, glWaitSync does not cause the GL server to block.
	__gshared void function(GLsync sync, GLbitfield flags, GLint64 timeout) glWaitSync;
}

/// Loads all supported extensions. A valid context must be created and active.
void LoadGLExtensions() {
	glActiveShaderProgram = cast(typeof(glActiveShaderProgram))getExtensionAddress("glActiveShaderProgram");
	glActiveTexture = cast(typeof(glActiveTexture))getExtensionAddress("glActiveTexture");
	glAttachShader = cast(typeof(glAttachShader))getExtensionAddress("glAttachShader");
	glBeginConditionalRender = cast(typeof(glBeginConditionalRender))getExtensionAddress("glBeginConditionalRender");
	glEndConditionalRender = cast(typeof(glEndConditionalRender))getExtensionAddress("glEndConditionalRender");
	glBeginQuery = cast(typeof(glBeginQuery))getExtensionAddress("glBeginQuery");
	glEndQuery = cast(typeof(glEndQuery))getExtensionAddress("glEndQuery");
	glBeginQueryIndexed = cast(typeof(glBeginQueryIndexed))getExtensionAddress("glBeginQueryIndexed");
	glEndQueryIndexed = cast(typeof(glEndQueryIndexed))getExtensionAddress("glEndQueryIndexed");
	glBeginTransformFeedback = cast(typeof(glBeginTransformFeedback))getExtensionAddress("glBeginTransformFeedback");
	glEndTransformFeedback = cast(typeof(glEndTransformFeedback))getExtensionAddress("glEndTransformFeedback");
	glBindAttribLocation = cast(typeof(glBindAttribLocation))getExtensionAddress("glBindAttribLocation");
	glBindBuffer = cast(typeof(glBindBuffer))getExtensionAddress("glBindBuffer");
	glBindBufferBase = cast(typeof(glBindBufferBase))getExtensionAddress("glBindBufferBase");
	glBindBufferRange = cast(typeof(glBindBufferRange))getExtensionAddress("glBindBufferRange");
	glBindFragDataLocation = cast(typeof(glBindFragDataLocation))getExtensionAddress("glBindFragDataLocation");
	glBindFragDataLocationIndexed = cast(typeof(glBindFragDataLocationIndexed))getExtensionAddress("glBindFragDataLocationIndexed");
	glBindFramebuffer = cast(typeof(glBindFramebuffer))getExtensionAddress("glBindFramebuffer");
	glBindImageTexture = cast(typeof(glBindImageTexture))getExtensionAddress("glBindImageTexture");
	glBindProgramPipeline = cast(typeof(glBindProgramPipeline))getExtensionAddress("glBindProgramPipeline");
	glBindRenderbuffer = cast(typeof(glBindRenderbuffer))getExtensionAddress("glBindRenderbuffer");
	glBindSampler = cast(typeof(glBindSampler))getExtensionAddress("glBindSampler");
	glBindTransformFeedback = cast(typeof(glBindTransformFeedback))getExtensionAddress("glBindTransformFeedback");
	glBindVertexArray = cast(typeof(glBindVertexArray))getExtensionAddress("glBindVertexArray");
	glBlendColor = cast(typeof(glBlendColor))getExtensionAddress("glBlendColor");
	glBlendEquation = cast(typeof(glBlendEquation))getExtensionAddress("glBlendEquation");
	glBlendEquationi = cast(typeof(glBlendEquationi))getExtensionAddress("glBlendEquationi");
	glBlendEquationSeparate = cast(typeof(glBlendEquationSeparate))getExtensionAddress("glBlendEquationSeparate");
	glBlendEquationSeparatei = cast(typeof(glBlendEquationSeparatei))getExtensionAddress("glBlendEquationSeparatei");
	glBlendFuncSeparate = cast(typeof(glBlendFuncSeparate))getExtensionAddress("glBlendFuncSeparate");
	glBlendFuncSeparatei = cast(typeof(glBlendFuncSeparatei))getExtensionAddress("glBlendFuncSeparatei");
	glBlitFramebuffer = cast(typeof(glBlitFramebuffer))getExtensionAddress("glBlitFramebuffer");
	glBufferData = cast(typeof(glBufferData))getExtensionAddress("glBufferData");
	glBufferSubData = cast(typeof(glBufferSubData))getExtensionAddress("glBufferSubData");
	glCheckFramebufferStatus = cast(typeof(glCheckFramebufferStatus))getExtensionAddress("glCheckFramebufferStatus");
	glClampColor = cast(typeof(glClampColor))getExtensionAddress("glClampColor");
	glClearBufferiv = cast(typeof(glClearBufferiv))getExtensionAddress("glClearBufferiv");
	glClearBufferuiv = cast(typeof(glClearBufferuiv))getExtensionAddress("glClearBufferuiv");
	glClearBufferfv = cast(typeof(glClearBufferfv))getExtensionAddress("glClearBufferfv");
	glClearBufferfi = cast(typeof(glClearBufferfi))getExtensionAddress("glClearBufferfi");
	glClientWaitSync = cast(typeof(glClientWaitSync))getExtensionAddress("glClientWaitSync");
	glCompileShader = cast(typeof(glCompileShader))getExtensionAddress("glCompileShader");
	glCompressedTexImage1D = cast(typeof(glCompressedTexImage1D))getExtensionAddress("glCompressedTexImage1D");
	glCompressedTexImage2D = cast(typeof(glCompressedTexImage2D))getExtensionAddress("glCompressedTexImage2D");
	glCompressedTexImage3D = cast(typeof(glCompressedTexImage3D))getExtensionAddress("glCompressedTexImage3D");
	glCompressedTexSubImage1D = cast(typeof(glCompressedTexSubImage1D))getExtensionAddress("glCompressedTexSubImage1D");
	glCompressedTexSubImage2D = cast(typeof(glCompressedTexSubImage2D))getExtensionAddress("glCompressedTexSubImage2D");
	glCompressedTexSubImage3D = cast(typeof(glCompressedTexSubImage3D))getExtensionAddress("glCompressedTexSubImage3D");
	glCopyBufferSubData = cast(typeof(glCopyBufferSubData))getExtensionAddress("glCopyBufferSubData");
	glCopyTexSubImage3D = cast(typeof(glCopyTexSubImage3D))getExtensionAddress("glCopyTexSubImage3D");
	glCreateProgram = cast(typeof(glCreateProgram))getExtensionAddress("glCreateProgram");
	glCreateShader = cast(typeof(glCreateShader))getExtensionAddress("glCreateShader");
	glCreateShaderProgramv = cast(typeof(glCreateShaderProgramv))getExtensionAddress("glCreateShaderProgramv");
	glDeleteBuffers = cast(typeof(glDeleteBuffers))getExtensionAddress("glDeleteBuffers");
	glDeleteFramebuffers = cast(typeof(glDeleteFramebuffers))getExtensionAddress("glDeleteFramebuffers");
	glDeleteProgram = cast(typeof(glDeleteProgram))getExtensionAddress("glDeleteProgram");
	glDeleteProgramPipelines = cast(typeof(glDeleteProgramPipelines))getExtensionAddress("glDeleteProgramPipelines");
	glDeleteQueries = cast(typeof(glDeleteQueries))getExtensionAddress("glDeleteQueries");
	glDeleteRenderbuffers = cast(typeof(glDeleteRenderbuffers))getExtensionAddress("glDeleteRenderbuffers");
	glDeleteSamplers = cast(typeof(glDeleteSamplers))getExtensionAddress("glDeleteSamplers");
	glDeleteShader = cast(typeof(glDeleteShader))getExtensionAddress("glDeleteShader");
	glDeleteSync = cast(typeof(glDeleteSync))getExtensionAddress("glDeleteSync");
	glDeleteTransformFeedbacks = cast(typeof(glDeleteTransformFeedbacks))getExtensionAddress("glDeleteTransformFeedbacks");
	glDeleteVertexArrays = cast(typeof(glDeleteVertexArrays))getExtensionAddress("glDeleteVertexArrays");
	glDepthRangeArrayv = cast(typeof(glDepthRangeArrayv))getExtensionAddress("glDepthRangeArrayv");
	glDepthRangeIndexed = cast(typeof(glDepthRangeIndexed))getExtensionAddress("glDepthRangeIndexed");
	glDetachShader = cast(typeof(glDetachShader))getExtensionAddress("glDetachShader");
	glDrawArraysIndirect = cast(typeof(glDrawArraysIndirect))getExtensionAddress("glDrawArraysIndirect");
	glDrawArraysInstanced = cast(typeof(glDrawArraysInstanced))getExtensionAddress("glDrawArraysInstanced");
	glDrawArraysInstancedBaseInstance = cast(typeof(glDrawArraysInstancedBaseInstance))getExtensionAddress("glDrawArraysInstancedBaseInstance");
	glDrawElementsBaseVertex = cast(typeof(glDrawElementsBaseVertex))getExtensionAddress("glDrawElementsBaseVertex");
	glDrawElementsIndirect = cast(typeof(glDrawElementsIndirect))getExtensionAddress("glDrawElementsIndirect");
	glDrawElementsInstanced = cast(typeof(glDrawElementsInstanced))getExtensionAddress("glDrawElementsInstanced");
	glDrawElementsInstancedBaseInstance = cast(typeof(glDrawElementsInstancedBaseInstance))getExtensionAddress("glDrawElementsInstancedBaseInstance");
	glDrawElementsInstancedBaseVertex = cast(typeof(glDrawElementsInstancedBaseVertex))getExtensionAddress("glDrawElementsInstancedBaseVertex");
	glDrawElementsInstancedBaseVertexBaseInstance = cast(typeof(glDrawElementsInstancedBaseVertexBaseInstance))getExtensionAddress("glDrawElementsInstancedBaseVertexBaseInstance");
	glDrawRangeElements = cast(typeof(glDrawRangeElements))getExtensionAddress("glDrawRangeElements");
	glDrawRangeElementsBaseVertex = cast(typeof(glDrawRangeElementsBaseVertex))getExtensionAddress("glDrawRangeElementsBaseVertex");
	glDrawTransformFeedback = cast(typeof(glDrawTransformFeedback))getExtensionAddress("glDrawTransformFeedback");
	glDrawTransformFeedbackInstanced = cast(typeof(glDrawTransformFeedbackInstanced))getExtensionAddress("glDrawTransformFeedbackInstanced");
	glDrawTransformFeedbackStream = cast(typeof(glDrawTransformFeedbackStream))getExtensionAddress("glDrawTransformFeedbackStream");
	glDrawTransformFeedbackStreamInstanced = cast(typeof(glDrawTransformFeedbackStreamInstanced))getExtensionAddress("glDrawTransformFeedbackStreamInstanced");
	glEnableVertexAttribArray = cast(typeof(glEnableVertexAttribArray))getExtensionAddress("glEnableVertexAttribArray");
	glDisableVertexAttribArray = cast(typeof(glDisableVertexAttribArray))getExtensionAddress("glDisableVertexAttribArray");
	glFenceSync = cast(typeof(glFenceSync))getExtensionAddress("glFenceSync");
	glFlushMappedBufferRange = cast(typeof(glFlushMappedBufferRange))getExtensionAddress("glFlushMappedBufferRange");
	glFramebufferRenderbuffer = cast(typeof(glFramebufferRenderbuffer))getExtensionAddress("glFramebufferRenderbuffer");
	glFramebufferTexture = cast(typeof(glFramebufferTexture))getExtensionAddress("glFramebufferTexture");
	glFramebufferTexture1D = cast(typeof(glFramebufferTexture1D))getExtensionAddress("glFramebufferTexture1D");
	glFramebufferTexture2D = cast(typeof(glFramebufferTexture2D))getExtensionAddress("glFramebufferTexture2D");
	glFramebufferTexture3D = cast(typeof(glFramebufferTexture3D))getExtensionAddress("glFramebufferTexture3D");
	glFramebufferTextureLayer = cast(typeof(glFramebufferTextureLayer))getExtensionAddress("glFramebufferTextureLayer");
	glGenBuffers = cast(typeof(glGenBuffers))getExtensionAddress("glGenBuffers");
	glGenerateMipmap = cast(typeof(glGenerateMipmap))getExtensionAddress("glGenerateMipmap");
	glGenFramebuffers = cast(typeof(glGenFramebuffers))getExtensionAddress("glGenFramebuffers");
	glGenProgramPipelines = cast(typeof(glGenProgramPipelines))getExtensionAddress("glGenProgramPipelines");
	glGenQueries = cast(typeof(glGenQueries))getExtensionAddress("glGenQueries");
	glGenRenderbuffers = cast(typeof(glGenRenderbuffers))getExtensionAddress("glGenRenderbuffers");
	glGenSamplers = cast(typeof(glGenSamplers))getExtensionAddress("glGenSamplers");
	glGenTransformFeedbacks = cast(typeof(glGenTransformFeedbacks))getExtensionAddress("glGenTransformFeedbacks");
	glGenVertexArrays = cast(typeof(glGenVertexArrays))getExtensionAddress("glGenVertexArrays");
	glGetInteger64v = cast(typeof(glGetInteger64v))getExtensionAddress("glGetInteger64v");
	glGetBooleani_v = cast(typeof(glGetBooleani_v))getExtensionAddress("glGetBooleani_v");
	glGetIntegeri_v = cast(typeof(glGetIntegeri_v))getExtensionAddress("glGetIntegeri_v");
	glGetInteger64i_v = cast(typeof(glGetInteger64i_v))getExtensionAddress("glGetInteger64i_v");
	glGetActiveAtomicCounterBufferiv = cast(typeof(glGetActiveAtomicCounterBufferiv))getExtensionAddress("glGetActiveAtomicCounterBufferiv");
	glGetActiveAttrib = cast(typeof(glGetActiveAttrib))getExtensionAddress("glGetActiveAttrib");
	glGetActiveSubroutineName = cast(typeof(glGetActiveSubroutineName))getExtensionAddress("glGetActiveSubroutineName");
	glGetActiveSubroutineUniformiv = cast(typeof(glGetActiveSubroutineUniformiv))getExtensionAddress("glGetActiveSubroutineUniformiv");
	glGetActiveSubroutineUniformName = cast(typeof(glGetActiveSubroutineUniformName))getExtensionAddress("glGetActiveSubroutineUniformName");
	glGetActiveUniform = cast(typeof(glGetActiveUniform))getExtensionAddress("glGetActiveUniform");
	glGetActiveUniformBlockiv = cast(typeof(glGetActiveUniformBlockiv))getExtensionAddress("glGetActiveUniformBlockiv");
	glGetActiveUniformBlockName = cast(typeof(glGetActiveUniformBlockName))getExtensionAddress("glGetActiveUniformBlockName");
	glGetActiveUniformName = cast(typeof(glGetActiveUniformName))getExtensionAddress("glGetActiveUniformName");
	glGetActiveUniformsiv = cast(typeof(glGetActiveUniformsiv))getExtensionAddress("glGetActiveUniformsiv");
	glGetAttachedShaders = cast(typeof(glGetAttachedShaders))getExtensionAddress("glGetAttachedShaders");
	glGetAttribLocation = cast(typeof(glGetAttribLocation))getExtensionAddress("glGetAttribLocation");
	glGetBufferParameteriv = cast(typeof(glGetBufferParameteriv))getExtensionAddress("glGetBufferParameteriv");
	glGetBufferPointerv = cast(typeof(glGetBufferPointerv))getExtensionAddress("glGetBufferPointerv");
	glGetBufferSubData = cast(typeof(glGetBufferSubData))getExtensionAddress("glGetBufferSubData");
	glGetCompressedTexImage = cast(typeof(glGetCompressedTexImage))getExtensionAddress("glGetCompressedTexImage");
	glGetFragDataIndex = cast(typeof(glGetFragDataIndex))getExtensionAddress("glGetFragDataIndex");
	glGetFragDataLocation = cast(typeof(glGetFragDataLocation))getExtensionAddress("glGetFragDataLocation");
	glGetFramebufferAttachmentParameter = cast(typeof(glGetFramebufferAttachmentParameter))getExtensionAddress("glGetFramebufferAttachmentParameter");
	glGetInternalFormativ = cast(typeof(glGetInternalFormativ))getExtensionAddress("glGetInternalFormativ");
	glGetMultisamplefv = cast(typeof(glGetMultisamplefv))getExtensionAddress("glGetMultisamplefv");
	glGetProgramiv = cast(typeof(glGetProgramiv))getExtensionAddress("glGetProgramiv");
	glGetProgramBinary = cast(typeof(glGetProgramBinary))getExtensionAddress("glGetProgramBinary");
	glGetProgramInfoLog = cast(typeof(glGetProgramInfoLog))getExtensionAddress("glGetProgramInfoLog");
	glGetProgramPipelineiv = cast(typeof(glGetProgramPipelineiv))getExtensionAddress("glGetProgramPipelineiv");
	glGetProgramPipelineInfoLog = cast(typeof(glGetProgramPipelineInfoLog))getExtensionAddress("glGetProgramPipelineInfoLog");
	glGetProgramStageiv = cast(typeof(glGetProgramStageiv))getExtensionAddress("glGetProgramStageiv");
	glGetQueryIndexediv = cast(typeof(glGetQueryIndexediv))getExtensionAddress("glGetQueryIndexediv");
	glGetQueryiv = cast(typeof(glGetQueryiv))getExtensionAddress("glGetQueryiv");
	glGetQueryObjectiv = cast(typeof(glGetQueryObjectiv))getExtensionAddress("glGetQueryObjectiv");
	glGetQueryObjectuiv = cast(typeof(glGetQueryObjectuiv))getExtensionAddress("glGetQueryObjectuiv");
	glGetQueryObjecti64v = cast(typeof(glGetQueryObjecti64v))getExtensionAddress("glGetQueryObjecti64v");
	glGetQueryObjectui64v = cast(typeof(glGetQueryObjectui64v))getExtensionAddress("glGetQueryObjectui64v");
	glGetRenderbufferParameteriv = cast(typeof(glGetRenderbufferParameteriv))getExtensionAddress("glGetRenderbufferParameteriv");
	glGetSamplerParameterfv = cast(typeof(glGetSamplerParameterfv))getExtensionAddress("glGetSamplerParameterfv");
	glGetSamplerParameteriv = cast(typeof(glGetSamplerParameteriv))getExtensionAddress("glGetSamplerParameteriv");
	glGetShaderiv = cast(typeof(glGetShaderiv))getExtensionAddress("glGetShaderiv");
	glGetShaderInfoLog = cast(typeof(glGetShaderInfoLog))getExtensionAddress("glGetShaderInfoLog");
	glGetShaderPrecisionFormat = cast(typeof(glGetShaderPrecisionFormat))getExtensionAddress("glGetShaderPrecisionFormat");
	glGetShaderSource = cast(typeof(glGetShaderSource))getExtensionAddress("glGetShaderSource");
	glGetSubroutineIndex = cast(typeof(glGetSubroutineIndex))getExtensionAddress("glGetSubroutineIndex");
	glGetSubroutineUniformLocation = cast(typeof(glGetSubroutineUniformLocation))getExtensionAddress("glGetSubroutineUniformLocation");
	glGetSynciv = cast(typeof(glGetSynciv))getExtensionAddress("glGetSynciv");
	glGetTexParameterIiv = cast(typeof(glGetTexParameterIiv))getExtensionAddress("glGetTexParameterIiv");
	glGetTexParameterIuiv = cast(typeof(glGetTexParameterIuiv))getExtensionAddress("glGetTexParameterIuiv");
	glGetTransformFeedbackVarying = cast(typeof(glGetTransformFeedbackVarying))getExtensionAddress("glGetTransformFeedbackVarying");
	glGetUniformfv = cast(typeof(glGetUniformfv))getExtensionAddress("glGetUniformfv");
	glGetUniformiv = cast(typeof(glGetUniformiv))getExtensionAddress("glGetUniformiv");
	glGetUniformBlockIndex = cast(typeof(glGetUniformBlockIndex))getExtensionAddress("glGetUniformBlockIndex");
	glGetUniformIndices = cast(typeof(glGetUniformIndices))getExtensionAddress("glGetUniformIndices");
	glGetUniformLocation = cast(typeof(glGetUniformLocation))getExtensionAddress("glGetUniformLocation");
	glGetUniformSubroutineuiv = cast(typeof(glGetUniformSubroutineuiv))getExtensionAddress("glGetUniformSubroutineuiv");
	glGetVertexAttribdv = cast(typeof(glGetVertexAttribdv))getExtensionAddress("glGetVertexAttribdv");
	glGetVertexAttribfv = cast(typeof(glGetVertexAttribfv))getExtensionAddress("glGetVertexAttribfv");
	glGetVertexAttribiv = cast(typeof(glGetVertexAttribiv))getExtensionAddress("glGetVertexAttribiv");
	glGetVertexAttribIiv = cast(typeof(glGetVertexAttribIiv))getExtensionAddress("glGetVertexAttribIiv");
	glGetVertexAttribIuiv = cast(typeof(glGetVertexAttribIuiv))getExtensionAddress("glGetVertexAttribIuiv");
	glGetVertexAttribLdv = cast(typeof(glGetVertexAttribLdv))getExtensionAddress("glGetVertexAttribLdv");
	glGetVertexAttribPointerv = cast(typeof(glGetVertexAttribPointerv))getExtensionAddress("glGetVertexAttribPointerv");
	glIsBuffer = cast(typeof(glIsBuffer))getExtensionAddress("glIsBuffer");
	glIsFramebuffer = cast(typeof(glIsFramebuffer))getExtensionAddress("glIsFramebuffer");
	glIsProgram = cast(typeof(glIsProgram))getExtensionAddress("glIsProgram");
	glIsProgramPipeline = cast(typeof(glIsProgramPipeline))getExtensionAddress("glIsProgramPipeline");
	glIsQuery = cast(typeof(glIsQuery))getExtensionAddress("glIsQuery");
	glIsRenderbuffer = cast(typeof(glIsRenderbuffer))getExtensionAddress("glIsRenderbuffer");
	glIsSampler = cast(typeof(glIsSampler))getExtensionAddress("glIsSampler");
	glIsShader = cast(typeof(glIsShader))getExtensionAddress("glIsShader");
	glIsSync = cast(typeof(glIsSync))getExtensionAddress("glIsSync");
	glIsTransformFeedback = cast(typeof(glIsTransformFeedback))getExtensionAddress("glIsTransformFeedback");
	glIsVertexArray = cast(typeof(glIsVertexArray))getExtensionAddress("glIsVertexArray");
	glLinkProgram = cast(typeof(glLinkProgram))getExtensionAddress("glLinkProgram");
	glMapBuffer = cast(typeof(glMapBuffer))getExtensionAddress("glMapBuffer");
	glUnmapBuffer = cast(typeof(glUnmapBuffer))getExtensionAddress("glUnmapBuffer");
	glMapBufferRange = cast(typeof(glMapBufferRange))getExtensionAddress("glMapBufferRange");
	glMemoryBarrier = cast(typeof(glMemoryBarrier))getExtensionAddress("glMemoryBarrier");
	glMinSampleShading = cast(typeof(glMinSampleShading))getExtensionAddress("glMinSampleShading");
	glMultiDrawArrays = cast(typeof(glMultiDrawArrays))getExtensionAddress("glMultiDrawArrays");
	glMultiDrawElements = cast(typeof(glMultiDrawElements))getExtensionAddress("glMultiDrawElements");
	glMultiDrawElementsBaseVertex = cast(typeof(glMultiDrawElementsBaseVertex))getExtensionAddress("glMultiDrawElementsBaseVertex");
	glPatchParameteri = cast(typeof(glPatchParameteri))getExtensionAddress("glPatchParameteri");
	glPatchParameterfv = cast(typeof(glPatchParameterfv))getExtensionAddress("glPatchParameterfv");
	glPauseTransformFeedback = cast(typeof(glPauseTransformFeedback))getExtensionAddress("glPauseTransformFeedback");
	glPointParameterf = cast(typeof(glPointParameterf))getExtensionAddress("glPointParameterf");
	glPointParameteri = cast(typeof(glPointParameteri))getExtensionAddress("glPointParameteri");
	glPointParameterfv = cast(typeof(glPointParameterfv))getExtensionAddress("glPointParameterfv");
	glPointParameteriv = cast(typeof(glPointParameteriv))getExtensionAddress("glPointParameteriv");
	glPrimitiveRestartIndex = cast(typeof(glPrimitiveRestartIndex))getExtensionAddress("glPrimitiveRestartIndex");
	glProgramBinary = cast(typeof(glProgramBinary))getExtensionAddress("glProgramBinary");
	glProgramParameteri = cast(typeof(glProgramParameteri))getExtensionAddress("glProgramParameteri");
	glProgramUniform1f = cast(typeof(glProgramUniform1f))getExtensionAddress("glProgramUniform1f");
	glProgramUniform2f = cast(typeof(glProgramUniform2f))getExtensionAddress("glProgramUniform2f");
	glProgramUniform3f = cast(typeof(glProgramUniform3f))getExtensionAddress("glProgramUniform3f");
	glProgramUniform4f = cast(typeof(glProgramUniform4f))getExtensionAddress("glProgramUniform4f");
	glProgramUniform1i = cast(typeof(glProgramUniform1i))getExtensionAddress("glProgramUniform1i");
	glProgramUniform2i = cast(typeof(glProgramUniform2i))getExtensionAddress("glProgramUniform2i");
	glProgramUniform3i = cast(typeof(glProgramUniform3i))getExtensionAddress("glProgramUniform3i");
	glProgramUniform4i = cast(typeof(glProgramUniform4i))getExtensionAddress("glProgramUniform4i");
	glProgramUniform1ui = cast(typeof(glProgramUniform1ui))getExtensionAddress("glProgramUniform1ui");
	glProgramUniform2ui = cast(typeof(glProgramUniform2ui))getExtensionAddress("glProgramUniform2ui");
	glProgramUniform3ui = cast(typeof(glProgramUniform3ui))getExtensionAddress("glProgramUniform3ui");
	glProgramUniform4ui = cast(typeof(glProgramUniform4ui))getExtensionAddress("glProgramUniform4ui");
	glProgramUniform1fv = cast(typeof(glProgramUniform1fv))getExtensionAddress("glProgramUniform1fv");
	glProgramUniform2fv = cast(typeof(glProgramUniform2fv))getExtensionAddress("glProgramUniform2fv");
	glProgramUniform3fv = cast(typeof(glProgramUniform3fv))getExtensionAddress("glProgramUniform3fv");
	glProgramUniform4fv = cast(typeof(glProgramUniform4fv))getExtensionAddress("glProgramUniform4fv");
	glProgramUniform1iv = cast(typeof(glProgramUniform1iv))getExtensionAddress("glProgramUniform1iv");
	glProgramUniform2iv = cast(typeof(glProgramUniform2iv))getExtensionAddress("glProgramUniform2iv");
	glProgramUniform3iv = cast(typeof(glProgramUniform3iv))getExtensionAddress("glProgramUniform3iv");
	glProgramUniform4iv = cast(typeof(glProgramUniform4iv))getExtensionAddress("glProgramUniform4iv");
	glProgramUniform1uiv = cast(typeof(glProgramUniform1uiv))getExtensionAddress("glProgramUniform1uiv");
	glProgramUniform2uiv = cast(typeof(glProgramUniform2uiv))getExtensionAddress("glProgramUniform2uiv");
	glProgramUniform3uiv = cast(typeof(glProgramUniform3uiv))getExtensionAddress("glProgramUniform3uiv");
	glProgramUniform4uiv = cast(typeof(glProgramUniform4uiv))getExtensionAddress("glProgramUniform4uiv");
	glProgramUniformMatrix2fv = cast(typeof(glProgramUniformMatrix2fv))getExtensionAddress("glProgramUniformMatrix2fv");
	glProgramUniformMatrix3fv = cast(typeof(glProgramUniformMatrix3fv))getExtensionAddress("glProgramUniformMatrix3fv");
	glProgramUniformMatrix4fv = cast(typeof(glProgramUniformMatrix4fv))getExtensionAddress("glProgramUniformMatrix4fv");
	glProgramUniformMatrix2x3fv = cast(typeof(glProgramUniformMatrix2x3fv))getExtensionAddress("glProgramUniformMatrix2x3fv");
	glProgramUniformMatrix3x2fv = cast(typeof(glProgramUniformMatrix3x2fv))getExtensionAddress("glProgramUniformMatrix3x2fv");
	glProgramUniformMatrix2x4fv = cast(typeof(glProgramUniformMatrix2x4fv))getExtensionAddress("glProgramUniformMatrix2x4fv");
	glProgramUniformMatrix4x2fv = cast(typeof(glProgramUniformMatrix4x2fv))getExtensionAddress("glProgramUniformMatrix4x2fv");
	glProgramUniformMatrix3x4fv = cast(typeof(glProgramUniformMatrix3x4fv))getExtensionAddress("glProgramUniformMatrix3x4fv");
	glProgramUniformMatrix4x3fv = cast(typeof(glProgramUniformMatrix4x3fv))getExtensionAddress("glProgramUniformMatrix4x3fv");
	glProvokingVertex = cast(typeof(glProvokingVertex))getExtensionAddress("glProvokingVertex");
	glQueryCounter = cast(typeof(glQueryCounter))getExtensionAddress("glQueryCounter");
	glReleaseShaderCompiler = cast(typeof(glReleaseShaderCompiler))getExtensionAddress("glReleaseShaderCompiler");
	glRenderbufferStorage = cast(typeof(glRenderbufferStorage))getExtensionAddress("glRenderbufferStorage");
	glRenderbufferStorageMultisample = cast(typeof(glRenderbufferStorageMultisample))getExtensionAddress("glRenderbufferStorageMultisample");
	glResumeTransformFeedback = cast(typeof(glResumeTransformFeedback))getExtensionAddress("glResumeTransformFeedback");
	glSampleCoverage = cast(typeof(glSampleCoverage))getExtensionAddress("glSampleCoverage");
	glSampleMaski = cast(typeof(glSampleMaski))getExtensionAddress("glSampleMaski");
	glSamplerParameterf = cast(typeof(glSamplerParameterf))getExtensionAddress("glSamplerParameterf");
	glSamplerParameteri = cast(typeof(glSamplerParameteri))getExtensionAddress("glSamplerParameteri");
	glSamplerParameterfv = cast(typeof(glSamplerParameterfv))getExtensionAddress("glSamplerParameterfv");
	glSamplerParameteriv = cast(typeof(glSamplerParameteriv))getExtensionAddress("glSamplerParameteriv");
	glScissorArrayv = cast(typeof(glScissorArrayv))getExtensionAddress("glScissorArrayv");
	glScissorIndexed = cast(typeof(glScissorIndexed))getExtensionAddress("glScissorIndexed");
	glScissorIndexedv = cast(typeof(glScissorIndexedv))getExtensionAddress("glScissorIndexedv");
	glShaderBinary = cast(typeof(glShaderBinary))getExtensionAddress("glShaderBinary");
	glShaderSource = cast(typeof(glShaderSource))getExtensionAddress("glShaderSource");
	glStencilFuncSeparate = cast(typeof(glStencilFuncSeparate))getExtensionAddress("glStencilFuncSeparate");
	glStencilMaskSeparate = cast(typeof(glStencilMaskSeparate))getExtensionAddress("glStencilMaskSeparate");
	glStencilOpSeparate = cast(typeof(glStencilOpSeparate))getExtensionAddress("glStencilOpSeparate");
	glTexBuffer = cast(typeof(glTexBuffer))getExtensionAddress("glTexBuffer");
	glTexImage2DMultisample = cast(typeof(glTexImage2DMultisample))getExtensionAddress("glTexImage2DMultisample");
	glTexImage3D = cast(typeof(glTexImage3D))getExtensionAddress("glTexImage3D");
	glTexImage3DMultisample = cast(typeof(glTexImage3DMultisample))getExtensionAddress("glTexImage3DMultisample");
	glTexParameterIiv = cast(typeof(glTexParameterIiv))getExtensionAddress("glTexParameterIiv");
	glTexParameterIuiv = cast(typeof(glTexParameterIuiv))getExtensionAddress("glTexParameterIuiv");
	glTexStorage1D = cast(typeof(glTexStorage1D))getExtensionAddress("glTexStorage1D");
	glTexStorage2D = cast(typeof(glTexStorage2D))getExtensionAddress("glTexStorage2D");
	glTexStorage3D = cast(typeof(glTexStorage3D))getExtensionAddress("glTexStorage3D");
	glTexSubImage3D = cast(typeof(glTexSubImage3D))getExtensionAddress("glTexSubImage3D");
	glTransformFeedbackVaryings = cast(typeof(glTransformFeedbackVaryings))getExtensionAddress("glTransformFeedbackVaryings");
	glUniform1f = cast(typeof(glUniform1f))getExtensionAddress("glUniform1f");
	glUniform2f = cast(typeof(glUniform2f))getExtensionAddress("glUniform2f");
	glUniform3f = cast(typeof(glUniform3f))getExtensionAddress("glUniform3f");
	glUniform4f = cast(typeof(glUniform4f))getExtensionAddress("glUniform4f");
	glUniform1i = cast(typeof(glUniform1i))getExtensionAddress("glUniform1i");
	glUniform2i = cast(typeof(glUniform2i))getExtensionAddress("glUniform2i");
	glUniform3i = cast(typeof(glUniform3i))getExtensionAddress("glUniform3i");
	glUniform4i = cast(typeof(glUniform4i))getExtensionAddress("glUniform4i");
	glUniform1ui = cast(typeof(glUniform1ui))getExtensionAddress("glUniform1ui");
	glUniform2ui = cast(typeof(glUniform2ui))getExtensionAddress("glUniform2ui");
	glUniform3ui = cast(typeof(glUniform3ui))getExtensionAddress("glUniform3ui");
	glUniform4ui = cast(typeof(glUniform4ui))getExtensionAddress("glUniform4ui");
	glUniform1fv = cast(typeof(glUniform1fv))getExtensionAddress("glUniform1fv");
	glUniform2fv = cast(typeof(glUniform2fv))getExtensionAddress("glUniform2fv");
	glUniform3fv = cast(typeof(glUniform3fv))getExtensionAddress("glUniform3fv");
	glUniform4fv = cast(typeof(glUniform4fv))getExtensionAddress("glUniform4fv");
	glUniform1iv = cast(typeof(glUniform1iv))getExtensionAddress("glUniform1iv");
	glUniform2iv = cast(typeof(glUniform2iv))getExtensionAddress("glUniform2iv");
	glUniform3iv = cast(typeof(glUniform3iv))getExtensionAddress("glUniform3iv");
	glUniform4iv = cast(typeof(glUniform4iv))getExtensionAddress("glUniform4iv");
	glUniform1uiv = cast(typeof(glUniform1uiv))getExtensionAddress("glUniform1uiv");
	glUniform2uiv = cast(typeof(glUniform2uiv))getExtensionAddress("glUniform2uiv");
	glUniform3uiv = cast(typeof(glUniform3uiv))getExtensionAddress("glUniform3uiv");
	glUniform4uiv = cast(typeof(glUniform4uiv))getExtensionAddress("glUniform4uiv");
	glUniformMatrix2fv = cast(typeof(glUniformMatrix2fv))getExtensionAddress("glUniformMatrix2fv");
	glUniformMatrix3fv = cast(typeof(glUniformMatrix3fv))getExtensionAddress("glUniformMatrix3fv");
	glUniformMatrix4fv = cast(typeof(glUniformMatrix4fv))getExtensionAddress("glUniformMatrix4fv");
	glUniformMatrix2x3fv = cast(typeof(glUniformMatrix2x3fv))getExtensionAddress("glUniformMatrix2x3fv");
	glUniformMatrix3x2fv = cast(typeof(glUniformMatrix3x2fv))getExtensionAddress("glUniformMatrix3x2fv");
	glUniformMatrix2x4fv = cast(typeof(glUniformMatrix2x4fv))getExtensionAddress("glUniformMatrix2x4fv");
	glUniformMatrix4x2fv = cast(typeof(glUniformMatrix4x2fv))getExtensionAddress("glUniformMatrix4x2fv");
	glUniformMatrix3x4fv = cast(typeof(glUniformMatrix3x4fv))getExtensionAddress("glUniformMatrix3x4fv");
	glUniformMatrix4x3fv = cast(typeof(glUniformMatrix4x3fv))getExtensionAddress("glUniformMatrix4x3fv");
	glUniformBlockBinding = cast(typeof(glUniformBlockBinding))getExtensionAddress("glUniformBlockBinding");
	glUniformSubroutinesuiv = cast(typeof(glUniformSubroutinesuiv))getExtensionAddress("glUniformSubroutinesuiv");
	glUseProgram = cast(typeof(glUseProgram))getExtensionAddress("glUseProgram");
	glUseProgramStages = cast(typeof(glUseProgramStages))getExtensionAddress("glUseProgramStages");
	glValidateProgram = cast(typeof(glValidateProgram))getExtensionAddress("glValidateProgram");
	glValidateProgramPipeline = cast(typeof(glValidateProgramPipeline))getExtensionAddress("glValidateProgramPipeline");
	glVertexAttrib1f = cast(typeof(glVertexAttrib1f))getExtensionAddress("glVertexAttrib1f");
	glVertexAttrib1s = cast(typeof(glVertexAttrib1s))getExtensionAddress("glVertexAttrib1s");
	glVertexAttrib1d = cast(typeof(glVertexAttrib1d))getExtensionAddress("glVertexAttrib1d");
	glVertexAttribI1i = cast(typeof(glVertexAttribI1i))getExtensionAddress("glVertexAttribI1i");
	glVertexAttribI1ui = cast(typeof(glVertexAttribI1ui))getExtensionAddress("glVertexAttribI1ui");
	glVertexAttrib2f = cast(typeof(glVertexAttrib2f))getExtensionAddress("glVertexAttrib2f");
	glVertexAttrib2s = cast(typeof(glVertexAttrib2s))getExtensionAddress("glVertexAttrib2s");
	glVertexAttrib2d = cast(typeof(glVertexAttrib2d))getExtensionAddress("glVertexAttrib2d");
	glVertexAttribI2i = cast(typeof(glVertexAttribI2i))getExtensionAddress("glVertexAttribI2i");
	glVertexAttribI2ui = cast(typeof(glVertexAttribI2ui))getExtensionAddress("glVertexAttribI2ui");
	glVertexAttrib3f = cast(typeof(glVertexAttrib3f))getExtensionAddress("glVertexAttrib3f");
	glVertexAttrib3s = cast(typeof(glVertexAttrib3s))getExtensionAddress("glVertexAttrib3s");
	glVertexAttrib3d = cast(typeof(glVertexAttrib3d))getExtensionAddress("glVertexAttrib3d");
	glVertexAttribI3i = cast(typeof(glVertexAttribI3i))getExtensionAddress("glVertexAttribI3i");
	glVertexAttribI3ui = cast(typeof(glVertexAttribI3ui))getExtensionAddress("glVertexAttribI3ui");
	glVertexAttrib4f = cast(typeof(glVertexAttrib4f))getExtensionAddress("glVertexAttrib4f");
	glVertexAttrib4s = cast(typeof(glVertexAttrib4s))getExtensionAddress("glVertexAttrib4s");
	glVertexAttrib4d = cast(typeof(glVertexAttrib4d))getExtensionAddress("glVertexAttrib4d");
	glVertexAttrib4Nub = cast(typeof(glVertexAttrib4Nub))getExtensionAddress("glVertexAttrib4Nub");
	glVertexAttribI4i = cast(typeof(glVertexAttribI4i))getExtensionAddress("glVertexAttribI4i");
	glVertexAttribI4ui = cast(typeof(glVertexAttribI4ui))getExtensionAddress("glVertexAttribI4ui");
	glVertexAttribL1d = cast(typeof(glVertexAttribL1d))getExtensionAddress("glVertexAttribL1d");
	glVertexAttribL2d = cast(typeof(glVertexAttribL2d))getExtensionAddress("glVertexAttribL2d");
	glVertexAttribL3d = cast(typeof(glVertexAttribL3d))getExtensionAddress("glVertexAttribL3d");
	glVertexAttribL4d = cast(typeof(glVertexAttribL4d))getExtensionAddress("glVertexAttribL4d");
	glVertexAttrib1fv = cast(typeof(glVertexAttrib1fv))getExtensionAddress("glVertexAttrib1fv");
	glVertexAttrib1sv = cast(typeof(glVertexAttrib1sv))getExtensionAddress("glVertexAttrib1sv");
	glVertexAttrib1dv = cast(typeof(glVertexAttrib1dv))getExtensionAddress("glVertexAttrib1dv");
	glVertexAttribI1iv = cast(typeof(glVertexAttribI1iv))getExtensionAddress("glVertexAttribI1iv");
	glVertexAttribI1uiv = cast(typeof(glVertexAttribI1uiv))getExtensionAddress("glVertexAttribI1uiv");
	glVertexAttrib2fv = cast(typeof(glVertexAttrib2fv))getExtensionAddress("glVertexAttrib2fv");
	glVertexAttrib2sv = cast(typeof(glVertexAttrib2sv))getExtensionAddress("glVertexAttrib2sv");
	glVertexAttrib2dv = cast(typeof(glVertexAttrib2dv))getExtensionAddress("glVertexAttrib2dv");
	glVertexAttribI2iv = cast(typeof(glVertexAttribI2iv))getExtensionAddress("glVertexAttribI2iv");
	glVertexAttribI2uiv = cast(typeof(glVertexAttribI2uiv))getExtensionAddress("glVertexAttribI2uiv");
	glVertexAttrib3fv = cast(typeof(glVertexAttrib3fv))getExtensionAddress("glVertexAttrib3fv");
	glVertexAttrib3sv = cast(typeof(glVertexAttrib3sv))getExtensionAddress("glVertexAttrib3sv");
	glVertexAttrib3dv = cast(typeof(glVertexAttrib3dv))getExtensionAddress("glVertexAttrib3dv");
	glVertexAttribI3iv = cast(typeof(glVertexAttribI3iv))getExtensionAddress("glVertexAttribI3iv");
	glVertexAttribI3uiv = cast(typeof(glVertexAttribI3uiv))getExtensionAddress("glVertexAttribI3uiv");
	glVertexAttrib4fv = cast(typeof(glVertexAttrib4fv))getExtensionAddress("glVertexAttrib4fv");
	glVertexAttrib4sv = cast(typeof(glVertexAttrib4sv))getExtensionAddress("glVertexAttrib4sv");
	glVertexAttrib4dv = cast(typeof(glVertexAttrib4dv))getExtensionAddress("glVertexAttrib4dv");
	glVertexAttrib4iv = cast(typeof(glVertexAttrib4iv))getExtensionAddress("glVertexAttrib4iv");
	glVertexAttrib4bv = cast(typeof(glVertexAttrib4bv))getExtensionAddress("glVertexAttrib4bv");
	glVertexAttrib4ubv = cast(typeof(glVertexAttrib4ubv))getExtensionAddress("glVertexAttrib4ubv");
	glVertexAttrib4usv = cast(typeof(glVertexAttrib4usv))getExtensionAddress("glVertexAttrib4usv");
	glVertexAttrib4uiv = cast(typeof(glVertexAttrib4uiv))getExtensionAddress("glVertexAttrib4uiv");
	glVertexAttrib4Nbv = cast(typeof(glVertexAttrib4Nbv))getExtensionAddress("glVertexAttrib4Nbv");
	glVertexAttrib4Nsv = cast(typeof(glVertexAttrib4Nsv))getExtensionAddress("glVertexAttrib4Nsv");
	glVertexAttrib4Niv = cast(typeof(glVertexAttrib4Niv))getExtensionAddress("glVertexAttrib4Niv");
	glVertexAttrib4Nubv = cast(typeof(glVertexAttrib4Nubv))getExtensionAddress("glVertexAttrib4Nubv");
	glVertexAttrib4Nusv = cast(typeof(glVertexAttrib4Nusv))getExtensionAddress("glVertexAttrib4Nusv");
	glVertexAttrib4Nuiv = cast(typeof(glVertexAttrib4Nuiv))getExtensionAddress("glVertexAttrib4Nuiv");
	glVertexAttribI4bv = cast(typeof(glVertexAttribI4bv))getExtensionAddress("glVertexAttribI4bv");
	glVertexAttribI4ubv = cast(typeof(glVertexAttribI4ubv))getExtensionAddress("glVertexAttribI4ubv");
	glVertexAttribI4sv = cast(typeof(glVertexAttribI4sv))getExtensionAddress("glVertexAttribI4sv");
	glVertexAttribI4usv = cast(typeof(glVertexAttribI4usv))getExtensionAddress("glVertexAttribI4usv");
	glVertexAttribI4iv = cast(typeof(glVertexAttribI4iv))getExtensionAddress("glVertexAttribI4iv");
	glVertexAttribI4uiv = cast(typeof(glVertexAttribI4uiv))getExtensionAddress("glVertexAttribI4uiv");
	glVertexAttribL1dv = cast(typeof(glVertexAttribL1dv))getExtensionAddress("glVertexAttribL1dv");
	glVertexAttribL2dv = cast(typeof(glVertexAttribL2dv))getExtensionAddress("glVertexAttribL2dv");
	glVertexAttribL3dv = cast(typeof(glVertexAttribL3dv))getExtensionAddress("glVertexAttribL3dv");
	glVertexAttribL4dv = cast(typeof(glVertexAttribL4dv))getExtensionAddress("glVertexAttribL4dv");
	glVertexAttribP1ui = cast(typeof(glVertexAttribP1ui))getExtensionAddress("glVertexAttribP1ui");
	glVertexAttribP2ui = cast(typeof(glVertexAttribP2ui))getExtensionAddress("glVertexAttribP2ui");
	glVertexAttribP3ui = cast(typeof(glVertexAttribP3ui))getExtensionAddress("glVertexAttribP3ui");
	glVertexAttribP4ui = cast(typeof(glVertexAttribP4ui))getExtensionAddress("glVertexAttribP4ui");
	glVertexAttribDivisor = cast(typeof(glVertexAttribDivisor))getExtensionAddress("glVertexAttribDivisor");
	glVertexAttribPointer = cast(typeof(glVertexAttribPointer))getExtensionAddress("glVertexAttribPointer");
	glVertexAttribIPointer = cast(typeof(glVertexAttribIPointer))getExtensionAddress("glVertexAttribIPointer");
	glVertexAttribLPointer = cast(typeof(glVertexAttribLPointer))getExtensionAddress("glVertexAttribLPointer");
	glViewportArrayv = cast(typeof(glViewportArrayv))getExtensionAddress("glViewportArrayv");
	glViewportIndexedf = cast(typeof(glViewportIndexedf))getExtensionAddress("glViewportIndexedf");
	glViewportIndexedfv = cast(typeof(glViewportIndexedfv))getExtensionAddress("glViewportIndexedfv");
	glWaitSync = cast(typeof(glWaitSync))getExtensionAddress("glWaitSync");
}
